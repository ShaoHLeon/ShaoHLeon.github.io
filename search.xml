<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Ubuntu中配置TensorFlow环境</title>
      <link href="/2025/01/25/Python/Ubuntu%E4%B8%AD%E9%85%8D%E7%BD%AETensorFlow%E7%8E%AF%E5%A2%83/"/>
      <url>/2025/01/25/Python/Ubuntu%E4%B8%AD%E9%85%8D%E7%BD%AETensorFlow%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>环境：Ubuntu20.04 x86_64、 anaconda</p></blockquote><h1 id="检查环境"><a href="#检查环境" class="headerlink" title="检查环境"></a>检查环境</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ nvidia-smi</span><br></pre></td></tr></table></figure><p>根据自己的显卡驱动和对应表(<a href="https://blog.csdn.net/ly869915532/article/details/124542362">Tensorflow与Python、CUDA、cuDNN的版本对应表_tensorflow版本对应-CSDN博客</a>)选择合适的CUDA、CUDNN、TensorFlow版本</p><blockquote><p>我的需求：</p><p>CUDA 12.2</p><p>CUDNN 8.9</p><p>TensorFlow 2.15.0</p></blockquote><h1 id="conda创建虚拟环境"><a href="#conda创建虚拟环境" class="headerlink" title="conda创建虚拟环境"></a>conda创建虚拟环境</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ conda create -n tf2 python==3.9</span><br><span class="line">~$ conda activate tf2</span><br></pre></td></tr></table></figure><h1 id="安装CUDA"><a href="#安装CUDA" class="headerlink" title="安装CUDA"></a>安装CUDA</h1><h2 id="搜索包源"><a href="#搜索包源" class="headerlink" title="搜索包源"></a>搜索包源</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(tf2)~$ conda search cudatoolkit</span><br></pre></td></tr></table></figure><p>查看conda是否有包，如果有需要的版本，<code>conda install cudatoolkit=</code>安装。</p><h3 id="没有需要版本的包"><a href="#没有需要版本的包" class="headerlink" title="没有需要版本的包"></a>没有需要版本的包</h3><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>根据自己的显卡驱动和需求选择对应的cuda版本</p><p><a href="https://developer.nvidia.com/cuda-toolkit-archive">CUDA Toolkit Archive | NVIDIA Developer</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(tf2)~$ wget https://developer.download.nvidia.com/compute/cuda/12.2.0/local_installers/cuda_12.2.0_535.54.03_linux.run</span><br><span class="line">(tf2)~$ <span class="built_in">sudo</span> sh cuda_12.2.0_535.54.03_linux.run</span><br></pre></td></tr></table></figure><ol><li><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6dc85544475499997e8606ed30ee875a.png" alt=""></p></li><li><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8eda00e88164002cb3ea78c2efcf45a7.png" alt=""></p></li><li><p>如果已经安装显卡驱动，选择驱动，回车取消，然后移动到install安装<img src="https://i-blog.csdnimg.cn/blog_migrate/88b5eea6fad323b3c180aad8c14801f3.png" alt=""></p></li></ol><h4 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h4><p>为了防止与其他版本的CUDA冲突：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(tf2)~$ nano .bashrc</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &lt;&lt;&lt;cuda&lt;&lt;&lt;</span></span><br><span class="line"><span class="built_in">export</span> DEFAULT_CUDA=/usr/local/cuda-12.1</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$DEFAULT_CUDA</span>/bin:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="string">&quot;<span class="variable">$DEFAULT_CUDA</span>/lib64:<span class="variable">$LD_LIBRARY_PATH</span>&quot;</span></span><br><span class="line"><span class="comment"># 切换CUDA版本</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">switch_cuda</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;12.2&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">export</span> CUDA_PATH=/usr/local/cuda-12.2</span><br><span class="line">    <span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;11.8&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">export</span> CUDA_PATH=/usr/local/cuda-11.8</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Unsupported CUDA version: <span class="variable">$1</span>&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Switched to CUDA 12.1&quot;</span></span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="comment"># 设置路径环境变量</span></span><br><span class="line">    <span class="built_in">export</span> PATH=<span class="variable">$CUDA_PATH</span>/bin:<span class="variable">$PATH</span></span><br><span class="line">    <span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$CUDA_PATH</span>/lib64:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Switched to CUDA <span class="variable">$1</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h4><p>当进入虚拟环境时自动执行<code>switch_cuda 12.2</code>命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(tf2)~$ <span class="built_in">mkdir</span> -p [自己安装anaconda的路径]/anaconda/envs/tf2/etc/conda/activate.d</span><br><span class="line">(tf2)~$ vim [自己安装anaconda的路径]/anaconda/envs/tf2/etc/conda/activate.d/auto_activate.sh</span><br></pre></td></tr></table></figure><p>添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 自动执行 switch_cuda 12.2 命令</span></span><br><span class="line">switch_cuda 12.2</span><br></pre></td></tr></table></figure><p>修改权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(tf2)~$ <span class="built_in">chmod</span> +x [自己安装anaconda的路径]/anaconda/envs/tf2/etc/conda/activate.d/auto_activate.sh</span><br><span class="line">(tf2)~$ <span class="built_in">source</span> .bashrc</span><br><span class="line">~$ conda activate tf2</span><br></pre></td></tr></table></figure><h1 id="安装CUDNN"><a href="#安装CUDNN" class="headerlink" title="安装CUDNN"></a>安装CUDNN</h1><p>根据自己版本的CUDA选择合适的CUDNN</p><h2 id="搜索包源-1"><a href="#搜索包源-1" class="headerlink" title="搜索包源"></a>搜索包源</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(tf2)~$ conda search cudnn</span><br></pre></td></tr></table></figure><p>查看conda是否有包，如果有需要的版本，<code>conda install cudnn=</code>安装。</p><h3 id="没有包"><a href="#没有包" class="headerlink" title="没有包"></a>没有包</h3><p><a href="https://developer.nvidia.com/rdp/cudnn-archive">cuDNN Archive | NVIDIA Developer</a>下载需要的版本</p><p>解压并进入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> include/cudnn*.h /usr/local/cuda-12.2/include/</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> lib/libcudnn* /usr/local/cuda-12.2/lib64/</span><br></pre></td></tr></table></figure><h1 id="安装TensorFlow"><a href="#安装TensorFlow" class="headerlink" title="安装TensorFlow"></a>安装TensorFlow</h1><p>tf 2.13.0及以后的版本都不需要额外<a href="https://so.csdn.net/so/search?q=%E5%AE%89%E8%A3%85tensorflow-gpu&amp;spm=1001.2101.3001.7020">安装tensorflow-gpu</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(tf2)~$ pip install tensorflow==2.15.0 -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><h1 id="查看是否安装成功"><a href="#查看是否安装成功" class="headerlink" title="查看是否安装成功"></a>查看是否安装成功</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(tf2)~$ python</span><br><span class="line">&gt;&gt;&gt; import tensorflow as tf</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(tf.__version__)</span><br><span class="line">2.15.0</span><br><span class="line">&gt;&gt;&gt; gpus = tf.config.list_physical_devices(<span class="string">&#x27;GPU&#x27;</span>)</span><br><span class="line">2025-01-25 13:12:19.957843: I external/local_xla/xla/stream_executor/cuda/cuda_executor.cc:901] successful NUMA node <span class="built_in">read</span> from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero. See more at https://github.com/torvalds/linux/blob/v6.0/Documentation/ABI/testing/sysfs-bus-pci#L344-L355</span><br><span class="line">2025-01-25 13:12:19.978578: I external/local_xla/xla/stream_executor/cuda/cuda_executor.cc:901] successful NUMA node <span class="built_in">read</span> from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero. See more at https://github.com/torvalds/linux/blob/v6.0/Documentation/ABI/testing/sysfs-bus-pci#L344-L355</span><br><span class="line">2025-01-25 13:12:19.978708: I external/local_xla/xla/stream_executor/cuda/cuda_executor.cc:901] successful NUMA node <span class="built_in">read</span> from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero. See more at https://github.com/torvalds/linux/blob/v6.0/Documentation/ABI/testing/sysfs-bus-pci#L344-L355</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">if</span> gpus:</span><br><span class="line">...     <span class="built_in">print</span>(<span class="string">&quot;GPU is available&quot;</span>)</span><br><span class="line">... <span class="keyword">else</span>:</span><br><span class="line">...     <span class="built_in">print</span>(<span class="string">&quot;GPU is not available&quot;</span>)</span><br><span class="line">... </span><br><span class="line">GPU is available</span><br></pre></td></tr></table></figure><hr><p><a href="https://blog.csdn.net/qq_42406643/article/details/109545766">理清GPU、CUDA、CUDA Toolkit、cuDNN关系以及下载安装-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu环境配置 </tag>
            
            <tag> Python </tag>
            
            <tag> TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见英文缩写</title>
      <link href="/2024/12/16/%E5%B8%B8%E8%A7%81%E8%8B%B1%E6%96%87%E7%BC%A9%E5%86%99/"/>
      <url>/2024/12/16/%E5%B8%B8%E8%A7%81%E8%8B%B1%E6%96%87%E7%BC%A9%E5%86%99/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="i-e"><a href="#i-e" class="headerlink" title="i.e."></a>i.e.</h1><ul><li><strong>全称</strong>：<em>id est</em>（拉丁语）  </li><li><strong>含义</strong>：即，也就是说  </li><li><strong>用途</strong>：用于补充说明或解释前面提到的内容，更明确地定义或限定某个概念。  </li><li><strong>示例</strong>：  <ul><li><em>We need to improve the key modules, i.e., the encoder and decoder.</em><br>（我们需要改进关键模块，也就是说，编码器和解码器。）</li></ul></li></ul><h1 id="e-g"><a href="#e-g" class="headerlink" title="e.g."></a>e.g.</h1><ul><li><strong>全称</strong>：<em>exempli gratia</em>（拉丁语）  </li><li><strong>含义</strong>：例如  </li><li><strong>用途</strong>：用于列举一个或多个例子，帮助说明某个观点或情况。  </li><li><strong>示例</strong>：  <ul><li><em>We need to use multiple sensors, e.g., LiDAR, SAR, and hyperspectral cameras.</em><br>（我们需要使用多种传感器，例如激光雷达、合成孔径雷达和高光谱相机。）</li></ul></li></ul><h1 id="etc"><a href="#etc" class="headerlink" title="etc."></a>etc.</h1><ul><li><strong>全称</strong>：<em>et cetera</em>（拉丁语）  </li><li><strong>含义</strong>：等等，诸如此类  </li><li><strong>用途</strong>：用于表示一组类似的例子未完全列举完，可用 <strong>and so on</strong> 替代。  </li><li><strong>示例</strong>：  <ul><li><em>We need various data types such as optical images, SAR data, hyperspectral images, etc.</em><br>（我们需要多种数据类型，例如光学图像、SAR 数据、高光谱图像等等。）</li></ul></li></ul><h1 id="et-al"><a href="#et-al" class="headerlink" title="et al."></a>et al.</h1><ul><li><strong>全称</strong>：<em>et alia</em>（拉丁语）  </li><li><strong>含义</strong>：以及其他人  </li><li><strong>用途</strong>：通常用于学术引用中，当作者人数较多时，用于替代中间部分作者的名字。  </li><li><strong>示例</strong>：  <ul><li><em>This method was proposed by Smith et al. in their 2023 paper.</em><br>（这种方法由 Smith 等人在他们的 2023 年论文中提出。）</li></ul></li></ul><h1 id="viz"><a href="#viz" class="headerlink" title="viz."></a>viz.</h1><ul><li><strong>全称</strong>：<em>videlicet</em>（拉丁语）  </li><li><strong>含义</strong>：即，详细说明  </li><li><strong>用途</strong>：与 <strong>i.e.</strong> 类似，但更正式，通常用于列举或更具体地定义前述内容。  </li><li><strong>示例</strong>：  <ul><li><em>The algorithm has two main components, viz., the feature extractor and the classifier.</em><br>（该算法有两个主要组成部分，即特征提取器和分类器。）</li></ul></li></ul><h1 id="N-B"><a href="#N-B" class="headerlink" title="N.B."></a>N.B.</h1><ul><li><strong>全称</strong>：<em>Nota Bene</em>（拉丁语）  </li><li><strong>含义</strong>：注意  </li><li><strong>用途</strong>：用于引起读者对某一重要事项的注意，相当于 “Note” 或 “Take notice”。  </li><li><strong>示例</strong>：  <ul><li><em>N.B.: All data must be normalized before processing.</em><br>（注意：所有数据在处理之前必须归一化。）</li></ul></li></ul><h1 id="P-S"><a href="#P-S" class="headerlink" title="P.S."></a>P.S.</h1><ul><li><strong>全称</strong>：<em>Post Scriptum</em>（拉丁语）  </li><li><strong>含义</strong>：附言  </li><li><strong>用途</strong>：在信件或文档的正文结束后，补充额外的信息。  </li><li><strong>示例</strong>：  <ul><li><em>P.S.: Don’t forget to send the updated report by Friday.</em><br>（附言：别忘了在周五之前发送更新的报告。）</li></ul></li></ul><h1 id="cf"><a href="#cf" class="headerlink" title="cf."></a>cf.</h1><ul><li><strong>全称</strong>：<em>confer</em>（拉丁语）  </li><li><strong>含义</strong>：参见，对比  </li><li><strong>用途</strong>：用于提示读者参考其他相关文献或信息。  </li><li><strong>示例</strong>：  <ul><li><em>For more details on the algorithm, cf. Smith (2023).</em><br>（有关该算法的更多细节，参见 Smith（2023）。）</li></ul></li></ul><h1 id="a-k-a"><a href="#a-k-a" class="headerlink" title="a.k.a."></a>a.k.a.</h1><ul><li><strong>全称</strong>：<em>also known as</em>  </li><li><strong>含义</strong>：也称为，别名  </li><li><strong>用途</strong>：用于引出某人或事物的别名或别称。  </li><li><strong>示例</strong>：  <ul><li><em>This algorithm, a.k.a. the Smith method, is widely used in image classification.</em><br>（这种算法，也称为 Smith 方法，被广泛应用于图像分类。）</li></ul></li></ul><h1 id="p-a"><a href="#p-a" class="headerlink" title="p.a."></a>p.a.</h1><ul><li><strong>全称</strong>：<em>per annum</em>（拉丁语）  </li><li><strong>含义</strong>：每年  </li><li><strong>用途</strong>：通常用于表示年利率、年收入或其他以年为单位的频率。  </li><li><strong>示例</strong>：  <ul><li><em>The annual growth rate is 5%, p.a.</em><br>（年增长率为每年 5%。）</li></ul></li></ul><h1 id="p-p"><a href="#p-p" class="headerlink" title="p.p."></a>p.p.</h1><ul><li><strong>全称</strong>：<em>per person</em> 或 <em>pro persona</em>（拉丁语）  </li><li><strong>含义</strong>：每人  </li><li><strong>用途</strong>：表示与个人相关的指标，例如每人费用或每人消耗量。  </li><li><strong>示例</strong>：  <ul><li><em>The cost is $50 p.p.</em><br>（费用为每人 50 美元。）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博弈论基础概念</title>
      <link href="/2024/11/16/AI/%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/11/16/AI/%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="博弈论的基本概念"><a href="#博弈论的基本概念" class="headerlink" title="博弈论的基本概念"></a>博弈论的基本概念</h1><p><em>要素：</em></p><ul><li><p>博弈主体（参与人）</p><p>独立决策、独立行动并承担结果的个人或组织。</p></li><li><p>战略（行动）</p><ul><li><p>战略集合（战略空间）</p></li><li><p>战略组合</p><ul><li><p>纯战略</p></li><li><p>混合战略</p></li></ul></li></ul></li><li><p>支付（得益函数）</p><p>参与人战略实施后的效用。</p></li><li><p>信息（知识）</p><ul><li><p>完全信息</p></li><li><p>不完全信息</p></li><li><p>完美信息</p></li><li><p>不完美信息</p></li><li><p>对称信息</p></li><li><p>非对称信息</p></li><li><p>共同知识：博弈问题的结构和参与人完全理性</p></li></ul></li></ul><p><em>规则：</em></p><ul><li><p>参与人</p></li><li><p>行动次序</p></li><li><p>均衡结果</p></li></ul><p><em>博弈：</em></p><p>在一定的环境和规则下，参与人从各自允许的战略集合中选择并加以实施，取得结果的过程。</p><p><em>博弈的解：</em></p><p>在博弈问题的结构和参与人完全理性为共同知识的前提下，所有参与人都预测到的博弈结果，即参与人的<strong>一致性预测</strong>，是共同知识。<br>一致性预测的性质：如果所有参与人都预测一个特定的博弈结果会出现，那么所有参与人都不会利用该预测选择与预测结果不一致的策略。</p><p>博弈的表述：</p><ul><li><p>战略式表述（标准式表述）</p><p>适合静态博弈。</p><p>三要素：</p><ul><li><p>参与人集合 $N={1,2, \dots, n}$</p></li><li><p>每个参与人$i$的战略集合 $S_i = { \dots }$</p></li><li><p>参与人$i$的支付 $u_i$ (支付矩阵)</p></li></ul></li><li><p>扩展式表述（extensive form representation）</p><p>适合动态博弈。</p></li></ul><p><em>博弈论的分类</em></p><ul><li><p>合作博弈论</p></li><li><p>非合作博弈论</p></li></ul><div class="table-container"><table><thead><tr><th></th><th>静态</th><th>动态</th></tr></thead><tbody><tr><td>完全信息</td><td>完全信息静态博弈(NE)</td><td>完全信息动态博弈(SPNE)</td></tr><tr><td>不完全信息</td><td>不完全信息静态博弈(BNE)</td><td>不完全信息动态博弈</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th></th><th>纯战略</th><th>混合战略</th></tr></thead><tbody><tr><td>完美信息</td><td>完全且完美信息纯战略博弈</td><td>完全且完美信息混合战略博弈</td></tr><tr><td>不完美信息</td><td>完全但不完美信息纯战略博弈</td><td>完全但不完美信息混合战略博弈</td></tr></tbody></table></div><h1 id="完全信息静态博弈"><a href="#完全信息静态博弈" class="headerlink" title="完全信息静态博弈"></a>完全信息静态博弈</h1><p><strong>完全信息</strong>：每个参与人对所有其他参与人的特征（包括战略空间、支付函数等）完全了解。</p><p><strong>静态</strong>：所有参与人同时选择行动且只选择一次。<br><strong>同时</strong>：只要每个参与人在选择自己的行动时不知道其他参与人的选择，就是同时行动。</p><p>博弈分析的目的是均衡实现的路径并预测均衡结果。</p><h2 id="占优战略及占优战略均衡"><a href="#占优战略及占优战略均衡" class="headerlink" title="占优战略及占优战略均衡"></a>占优战略及占优战略均衡</h2><h3 id="占优战略"><a href="#占优战略" class="headerlink" title="占优战略"></a>占优战略</h3><p>无论其他玩家选择什么策略，某玩家总是会选择的最优策略。 即这种策略在任何情况下都比其他策略带来的收益更高或至少不低。</p><p>严格占优战略：</p><script type="math/tex; mode=display">u_i(s_i', s_{-i}) > u_i(s_i, s_{-i}), \quad \forall s_i \neq s_i', \forall s_{-i}</script><p>  不论其他人选择什么战略，$s’$是参与人唯一的最优战略</p><p>弱占优战略：</p><script type="math/tex; mode=display">u_i(s_i', s_{-i}) \geq u_i(s_i, s_{-i}), \quad \forall s_i \neq s_i', \forall s_{-i}</script><h3 id="重复剔除的占优战略均衡"><a href="#重复剔除的占优战略均衡" class="headerlink" title="重复剔除的占优战略均衡"></a>重复剔除的占优战略均衡</h3><p>  首先找到某个参与人的<mark>严格劣战略</mark>（假定存在），把这个严格劣战略剔除掉，重新构造一个不包含已剔除战略的新的博弈，然后再剔除这个新的博弈中的某个参与人的严格劣战略，一直重复这个过程，直到只剩下唯一的战略组合为止。这个唯一剩下的<u>战略组合</u>就是这个博弈的均衡解，称为“重复剔除的占优战略均衡”，这个唯一的解也是该博弈唯一的NE。</p><p>  面对同样博弈支付矩阵，通过剔除弱被占优战略的方法求解时，剔除战略的顺序不同，得到的均衡解也可能不同。因此不建议采用剔除弱被占优战略的方法寻找博弈均衡。</p><p><mark>注：</mark></p><ul><li><p>重复剔除的占优均衡结果与劣战略的剔除顺序是否有关取决于剔除的是否是严格劣战略。</p></li><li><p>重复剔除的占优战略均衡要求每个参与人是理性的，而且要求“理性”是参与人的共同知识。即：所有参与人知道所有参与是理性的，所有参与人知道所有参与人知道所有参与是理性的。</p></li></ul><h2 id="纳什均衡-Nash-Equilibrium-NE"><a href="#纳什均衡-Nash-Equilibrium-NE" class="headerlink" title="纳什均衡(Nash Equilibrium,NE)"></a>纳什均衡(Nash Equilibrium,NE)</h2><p>针对其他参与人的每种战略找出自己的最佳应对战略。</p><h3 id="最佳反应-Best-Response"><a href="#最佳反应-Best-Response" class="headerlink" title="最佳反应(Best Response)"></a>最佳反应(Best Response)</h3><p>一个玩家的最佳反应是指，给定其他玩家的策略时，使该玩家收益最大的策略选择。</p><p>对于参与者$i$的最佳战略组合$s<em>i’$、战略空间$S_i，和其他参与者组合$s</em>{-i}$：</p><script type="math/tex; mode=display">b_i(s_{-i}) = \{s_i \in S_i \mid u_i(s_i, s_{-i}) \geq u_i(s_i', s_{-i}), \forall s_i' \in S_i \}</script><h3 id="纳什均衡"><a href="#纳什均衡" class="headerlink" title="纳什均衡"></a>纳什均衡</h3><p>在博弈$G = { S<em>1, \dots , S_n; u_1, \dots , u_n }$ 中，如果战略组合 $(s_1^<em>, \dots , s_n^</em>) $ 中任意参与人$i$的战略 $s_i^<em>$ 都是其余参与人的战略组合 $(s_1^</em>, \dots , s</em>{i-1}^<em>, s_{i+1}^</em>, \dots ,s_{n}^<em>)$ 的最佳反应， 则 $ (s_1^</em>, \dots , s_n^*) $ 为博弈的一个NE。</p><p>双方在给定的战略下不愿意调整自己的战略。</p><h3 id="划线法寻找纳什均衡"><a href="#划线法寻找纳什均衡" class="headerlink" title="划线法寻找纳什均衡"></a>划线法寻找纳什均衡</h3><ol><li><strong>确定最佳反应</strong>：</li></ol><ul><li><p>对于每个玩家，在固定对手策略时找到自己的最佳反应。</p></li><li><p>在收益矩阵中，对每个玩家的最佳反应进行标记（如画线或圈出最高收益）。</p></li></ul><ol><li><strong>确定交点</strong>：</li></ol><ul><li>如果某个格子的所有玩家策略均是最佳反应，则该格子对应的策略组合为纳什均衡。</li></ul><h3 id="均衡的稳定性"><a href="#均衡的稳定性" class="headerlink" title="均衡的稳定性"></a>均衡的稳定性</h3><ul><li><p>纳什均衡是所有参与人共同的信念</p></li><li><p>纳什均衡具有“自实施” 的性质，参与人各自独立地追求自身利益，单独偏离没有意义。</p></li></ul><h3 id="均衡的存在性"><a href="#均衡的存在性" class="headerlink" title="均衡的存在性"></a>均衡的存在性</h3><ol><li><p>每一个有限的战略式博弈至少存在一个Nash均衡（包括纯战略和混合战略Nash均衡）。</p></li><li><p>对于战略式博弈 $ 𝑮 = {𝑵, 𝑺<em>𝒊 , 𝑼</em>𝒊 } $，若 $ 𝑺<em>𝒊$ 为欧氏空间的非空紧凸子集，支付函数 $𝑼</em>𝒊$ 关于战略组合 $ 𝑺$ 连续、关于 $𝒔_𝒊$ 拟凹，则该博弈存在纯战略的Nash均衡。</p></li><li><p>对于战略式博弈 $𝑮 = {𝑵, 𝑺<em>𝒊 , 𝑼</em>𝒊 }$，若战略空间 $𝑺<em>𝒊 = {𝒔</em>𝒊 }$为距离空间中的非空紧子集，支付函数 $𝒖_𝒊 $ 关于战略组合s连续，则该博弈存在混合战略的Nash均衡。</p></li><li><p>对于战略式博弈 $𝑮 = {𝑵, 𝑺<em>𝒊 , 𝑼</em>𝒊 }$ ，若对于所有的𝒊, $𝑺<em>𝒊$ 为有限维欧氏空间的非空紧凸子集； $𝒖</em>𝒊$ 关于 $𝒔<em>𝒊$ 拟凹、关于s上半连续且 $ \max 𝒖</em>𝒊 (𝒔<em>𝒊 , 𝒔</em>−𝒊 ) $关于 $𝑺_{−𝒊}$ 连续，则该博弈存在一个纯战略的Nash均衡。</p></li><li><p>若博弈存在两个纯战略纳什均衡，则一定还存在一个混合战略纳什均衡。</p></li></ol><h3 id="纳什均衡与占优战略均衡及重复剔除的占优均衡"><a href="#纳什均衡与占优战略均衡及重复剔除的占优均衡" class="headerlink" title="纳什均衡与占优战略均衡及重复剔除的占优均衡"></a>纳什均衡与占优战略均衡及重复剔除的占优均衡</h3><p>  每一个占优战略均衡及重复剔除的占优均衡一定是纳什均衡，但并非每一个纳什均衡都是占优战略均衡或重复剔除的占优均衡</p><p>  纳什均衡一定是在重复剔除严格劣战略过程中没有被剔除掉的战略组合，但没有被剔除掉的组合不一定是纳什均衡，除非它是唯一的（不适用于弱劣战略的情况）</p><h2 id="混合战略-mixed-strategy"><a href="#混合战略-mixed-strategy" class="headerlink" title="混合战略(mixed strategy)"></a>混合战略(mixed strategy)</h2><p>在博弈 $G = { S<em>1, \dots , S_n; u_1, \dots , u_n }$ 中，参与人$i$的战略空间 $S_i = {s</em>{i1}, \dots ,s<em>{ik} }$ ，则参与人$i$以概率分布 $p_i = (p</em>{i1}, \dots, p_{ik})$，随机选择其$k$个可选战略。</p><blockquote><p><em>纯战略(pure strategies)</em>：如果一个战略规定参与人在一个给定的信息情况下只选择一种特定的行动。<br><em>混合战略(mixed strategies)</em>：如果一个战略规定参与人在给定的信息情况下，以某种概率分布随机地选择不同的行动。<br>在静态博弈里，纯战略等价于特定行动，混合战略是不同行动之间的随机选择。</p></blockquote><h3 id="混合战略纳什均衡的求解"><a href="#混合战略纳什均衡的求解" class="headerlink" title="混合战略纳什均衡的求解"></a>混合战略纳什均衡的求解</h3><p>与混合战略相伴随的一个问题是 <strong>支付的不确定性</strong> (Uncertainty)。为了量化这种不确定性，可以使用 <strong>期望支付</strong> (Expected Payoff) 的概念。</p><p>参与者$i$支付可以取 $k$ 个值 $X_1, X_2, \dots, X_k$，概率分别为 $( p_1, p_2, \dots, p_k )$</p><script type="math/tex; mode=display">EU_i = p_1 X_1 + p_2 X_2 + \dots + p_k X_k</script><ul><li><p>支付最大化</p><p>最优化的一阶条件为0</p></li><li><p>支付等值法</p><p>参与者$i$每种可能取值相等，即$X_1 = \dots =X_k$</p></li><li><p>反应曲线法</p></li></ul><p><mark>需要剔除严格劣战略</mark></p><h1 id="完全信息动态博弈"><a href="#完全信息动态博弈" class="headerlink" title="完全信息动态博弈"></a>完全信息动态博弈</h1><p><strong>序贯博弈</strong>(Sequential Game)：参与人按照明确的顺序依次采取行动。每个参与人在决策时，可以观察到前面参与人的部分或全部行动。</p><ul><li><p>完全信息序贯博弈：每个参与人对所有之前的行动信息完全了解。</p></li><li><p>不完全信息序贯博弈：参与人对某些之前的行动信息不了解。</p></li></ul><p><br></p><p><strong>参与人集合$N$</strong>：博弈中所有参与人的集合。</p><ul><li><p>实际参与人：具有明确身份的博弈参与者。</p></li><li><p>虚拟参与人：例如自然或随机机制，其行动由概率分布描述。</p></li></ul><p><br></p><p>参与人的<strong>行动顺序</strong> (The Order of Moves)：定义了每个参与人采取行动的先后顺序。</p><ul><li><p>固定顺序：参与人的行动顺序明确且不变。</p></li><li><p>随机顺序：通过随机机制（例如抽签）决定行动顺序。</p></li></ul><p><br></p><p>参与人的<strong>行动空间</strong> (Action Set)：每个参与人在决策时可选择的策略集合$A<em>i = {a</em>{i1}, a<em>{i2}, \dots, a</em>{ik}}$。</p><p><br></p><p>参与人的<strong>信息集</strong> (Information Set):参与人在行动时所掌握的博弈信息，描述了参与人对博弈进程的了解程度。</p><ul><li><p>完全信息：参与人知道所有之前的决策和支付函数。</p></li><li><p>不完全信息：参与人只能观察到部分决策或结果。</p></li></ul><p><br>参与人的<strong>支付函数</strong> (Payoff Function)：描述了参与人在博弈结束时，根据所有参与人的行动组合所获得的收益。</p><p><br></p><p><strong>阶段</strong>：动态博弈中参与人的一次行为。</p><p><br></p><p><strong>路径</strong>：从第一阶段到达博弈结束的某个终端各参与人的行为组合。</p><p><br></p><p><strong>战略</strong>：针对每种可能的情况如何选择的完整行动计划。</p><p><br></p><p><strong>可信性</strong>：动态博弈中先行为的参与人是否该相信后行为的参与人会采取对自己有利或不利的行为。</p><h2 id="扩展式表述"><a href="#扩展式表述" class="headerlink" title="扩展式表述"></a>扩展式表述</h2><p>用决策树表示博弈过程:</p><ul><li><p><strong>节点（Node）</strong>：决策点。</p></li><li><p><strong>分支（Branch）</strong>：可选择的行动。</p></li><li><p><strong>叶子节点（Leaf Node）</strong>：每种可能结果的支付值。</p></li></ul><h2 id="子博弈"><a href="#子博弈" class="headerlink" title="子博弈"></a>子博弈</h2><p>从某个决策节点开始、包括其后所有分支的博弈。每个子博弈必须是原博弈的一个子集，且从起点节点开始。</p><ul><li><p>能够自成一个博弈的某个动态博弈的从其某个阶段开始的后续阶段。</p></li><li><p>必须有一个初始信息集。</p></li><li><p>具备博弈所需要的各种信息。</p></li></ul><h3 id="子博弈精炼纳什均衡-sub-game-perfect-Nash-equilibrium，SPNE"><a href="#子博弈精炼纳什均衡-sub-game-perfect-Nash-equilibrium，SPNE" class="headerlink" title="子博弈精炼纳什均衡(sub game perfect Nash equilibrium，SPNE)"></a>子博弈精炼纳什均衡(sub game perfect Nash equilibrium，SPNE)</h3><p><u>如果动态博弈中各参与人的战略在动态博弈本身和所有子博弈中都构成一个纳什均衡</u>，则称该战略组合为一个“子博弈精练纳什均衡”。</p><ul><li><p>方案的完整性</p></li><li><p>个体理性：序贯理性</p></li><li><p>既是纳什均衡，从而具有战略稳定性；又<br>不能包含任何的不会信守的许诺或威胁。</p></li></ul><h3 id="逆推归纳法求解SPNE"><a href="#逆推归纳法求解SPNE" class="headerlink" title="逆推归纳法求解SPNE"></a>逆推归纳法求解SPNE</h3><p>从动态博弈的最后一个阶段或最后一个子博弈开始，逐步向前倒推以求解动态博弈。</p><ol><li><p>从最末端叶子节点的支付值开始，确定最后决策点的最佳选择。</p></li><li><p>向前回溯，依次计算每个决策点的最佳策略。</p></li><li><p>重复以上过程，直至根节点。</p></li></ol><h2 id="重复博弈"><a href="#重复博弈" class="headerlink" title="重复博弈"></a>重复博弈</h2><p>重复博弈：同样结构的博弈重复多次,特殊的动态博弈。</p><ul><li><p>每次博弈称为阶段博弈（stage game）</p></li><li><p>有限次重复博弈、无限次重复博弈</p></li></ul><p>由于长期利益的制约，一次博弈中不可信的威胁或许诺会变为可信，存在合作的可能性及更有效率的均衡。</p><p>博弈的均衡结果有多种可能性。影响博弈均衡结果的主要因素是博弈重复次数和信息的完备性（completeness）</p><h3 id="有限次重复博弈"><a href="#有限次重复博弈" class="headerlink" title="有限次重复博弈"></a>有限次重复博弈</h3><p>给定一个博弈G，重复进行T次G，并且在每次重复之前各参与人都能观察到以前博弈的结果，这样的博弈过程称为G的一个“T次重复博弈”，记为G（T）。而G则称为G（T）的原博弈。G（T）中的每次重复称为G（T）的一个阶段。</p><p>如果原博弈存在唯一的纯战略NE，则有限次重复博弈的均衡解即各参与人在每阶段都采用原博弈的NE。</p><p><mark>定理</mark>：<u>设原博弈G有唯一纯战略纳什均衡，则对任意正整数T，重复博弈G（T）有唯一的子博弈精练解，即各参与人每个阶段都采用G的纳什均衡战略。各参与人在G（T）中的总得益为在G中得益的T倍，平均每阶段得益等于原博弈G中的得益。</u></p><h3 id="无限次重复博弈"><a href="#无限次重复博弈" class="headerlink" title="无限次重复博弈"></a>无限次重复博弈</h3><p>无限次重复博弈是指同一阶段博弈在无限个时间周期内重复进行的一种博弈模型。参与人不知道或不关心博弈的结束时间，因此需要在长期利益和短期收益之间权衡。</p><p>给定一博弈G，无限次重复进行G博弈的过程称为G的“无限次重复博弈”，记为G（∞，δ），其中是各参与人得益共同的贴现系数δ。并且，对任意的t，在进行第t阶段（第t次重复）博弈之前，所有参与人都能看到前t－1阶段博弈的结果。各参与人在G（∞，δ）中的“得益”等于各阶段得益的现在值。</p><ul><li><strong>贴现因子（Discount Factor）$\delta$</strong>：范围为 $0 &lt; \delta &lt; 1$，反映了参与人对未来收益的重视程度。$\delta$ 越大，表示参与人越重视长期收益。</li></ul><h4 id="收益"><a href="#收益" class="headerlink" title="收益"></a>收益</h4><p>在无限次重复博弈中，参与人关注的是<strong>总收益的折现值</strong>，即将未来各阶段的支付按照贴现因子进行加权求和：</p><script type="math/tex; mode=display">U_i = \sum_{t=0}^{\infty} \delta^t u_i^t</script><h4 id="触发战略-Trigger-Strateg"><a href="#触发战略-Trigger-Strateg" class="headerlink" title="触发战略(Trigger Strateg)"></a>触发战略(Trigger Strateg)</h4><ul><li><p><strong>初始阶段合作</strong>：参与人假定对方会合作。</p></li><li><p><strong>背叛报复</strong>：如果对方在某一阶段背叛，则后续所有阶段均选择不合作作为惩罚。</p></li></ul><p>为了维持合作，合作的总收益需大于背叛的总收益:</p><script type="math/tex; mode=display">\frac{R}{1 - \delta} \geq T + \delta \cdot \frac{P}{1 - \delta}</script><p>其中，</p><ul><li><p>$ R $：双方合作时的支付；</p></li><li><p>$ T $：单方背叛时的最大支付；</p></li><li><p>$ P $：双方都不合作时的支付；</p></li><li><p>$ \delta $：贴现因子。</p></li></ul><h1 id="市场模型"><a href="#市场模型" class="headerlink" title="市场模型"></a>市场模型</h1><h2 id="完全垄断模型"><a href="#完全垄断模型" class="headerlink" title="完全垄断模型"></a>完全垄断模型</h2><p>在完全垄断市场中，只有一个厂商，厂商完全控制市场供给，并能够通过调整产量影响市场价格。</p><ul><li><p><strong>均衡产量</strong>：</p><p>单个企业的均衡产量：</p><script type="math/tex; mode=display">q_s = \frac{a - c}{2}</script></li><li><p><strong>总供给</strong>：</p><script type="math/tex; mode=display">Q_m = q_s = \frac{a - c}{2}</script></li><li><p><strong>市场价格</strong>：</p><script type="math/tex; mode=display">p_m = \frac{a + c}{2}</script></li><li><p><strong>企业均衡收益</strong>：</p><script type="math/tex; mode=display">u_m = \frac{(a - c)^2}{8}</script></li></ul><h2 id="2-古诺模型（Cournot-Model）"><a href="#2-古诺模型（Cournot-Model）" class="headerlink" title="2. 古诺模型（Cournot Model）"></a>2. 古诺模型（Cournot Model）</h2><p>非合作寡占模型，两个企业同时决策产量，假设对手的产量不变，通过相互反应形成均衡。</p><ul><li><p><strong>均衡产量</strong>：</p><p>两个企业的均衡产量分别为：</p><script type="math/tex; mode=display">q_c^1 = q_c^2 = \frac{a - c}{3}</script></li><li><p><strong>总供给</strong>：</p><script type="math/tex; mode=display">Q_c = q_c^1 + q_c^2 = \frac{2(a - c)}{3}</script></li><li><p><strong>市场价格</strong>：</p><script type="math/tex; mode=display">p_c = \frac{a + 2c}{3}</script></li><li><p><strong>企业均衡收益</strong>：</p><p>每个企业的均衡收益为：</p><script type="math/tex; mode=display">u_c^1 = u_c^2 = \frac{(a - c)^2}{9}</script></li></ul><h2 id="3-斯坦科尔伯格模型（Stackelberg-Model）"><a href="#3-斯坦科尔伯格模型（Stackelberg-Model）" class="headerlink" title="3. 斯坦科尔伯格模型（Stackelberg Model）"></a>3. 斯坦科尔伯格模型（Stackelberg Model）</h2><ul><li><p><strong>均衡产量</strong>：</p><ul><li><p>领导企业的均衡产量：</p><script type="math/tex; mode=display">q_s^1 = \frac{a - c}{2}</script></li></ul></li><li><p>跟随企业的均衡产量</p><script type="math/tex; mode=display">q_s^2 = \frac{a - c}{4}</script></li><li><p><strong>总供给</strong>：</p><script type="math/tex; mode=display">Q_s = q_s^1 + q_s^2 = \frac{3(a - c)}{4}</script></li><li><p><strong>市场价格</strong>：</p><script type="math/tex; mode=display">p_s = \frac{a + 3c}{4}</script><p>其中</p></li><li><p><strong>企业均衡收益</strong>：</p><ul><li><p>领导企业的均衡收益：</p><script type="math/tex; mode=display">u_s^1 = \frac{(a - c)^2}{8}</script></li></ul></li><li><p>跟随企业的均衡收益： </p><script type="math/tex; mode=display">u_s^2 = \frac{(a - c)^2}{16}</script></li></ul><div class="table-container"><table><thead><tr><th><strong>模型</strong></th><th><strong>均衡产量</strong></th><th><strong>总供给</strong></th><th><strong>市场价格</strong></th><th><strong>企业收益</strong></th></tr></thead><tbody><tr><td><strong>完全垄断</strong></td><td>$q_s = \frac{a - c}{2}$</td><td>$Q_m = \frac{a - c}{2}$</td><td>$p_m = \frac{a + c}{2}$</td><td>$u_m = \frac{(a - c)^2}{8}$</td></tr><tr><td><strong>古诺模型</strong></td><td>$q_c^1 = q_c^2 = \frac{a - c}{3}$</td><td>$Q_c = \frac{2(a - c)}{3}$</td><td>$p_c = \frac{a + 2c}{3}$</td><td>$u_c^1 = u_c^2 = \frac{(a - c)^2}{9}$</td></tr><tr><td><strong>斯坦科尔伯格</strong></td><td>$q_s^1 = \frac{a - c}{2}, q_s^2 = \frac{a - c}{4}$</td><td>$Q_s = \frac{3(a - c)}{4}$</td><td>$p_s = \frac{a + 3c}{4}$</td><td>$u_s^1 = \frac{(a - c)^2}{8}, u_s^2 = \frac{(a - c)^2}{16}$</td></tr></tbody></table></div><h1 id="不完全信息静态博弈"><a href="#不完全信息静态博弈" class="headerlink" title="不完全信息静态博弈"></a>不完全信息静态博弈</h1><p>不完全信息静态博弈是指参与人对某些博弈参数（如对手的支付函数、策略空间等）缺乏完整了解的博弈模型。参与人通过<strong>信念</strong>来描述不确定性，并基于贝叶斯法则更新和优化其策略。</p><h2 id="海萨尼转换-Harsanyi-Transformation"><a href="#海萨尼转换-Harsanyi-Transformation" class="headerlink" title="海萨尼转换(Harsanyi Transformation)"></a>海萨尼转换(Harsanyi Transformation)</h2><p>海萨尼转换是一种将不完全信息博弈转化为完全但不完美信息博弈的方法。通过引入<strong>类型(Type)</strong>的概念，将参与人的不确定性量化为不同类型，并赋予每种类型对应的概率分布。</p><p>引入虚拟的参与人-“自然”(𝒏𝒂𝒕𝒖𝒓𝒆)；自然首先行动决定参与人的特征(成本函数)，参与人知道自己的特征，其他参与人不知道。这样，上述不完全信息博弈就转换为完全但不完美信息博弈。</p><ul><li><p>“自然”先为其他每个参与人抽取他们的类型，抽取的这些类型构成类型向量。</p></li><li><p>“自然”让每个参与人知道自己的类型，但却不让其他参与人知道。</p></li><li><p>除“自然”以外的其他参与人同时从各自的行为空间中选择行动方<br>案。</p></li></ul><h2 id="不完全信息静态博弈的表述"><a href="#不完全信息静态博弈的表述" class="headerlink" title="不完全信息静态博弈的表述"></a>不完全信息静态博弈的表述</h2><p>在不完全信息静态博弈中，参与人的行动空间可能取决于其类型，即行动空间是<strong>类型依存的（type-contingent）</strong>。这种特性反映了参与人根据自己掌握的信息做出的有限选择。</p><script type="math/tex; mode=display">G = \{A_1, A_2, \dots, A_n; T_1, T_2, \dots, T_n; p_1, p_2, \dots, p_n; u_1, u_2, \dots, u_n\}</script><p>其中：</p><ul><li><p>$ A_i $：参与人 $ i $ 的类型依存行动空间。</p></li><li><p>$ T_i $：参与人 $ i $ 的类型集合。</p></li><li><p>$ p<em>i(t</em>{-i} / t<em>i) $：给定 $ t_i $ 时，关于 $ t</em>{-i} $ 的条件概率分布。</p></li><li><p>$ u<em>i(a_i, a</em>{-i}; t<em>i, t</em>{-i}) $：参与人 $ i $ 的支付函数，依赖于其行动 $ a<em>i $、对手的行动 $ a</em>{-i} $ 和所有人的类型。</p></li></ul><p><strong>条件概率分布</strong>：</p><script type="math/tex; mode=display">p_i(t_{-i} / t_i) = \frac{p(t_{-i}, t_i)}{\sum_{t'_{-i} \in T_{-i}} p(t'_{-i}, t_i)}</script><p><strong>期望效用函数</strong></p><p>给定类型 $t_i$ 和行动 $a_i$，参与人 $i$ 的期望效用为：</p><script type="math/tex; mode=display">v_i = \sum_{t_{-i} \in T_{-i}} p_i(t_{-i} / t_i) \cdot u_i(a_i(t_i), a_{-i}(t_{-i}); t_i, t_{-i})</script><h2 id="贝叶斯纳什均衡-Bayesian-Nash-Equilibrium"><a href="#贝叶斯纳什均衡-Bayesian-Nash-Equilibrium" class="headerlink" title="贝叶斯纳什均衡(Bayesian Nash Equilibrium)"></a>贝叶斯纳什均衡(Bayesian Nash Equilibrium)</h2><p>贝叶斯纳什均衡是指在不完全信息博弈中，每个参与人的策略 $s_i^*(t_i)$ 在给定其类型 $t_i$ 和对其他人策略及类型分布的信念下，最大化其期望支付。</p><script type="math/tex; mode=display">\mathbb{E}_{t_{-i}} \big[ u_i(s_i^*(t_i), s_{-i}(t_{-i}), t_i, t_{-i}) \big]\geq\mathbb{E}_{t_{-i}} \big[ u_i(s_i', s_{-i}(t_{-i}), t_i, t_{-i}) \big]</script><p>其中，</p><ul><li><p>$ s_i^* (t_i) $：类型为 $t_i$ 时的最优策略。</p></li><li><p>$ t_{-i} $：其他参与人的类型。</p></li><li><p>$ u_i $：参与人 $i$ 的支付函数。</p></li></ul><script type="math/tex; mode=display">s^* = (s_1^*(t_1), s_2^*(t_2), \dots, s_n^*(t_n))</script><script type="math/tex; mode=display">s_i^*(t_i) = \arg \max_{s_i \in A_i(s_i)} \sum_{t_{-i} \in T_{-i}} p_i(t_{-i} / t_i) \cdot u_i(s_i, s_{-i}^*(t_{-i}); t_i, t_{-i})</script><p><br></p><ol><li><p>参与人基于对对手类型的信念选择最优策略。</p></li><li><p>每种类型的参与人均选择相互最优的策略。</p></li></ol><h2 id="机制设计与揭示原理"><a href="#机制设计与揭示原理" class="headerlink" title="机制设计与揭示原理"></a>机制设计与揭示原理</h2><h3 id="直接机制"><a href="#直接机制" class="headerlink" title="直接机制"></a>直接机制</h3><p>直接机制是一种机制设计方法，要求参与人直接报告其私有信息（如类型），机制设计者根据报告的类型分配资源或确定支付。</p><p><strong>形式</strong>：</p><ul><li><p>每个参与人报告类型 $\hat{t}_i$。</p></li><li><p>机制设计者基于$\hat{t}_i$决定结果 $ a(\hat{t}) $ 和支付规则 $ p_i(\hat{t}) $。</p></li></ul><p>如果所设计的直接机制能使得各投标人讲真话为贝叶斯纳什均衡，则称这个直接机制为“鼓励—响应”的。</p><p>如果存在某个间接机制 $ M $ 达成目标，则一定存在一个直接机制 $ M’ $，使参与人诚实报告类型 $ t_i $ 是其最优策略。</p><h3 id="揭示原理"><a href="#揭示原理" class="headerlink" title="揭示原理"></a>揭示原理</h3><p>任何机制设计问题都可以被等效地转化为一个直接机制问题，其中参与人会诚实地报告其类型。任何贝叶斯博弈的任何贝叶斯纳什均衡都可以被一个“鼓<br>励-响应”的直接机制“代表”。</p><h2 id="贝叶斯博弈与混合战略均衡"><a href="#贝叶斯博弈与混合战略均衡" class="headerlink" title="贝叶斯博弈与混合战略均衡"></a>贝叶斯博弈与混合战略均衡</h2><p>贝叶斯博弈是指参与人存在类型不确定性且可能使用混合策略的不完全信息博弈。</p><h3 id="纯化定理"><a href="#纯化定理" class="headerlink" title="纯化定理"></a>纯化定理</h3><p><u>完全信息静态博弈中的一个混合战略博弈几乎总是可以被解释成一个有少量不完全信息的近似博弈的一个纯战略贝叶斯纳什均衡。</u></p><p>即，一个混合战略纳什均衡的根本特征不是参与人以随机的方法选择战略（即行为），而是各参与人对其他参与人的选择不能确定，这种不确定性既可以是随机性引起，也可以是少量信息的不完全性引起。</p><h1 id="不完全信息动态博弈"><a href="#不完全信息动态博弈" class="headerlink" title="不完全信息动态博弈"></a>不完全信息动态博弈</h1><p>不完全信息动态博弈是指参与人对博弈的某些信息（如对手的支付函数、类型等）存在不完全了解，但随着博弈的进行可以<u>通过观察对手的行为逐渐更新信念</u>。博弈的分析通常依赖于贝叶斯法则和精炼贝叶斯均衡。</p><p>“自然”首先选择参与人的类型，参与人自己知道，其他参与人不知道；之后参与人开始先后行动，后行动者能观测到先行动者的行动，但不能观测到先行动者的类型。</p><p>参与人的行动是类型依存的，后行动者可通过观察先行动者所选择的行动来推断其类型或修正对其类型的先验信念(概率分布)，然后选择最优行动。</p><p>先行动者预测到自己的行动将被后行动者所利用，就会设法选择传递对自己最有利的信息。</p><h2 id="贝叶斯法则"><a href="#贝叶斯法则" class="headerlink" title="贝叶斯法则"></a>贝叶斯法则</h2><p>先验概率：</p><script type="math/tex; mode=display">P(\theta^k)，\sum_{k=1}^{K}P(\theta^k) = 1</script><p>条件概率：</p><script type="math/tex; mode=display">P(a^h | \theta^k)， \sum_{k=1}^{K}P(a^h | \theta^k) = 1</script><p>边缘概率：</p><script type="math/tex; mode=display">P(a^h) = \sum_{k=1}^{K}P(\theta^k) \cdot P(a^h | \theta^k) = 1</script><p>后验概率：</p><script type="math/tex; mode=display">P(\theta^k | a^h) = \frac{P(\theta^k) \cdot P(a^h | \theta^k)}{P(a^h)}</script><h2 id="精炼贝叶斯均衡"><a href="#精炼贝叶斯均衡" class="headerlink" title="精炼贝叶斯均衡"></a>精炼贝叶斯均衡</h2><ul><li><p>在每一个信息集上，决策者必须有一个定义在属于该信息集的所有决策结上的一个概率分布(信念)</p></li><li><p>给定该信息集上的概率分布和其他参与人的后续战略，参与人的行动必须是最优的</p></li><li><p>每一个参与人根据贝叶斯法则和均衡战略修正后验概率</p></li></ul><p>精炼贝叶斯均衡是一个战略组合 $s(\theta) = [s_1(\theta_1), \dots, s_n(\theta_n)]$ 和后验概率组合 $\tilde{p} = (\tilde{p}_1, \dots, \tilde{p}_n)$，满足以下两个条件：</p><script type="math/tex; mode=display">s_i^*(s_{-i}, \theta_i) \in \arg \max_{s_i} \sum_{\theta_{-i}} \tilde{p}_i(\theta_{-i} | a_{-i}) \cdot u_i(s_i, s_{-i}, \theta_i)</script><script type="math/tex; mode=display">\tilde{p}_i(\theta_{-i} | a_{-i}) = \frac{p(\theta_{-i} | \theta_i) \cdot P(a_{-i} | \theta_{-i}, s_{-i}^*)}{\sum_{\theta_{-i}'} p(\theta_{-i}' | \theta_i) \cdot P(a_{-i} | \theta_{-i}', s_{-i}^*)}</script><p>在每一信息集中，应该行动的参与人必须对博弈进行到该信息集中的哪个节有一个推断。对于非单节信息集，推断是在信息集中不同节点的一个概率分布；对于单节的信息集，参与人的推断就是到达单一决策节的概率为1。</p><p>给定参与人的推断，参与人的战略必须满足序贯理性的要求，即在每一个信息集中应该行动的参与人(以及参与人随后的战略)，对于给定的该参与人在此信息集中的推断，以及其他参与人随后的战略必须是最优反应。</p><p>在处于均衡路径之上的信息集中，推断由贝叶斯法则及参与人的均衡战略给出；对处于均衡路径之外的信息集，推断由贝叶斯法则以及可能情况下的参与人的均衡战略决定。</p><blockquote><p>对于一个扩展式博弈中给定的均衡，如果博弈根据均衡战略进行时将以正的概率达到某信息集，称此信息集处于均衡路径之上。</p></blockquote><h2 id="信号传递博弈"><a href="#信号传递博弈" class="headerlink" title="信号传递博弈"></a>信号传递博弈</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><ol><li><p>“自然”首先为参与人1（发送方）选择一个类型 $\theta \in \Theta$，类型空间为： </p><script type="math/tex; mode=display">\Theta = {\theta_1, \theta_2, \dots, \theta_k}</script><ul><li><p>参与人1知道自己的类型 \theta，但参与人2不知道。</p></li><li><p>参与人2仅知道类型的先验概率分布 $p = {p<em>{\theta_1}, p</em>{\theta<em>2}, \dots, p</em>{\theta_k}}$，满足：</p><script type="math/tex; mode=display">\sum_{k} p({\theta_k}) = 1</script></li></ul></li><li><p>参与人1在观察到自己的类型 $\theta$ 后，选择发送一个信号 $m \in M$。</p><p>信号空间为：</p><script type="math/tex; mode=display">M = \{m_1, m_2, \dots, m_j\}</script></li><li><p>参与人2观察到信号 $m$ 后，通过贝叶斯法则更新关于 $\theta$ 的信念，得到后验概率 $\tilde{p}(\theta | m)$。接收方随后根据后验概率选择一个行动 $a \in A$，其中行动空间为： </p><script type="math/tex; mode=display">A = \{a_1, a_2, \dots, a_H\}</script></li></ol><ol><li><p>两位参与人的支付函数分别为： </p><ul><li><p>发送方（参与人1）： </p><script type="math/tex; mode=display">\mu_1(m, a, \theta)</script></li></ul></li></ol><ul><li><p>接收方（参与人2）：</p><script type="math/tex; mode=display">\mu_2(m, a, \theta)</script></li></ul><h3 id="信号传递博弈的精炼贝叶斯均衡"><a href="#信号传递博弈的精炼贝叶斯均衡" class="headerlink" title="信号传递博弈的精炼贝叶斯均衡"></a>信号传递博弈的精炼贝叶斯均衡</h3><p>是一个策略组合 $(m^<em>(\theta), a^</em>(m))$ 和后验概率分布 $\tilde{p}(\theta | m)$ 的集合。</p><h4 id="接收方的最优策略"><a href="#接收方的最优策略" class="headerlink" title="接收方的最优策略"></a>接收方的最优策略</h4><p>给定信号 $ m $ 和更新后的信念 $ \tilde{p}(\theta | m) $，接收方 $ a^*(m) $ 选择最大化其期望支付的行动：</p><script type="math/tex; mode=display">a^*(m) \in \arg \max_a \sum_{\theta} \tilde{p}(\theta | m) \cdot \mu_2(m, a, \theta)</script><h4 id="发送方的最优策略"><a href="#发送方的最优策略" class="headerlink" title="发送方的最优策略"></a>发送方的最优策略</h4><p>给定接收方的策略 $ a^<em>(m) $，发送方 $ m^</em>(\theta) $ 选择最大化自身支付的信号：</p><script type="math/tex; mode=display">m^*(\theta) \in \arg \max_m \mu_1(m, a^*(m), \theta)</script><h4 id="信念更新"><a href="#信念更新" class="headerlink" title="信念更新"></a>信念更新</h4><p>接收方的后验概率 $ \tilde{p}(\theta | m) $ 是根据贝叶斯法则，从先验概率 $ p(\theta) $、观测信号 $ m $、以及发送方的最优策略 $ m^*(\theta) $ 计算得出的：</p><script type="math/tex; mode=display">\tilde{p}(\theta | m) = \frac{p(\theta) \cdot P(m | \theta, m^*(\theta))}{\sum_{\theta' \in \Theta} p(\theta') \cdot P(m | \theta', m^*(\theta'))}</script><p>其中：</p><ul><li>$ P(m | \theta, m^<em>(\theta)) $ 是在类型为 $ \theta $ 且发送最优信号 $ m^</em>(\theta) $ 时，信号 $ m $ 被发送的概率。</li></ul><h3 id="均衡类型"><a href="#均衡类型" class="headerlink" title="均衡类型"></a>均衡类型</h3><ol><li><p>分离均衡（Separating Equilibrium）</p><p>不同类型的发送方以概率 1 选择不同的信号。</p></li><li><p>混同均衡（Pooling Equilibrium）</p><p>混同均衡是指所有类型的发送方选择相同的信号 $m$，接收方无法区分发送方的类型。</p></li><li><p>准分离均衡（Semi-separating Equilibrium）</p><p>一种介于分离均衡和混同均衡之间的情况，不同类型的发送方以一定的概率选择不同的信号。</p></li></ol><h1 id="演化博弈"><a href="#演化博弈" class="headerlink" title="演化博弈"></a>演化博弈</h1><p>演化博弈研究策略在长期互动中通过自然选择或学习过程的动态变化。与经典博弈论不同，它<u>关注个体的适应性而非完全理性</u>。演化博弈广泛应用于生物学、经济学和人工智能等领域。</p><ol><li><p>强调策略的适应性；</p></li><li><p>通过群体互动决定策略的成败；</p></li><li><p>采用动态方法分析策略的稳定性。</p></li></ol><h2 id="动态调整机制"><a href="#动态调整机制" class="headerlink" title="动态调整机制"></a>动态调整机制</h2><h3 id="最优反应动态"><a href="#最优反应动态" class="headerlink" title="最优反应动态"></a>最优反应动态</h3><p>最优反应动态描述参与人如何调整策略以逐步接近最优策略。假设参与人选择的策略为 x_i，其最优反应为 $BR_i$，则策略的动态变化为：</p><script type="math/tex; mode=display">\dot{x}_i = \lambda \cdot \left[ BR_i - x_i \right]</script><p>其中：</p><ul><li>$BR_i$：策略 <script type="math/tex">i</script> 的最优反应，满足：</li></ul><script type="math/tex; mode=display">BR_i \in \arg \max_{x_i} u(x_i, x_{-i})</script><ul><li>$\lambda$：调整速度。</li></ul><h3 id="复制动态"><a href="#复制动态" class="headerlink" title="复制动态"></a>复制动态</h3><p>复制动态描述了群体中策略的比例如何随着适应性变化。假设群体中有 $n$ 种策略，每种策略的比例为 $x_i$，其适应性为 $u_i$，则策略 $i$ 的动态变化由以下方程描述：</p><script type="math/tex; mode=display">\dot{x}_i = x_i \cdot \left[ u_i - \bar{u} \right]</script><p>其中：</p><ul><li><p>$\dot{x}_i$：策略 <script type="math/tex">i</script> 的比例变化率；</p></li><li><p>$u_i$：策略 <script type="math/tex">i</script> 的收益；</p></li><li><p>$\bar{u} = \sum_{i=1}^n x_i u_i$：群体的平均收益。</p></li><li><p>当 $u_i &gt; \bar{u}$ 时，策略 $i$ 的比例增加；</p></li><li><p>当 $u_i &lt; \bar{u}$ 时，策略 $i$ 的比例减少。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博弈论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四、数字形态学</title>
      <link href="/2024/11/09/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%9B%9B%E3%80%81%E6%95%B0%E5%AD%97%E5%BD%A2%E6%80%81%E5%AD%A6/"/>
      <url>/2024/11/09/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%9B%9B%E3%80%81%E6%95%B0%E5%AD%97%E5%BD%A2%E6%80%81%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数学形态学</p><ul><li><p>是建立在集合论基础上的图像处理技术。</p></li><li><p>用集合描述图像目标，描述图像各部分之间关系，描述目标的结构特点。</p></li><li><p>用具有一定形态的<em>结构元素</em>去量度和提取图像中的对应形状,达到对图像分析和识别目的。</p></li></ul><h1 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h1><h2 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h2><p>在数学形态学中，图像用<strong>集合</strong>来表示，定义在欧氏空间$\mathbb{R}^2$，记为 $A, B, C, \dots$。</p><h2 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h2><p>图像中的像素则用集合的元素来表示，记为 $a, b, c, \dots$。</p><ul><li><p>$a \in A$，表示像素 $a$ 属于集合 $A$（图像）；</p></li><li><p>$a \notin A$，表示像素 $a$ 不属于集合 $A$。</p></li></ul><h2 id="基本形态学算子"><a href="#基本形态学算子" class="headerlink" title="基本形态学算子"></a>基本形态学算子</h2><p>基本的数学形态学算子是通过一些集合运算来构成的，以下是常见的集合运算：</p><ul><li><p><strong>映射</strong>：用 $\,\hat{A}\,$ 表示集合 $A$ 的某种映射。</p></li><li><p><strong>补集</strong>：用 $A^c$ 表示集合 $A$ 的补集。</p></li><li><p><strong>子集</strong>：若 $B \subseteq A$，则表示 $B$ 是 $A$ 的子集。</p></li><li><p><strong>并集</strong>：$A \cup B$ 表示集合 $A$ 和集合 $B$ 的并集。</p></li><li><p><strong>交集</strong>：$A \cap B$ 表示集合 $A$ 和集合 $B$ 的交集。</p></li><li><p><strong>差集</strong>：$A - B$ 表示集合 $A$ 和集合 $B$ 的差集，即属于 $A$ 但不属于 $B$ 的元素集合。</p></li><li><p><strong>击中</strong>：如果 $A \cap B \neq \emptyset$，则称 $B$ 击中 $A$。</p></li><li><p><strong>击不中</strong>：如果 $A \cap B = \emptyset$，则称 $B$ 击不中 $A$。</p></li></ul><h1 id="二值形态学"><a href="#二值形态学" class="headerlink" title="二值形态学"></a>二值形态学</h1><h2 id="结构元素"><a href="#结构元素" class="headerlink" title="结构元素"></a>结构元素</h2><p>在分析目标图像时，需要创建一种几何形态滤波模板，用来收集图像信息，称之为结构元素。</p><p><mark>结构元素本身实际上也是1个图像集合。</mark></p><p><em>选取结构元素的遵循原则</em>：</p><ul><li><p>几何结构要比原图像简单，且有界。</p></li><li><p>尺寸要明显小于目标图像的尺寸。</p></li><li><p>形状具有某种凸性，如圆形、十字架、方形等。</p></li><li><p><em>每个结构元素需指定一个原点</em>，作为结构元素参与形态学运算的<strong>“参考点”</strong>。</p></li></ul><p><mark>所有形态学处理都基于填放结构元素的概念。</mark></p><p>填放：用不同的方法把结构元素放在原图像的内部，在结构元素的填放中引出一系列图像的特性。</p><p><img src="/home/leon/Pictures/Marktext/2024-11-10-16-29-27-image.png" alt=""></p><p><mark>函数</mark>：<code>cv.getStructuringElement(shape, ksize[, anchor])</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="comment"># 矩形结构元素</span></span><br><span class="line">rect1 = cv.getStructuringElement(cv.MORPH_RECT, (<span class="number">5</span>, <span class="number">3</span>))  <span class="comment"># 矩形结构，大小为 5x3</span></span><br><span class="line">rect2 = cv.getStructuringElement(cv.MORPH_RECT, (<span class="number">5</span>, <span class="number">3</span>), (<span class="number">0</span>, <span class="number">0</span>))  <span class="comment"># 矩形结构，锚点 (0, 0)</span></span><br><span class="line"><span class="comment"># 十字形结构元素</span></span><br><span class="line">cross1 = cv.getStructuringElement(cv.MORPH_CROSS, (<span class="number">5</span>, <span class="number">3</span>))  <span class="comment"># 十字形结构，大小为 5x3</span></span><br><span class="line">cross2 = cv.getStructuringElement(cv.MORPH_CROSS, (<span class="number">5</span>, <span class="number">3</span>), (<span class="number">0</span>, <span class="number">0</span>))  <span class="comment"># 十字形结构，锚点 (0, 0)</span></span><br><span class="line"><span class="comment"># 椭圆形结构元素</span></span><br><span class="line">ellipse1 = cv.getStructuringElement(cv.MORPH_ELLIPSE, (<span class="number">9</span>, <span class="number">5</span>))  <span class="comment"># 椭圆形结构，大小为 9x5</span></span><br><span class="line">ellipse2 = cv.getStructuringElement(cv.MORPH_ELLIPSE, (<span class="number">9</span>, <span class="number">5</span>), (<span class="number">0</span>, <span class="number">0</span>))  <span class="comment"># 椭圆形结构，锚点 (0, 0)</span></span><br><span class="line"><span class="comment"># 输出结果以查看结构元素的矩阵形式</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;矩形结构元素 rect1:\n&quot;</span>, rect1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;十字形结构元素 cross1:\n&quot;</span>, cross1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;椭圆形结构元素 ellipse1:\n&quot;</span>, ellipse1)</span><br></pre></td></tr></table></figure><h2 id="基本形态变换"><a href="#基本形态变换" class="headerlink" title="基本形态变换"></a>基本形态变换</h2><h3 id="膨胀-Dilation"><a href="#膨胀-Dilation" class="headerlink" title="膨胀(Dilation)"></a>膨胀(Dilation)</h3><h4 id="算符"><a href="#算符" class="headerlink" title="算符"></a>算符</h4><p>$A \oplus S$，其中 $A$ 为输入图像，$S$ 为结构元素。</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>膨胀操作会扩大图像中的前景（通常为白色）区域。在膨胀过程中，结构元素 $B$ 会扫描输入图像 $A$，如果 $B$ 的任何部分与 $A$ 的前景像素重叠，那么结构元素的原点（“参考点”）在输出图像中被设为前景。其作用是填充小孔、连接相邻物体等。</p><script type="math/tex; mode=display">A \oplus S = \{z \mid (Ŝ )_z \cap A \neq \emptyset\}</script><p>其中，$(Ŝ)_z$对结构元素 S 作关于原点的映射，然后平移 z。</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p><code>cv.dilate()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建结构元素</span></span><br><span class="line">kernel = cv.getStructuringElement(cv.MORPH_RECT, (<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment"># 膨胀操作</span></span><br><span class="line">dilated_image = cv.dilate(input_image, kernel, iterations=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="腐蚀-ecode"><a href="#腐蚀-ecode" class="headerlink" title="腐蚀(ecode)"></a>腐蚀(ecode)</h3><h4 id="算符-1"><a href="#算符-1" class="headerlink" title="算符"></a>算符</h4><p>$A \ominus B$</p><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>腐蚀操作会缩小图像中的前景区域。结构元素 $B$ 扫描输入图像 $A$，如果 $B$ 的任何部分不与前景像素完全重叠，则该位置在输出图像中被设为背景。其作用包括去除图像中的小物体、缩小目标物体等。</p><script type="math/tex; mode=display">A \oplus B = \{z \mid (B)_z \subseteq A \}</script><h4 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h4><p><code>cv.erode()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建结构元素</span></span><br><span class="line">kernel = cv.getStructuringElement(cv.MORPH_RECT, (<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment"># 腐蚀操作</span></span><br><span class="line">eroded_image = cv.erode(input_image, kernel, iterations=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="膨胀腐蚀性质"><a href="#膨胀腐蚀性质" class="headerlink" title="膨胀腐蚀性质"></a>膨胀腐蚀性质</h3><ol><li><p>对偶性</p><script type="math/tex; mode=display">(X \oplus S)^c = X^c \ominus S</script><script type="math/tex; mode=display">(X \ominus S)^c = X^c \oplus S</script></li><li><p>互换性（膨胀）</p><script type="math/tex; mode=display">(X \oplus S_1) \oplus S_2 = (X \oplus S_2) \oplus S_1</script></li><li><p>结合性（膨胀)</p><script type="math/tex; mode=display">X \oplus (S_1 \oplus S_2) = (X \oplus S_1) \oplus S_2</script></li><li><p>增长性</p><script type="math/tex; mode=display">X \subseteq Y \Rightarrow X \oplus S \subseteq Y \oplus S</script><script type="math/tex; mode=display">X \subseteq Y \Rightarrow X \ominus S \subseteq Y \ominus S</script></li></ol><h2 id="复合形态变换"><a href="#复合形态变换" class="headerlink" title="复合形态变换"></a>复合形态变换</h2><p>膨胀和腐蚀不是互为逆运算的。膨胀和腐蚀进行级连结合使用，产生新的形态变换，即开运算(Opening)和闭运算(Closing)。</p><h3 id="开运算（Opening）"><a href="#开运算（Opening）" class="headerlink" title="开运算（Opening）"></a>开运算（Opening）</h3><p>开运算由<strong>先腐蚀后膨胀</strong>构成，记作 $X \circ S$。</p><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><script type="math/tex; mode=display">X \circ S = (X \ominus S) \oplus S</script><ul><li><strong>作用</strong>：开运算可以去除小于结构元素的前景噪点，开运算平滑图像轮廓，去掉细长的突起、边缘、毛刺和孤点。</li></ul><h4 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h4><p> <code>cv.morphologyEx()</code> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="comment"># 定义结构元素</span></span><br><span class="line">kernel = cv.getStructuringElement(cv.MORPH_RECT, (<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line"><span class="comment"># 开运算</span></span><br><span class="line">opened_image = cv.morphologyEx(input_image, cv.MORPH_OPEN, kernel)</span><br></pre></td></tr></table></figure><h3 id="闭运算-Closing"><a href="#闭运算-Closing" class="headerlink" title="闭运算(Closing)"></a>闭运算(Closing)</h3><p>闭运算由<strong>先膨胀后腐蚀</strong>构成，记作 $X \bullet S$。</p><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><script type="math/tex; mode=display">X \bullet S = (X \oplus S) \ominus S</script><ul><li><strong>作用</strong>：闭运算平滑图像的轮廓，融合窄的缺口和细长的弯口，填补图像的裂缝及破洞。</li></ul><h4 id="函数-2"><a href="#函数-2" class="headerlink" title="函数"></a>函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">kernel = cv.getStructuringElement(cv.MORPH_RECT, (<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">closed_image = cv.morphologyEx(input_image, cv.MORPH_CLOSE, kernel)</span><br></pre></td></tr></table></figure><h2 id="二值形态学应用"><a href="#二值形态学应用" class="headerlink" title="二值形态学应用"></a>二值形态学应用</h2><h3 id="平滑滤波"><a href="#平滑滤波" class="headerlink" title="平滑滤波"></a>平滑滤波</h3><p>开运算和闭运算是关于集合补和反转的对偶（对偶：对集合执行开运算或闭运算 = 对集合的补集执行闭运算或开运算 ），而不是互为逆运算。</p><p>结构元素S大于图像X中所有噪声孔和噪声块的尺寸，可以有效去除图像的噪声，但不能过大。</p><h3 id="边缘提取"><a href="#边缘提取" class="headerlink" title="边缘提取"></a>边缘提取</h3><ol><li><p>内边界</p><script type="math/tex; mode=display">\text{Inner Boundary} = X - (X \ominus S)</script></li><li><p>外边界</p><script type="math/tex; mode=display">\text{Outer Boundary} = (X \oplus S) - X</script></li><li><p>形态学梯度</p><script type="math/tex; mode=display">\text{Morphological Gradient} = (X \oplus S) - (X \ominus S)</script></li></ol><h3 id="区域填充"><a href="#区域填充" class="headerlink" title="区域填充"></a>区域填充</h3><h3 id="目标探测"><a href="#目标探测" class="headerlink" title="目标探测"></a>目标探测</h3><h3 id="细化"><a href="#细化" class="headerlink" title="细化"></a>细化</h3><h1 id="灰度形态学"><a href="#灰度形态学" class="headerlink" title="灰度形态学"></a>灰度形态学</h1><h1 id="距离变换"><a href="#距离变换" class="headerlink" title="距离变换"></a>距离变换</h1>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三、图像增强</title>
      <link href="/2024/11/06/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%B8%89%E3%80%81%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/"/>
      <url>/2024/11/06/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%B8%89%E3%80%81%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>图像增强：图像增强是对图像进行加工，以得到对具体应用来说视觉效果更“好”，更“有用”的图像的技术。由于光照度不够会造成图像灰度过于集中；图像在传输或者处理过程中会引入噪声等等。</p><p>在图像增强的过程中，没有新信息的增加，只是通过压制一部分信息，从而突出另一部分信息。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">图像增强</span><br><span class="line">├── 空间域增强方法</span><br><span class="line">│   ├── 灰度变换</span><br><span class="line">│   │   ├── 对数变换</span><br><span class="line">│   │   ├── 伽马变换</span><br><span class="line">│   │   ├── 反转变换</span><br><span class="line">│   │   └── 线性变换</span><br><span class="line">│   ├── 直方图均衡化</span><br><span class="line">│   │   ├── 全局直方图均衡化</span><br><span class="line">│   │   └── 局部直方图均衡化</span><br><span class="line">│   ├── 图像平滑与锐化</span><br><span class="line">│   │   ├── 平滑</span><br><span class="line">│   │   │   ├── 均值滤波</span><br><span class="line">│   │   │   ├── 中值滤波</span><br><span class="line">│   │   │   └── 高斯滤波</span><br><span class="line">│   │   └── 锐化</span><br><span class="line">│   │       ├── 拉普拉斯算子</span><br><span class="line">│   │       ├── Sobel算子</span><br><span class="line">│   │       └── 高提升滤波</span><br><span class="line">│   └── 边缘检测</span><br><span class="line">│       ├── Sobel算子</span><br><span class="line">│       ├── Canny算子</span><br><span class="line">│       └── 拉普拉斯算子</span><br><span class="line">└── 频率域增强方法</span><br><span class="line">    ├── 低通滤波</span><br><span class="line">    │   ├── 理想低通滤波器</span><br><span class="line">    │   ├── 巴特沃斯低通滤波器</span><br><span class="line">    │   └── 高斯低通滤波器</span><br><span class="line">    ├── 高通滤波</span><br><span class="line">    │   ├── 理想高通滤波器</span><br><span class="line">    │   ├── 巴特沃斯高通滤波器</span><br><span class="line">    │   └── 高斯高通滤波器</span><br><span class="line">    └── 带通滤波和带阻滤波</span><br><span class="line">        ├── 带通滤波</span><br><span class="line">        └── 带阻滤波</span><br></pre></td></tr></table></figure><h1 id="图像的对比度增强"><a href="#图像的对比度增强" class="headerlink" title="图像的对比度增强"></a>图像的对比度增强</h1><h2 id="灰度变换"><a href="#灰度变换" class="headerlink" title="灰度变换"></a>灰度变换</h2><p>用于调整图像的亮度、对比度以及增强特定的视觉效果。其原理是<mark>通过改变像素的灰度值</mark>来达到预期的效果，主要用于图像的预处理，如增强、拉伸、反转等。</p><h3 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h3><script type="math/tex; mode=display">s = a \cdot r + b</script><p>其中，</p><p>$r$ 表示输入图像的灰度值;</p><p>$s$ 表示输出图像的灰度值; </p><p>$a$ 和 $b$ 为常数，控制图像的亮度和对比度。</p><h3 id="对数变换"><a href="#对数变换" class="headerlink" title="对数变换"></a>对数变换</h3><p>由于人眼所可以分辨的灰度的变化范围有限，所以当动态范围太大时，很高的亮度值把暗区的信号都掩盖了。</p><p>用于增强低灰度值的细节，使暗部细节更加清晰。</p><script type="math/tex; mode=display">s = c \cdot \log(1 + r)</script><p>其中，</p><p>$c$ 为常数，用于控制灰度变换的尺度;</p><p>$r$ 表示输入图像的灰度值。</p><h3 id="伽马（Gamma）变换"><a href="#伽马（Gamma）变换" class="headerlink" title="伽马（Gamma）变换"></a>伽马（Gamma）变换</h3><p>伽马变换可以增强暗区域的灰度值，抑制亮区的灰度值。</p><script type="math/tex; mode=display">s = c \cdot r^{\gamma}</script><p>其中，</p><p>$\gamma$ 为伽马值，$\gamma&gt;1$用于减暗图像，$0 &lt; \gamma &lt; 1$ 用于增亮图像；</p><p>$c$ 为常数，用于调整整体亮度。</p><h3 id="反转变换"><a href="#反转变换" class="headerlink" title="反转变换"></a>反转变换</h3><p>增强图像反差或获取负片效果。</p><script type="math/tex; mode=display">s = L - 1 - r</script><p>其中，</p><p>$L$ 为灰度级的总数（例如，对于 8 位图像，L = 256）。</p><h3 id="分段线性变换"><a href="#分段线性变换" class="headerlink" title="分段线性变换"></a>分段线性变换</h3><p>通过设置分段线性函数，可以调整特定灰度范围的图像细节。</p><script type="math/tex; mode=display">s =\begin{cases}\alpha \cdot r, & r < R_1 \\\frac{S_2 - S_1}{R_2 - R_1} \cdot (r - R_1) + S_1, & R_1 \leq r \leq R_2 \\\gamma \cdot (r-R_2) + S_2, & r > R_2\end{cases}</script><ul><li><strong>对比度拉伸</strong>：用于拉伸图像的对比度，将图像的灰度范围扩展。</li><li><strong>灰度切割</strong>：将特定灰度范围的值保留或放大，抑制其他灰度范围，增强特定灰度区域的细节。</li></ul><h1 id="直方图修正"><a href="#直方图修正" class="headerlink" title="直方图修正"></a>直方图修正</h1><p>通过调整图像的灰度分布来增强图像对比度。</p><h2 id="统计直方图"><a href="#统计直方图" class="headerlink" title="统计直方图"></a>统计直方图</h2><p><strong>统计直方图</strong>用于表示图像中各灰度级（亮度级别）的像素数量分布。</p><script type="math/tex; mode=display">p(s_k) = \frac{n_k}{n}</script><p>其中，</p><p>$s_k$是图像中第$k$级灰度，$n_k$是具有灰度$s_k$的像素个数。</p><h3 id="直方图与图像清晰性"><a href="#直方图与图像清晰性" class="headerlink" title="直方图与图像清晰性"></a>直方图与图像清晰性</h3><p>直方图反映了图像的清晰程度，当直方图均匀分布时，图像最清晰。</p><ul><li><strong>高亮图像</strong>：直方图会集中在高灰度级（右侧）。</li><li><strong>低亮度图像</strong>：直方图集中在低灰度级（左侧）。</li><li><strong>对比度较低图像</strong>：直方图会集中在灰度级中间范围，分布较窄。</li><li><strong>对比度较高图像</strong>：直方图分布较广，覆盖了较宽的灰度范围。</li></ul><h2 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h2><p><mark>将图像的灰度直方图分布尽量拉伸至均匀分布</mark>，使得图像的亮度和对比度得到增强。</p><script type="math/tex; mode=display">t = T(s) = \int_0^s p_s(w) \, dw</script><p>其中，</p><p>$s$ 为原图像的灰度级；$t$ 为均衡化后的灰度级；$p_s(w)$ 为原图像的灰度分布概率。</p><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li><p>列出原始图像灰度级 $s_k(0,1, \dots , L-1)$ （对于8位灰度图像$L=8$）</p></li><li><p>统计原始图像各灰度级像素 $n_k$</p></li><li><p>计算原始直方图 $p(s_k) = \frac{n_k}{n}$</p></li><li><p>计算累积直方图（累积分布函数（CDF）） $ t(s<em>k) = \sum</em>{i=0}^{k} p(s_i) $，$t(s_k)$ 为灰度级 $s_k$ 的累计概率密度</p></li><li><p>将累计概率映射到新的灰度级，并对结果（向下）取整。$ T(s_k) = \text{int}[(L - 1) \cdot t(s_k) + 0.5] $</p></li><li><p>确定映射对应关系：将每个灰度级 $s_k$ 映射到新的灰度级 $t(s_k)$，重新排序灰度级 $s_k’(0,1, \dots , L’-1)$</p></li><li><p>统计新图像各灰度级像素 $n_k’$</p></li><li><p>计算新的直方图 $p(s_k’) = \frac{n_k’}{n}$</p></li></ol><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>算法简单，易于实现，计算效率高，适合实时应用。</li><li>不需要预设参数，能够自适应不同图像的灰度分布，自动调整对比度。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li><p>不能用于交互方式的图像增强应用。</p></li><li><p>对于噪声较多的图像，均衡化可能会同时增强噪声，从而影响图像质量。</p></li></ul><h2 id="直方图规定化-Histogram-Specification"><a href="#直方图规定化-Histogram-Specification" class="headerlink" title="直方图规定化(Histogram Specification)"></a>直方图规定化(Histogram Specification)</h2><p>有时要求突出感兴趣灰度范围，即修正直方图使其具有要求的形式。</p><h3 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li><p>计算原始图像的累积直方图</p><p> $t(s<em>k) = \sum</em>{i=0}^{k} p(s_i)(i = 0,1, \dots , L-1)<br>$</p></li><li><p>计算目标图像的累计直方图 </p><p>$t<em>z(z_k) = \sum</em>{j=0}^{k} p_z(z_j)(j = 0,1, \dots , L-1)$</p></li><li><p>建立映射关系</p><p>将输入图像的累计概率 $t(s_k)$ 与目标直方图的累计概率 $t_z(z_k)$ 进行匹配，找到最接近的灰度级映射关系。</p><p>$s_k \rightarrow z_k$</p></li><li><p>根据映射关系，将输入图像中的每个灰度级 $s_k$ 映射到目标灰度级 $z_k$，生成匹配后的图像。</p></li></ol><p><img src="/images/图像处理/三/1.png" alt=""></p><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>可以将图像的灰度分布调整为特定的形状。</li><li>通过将不同图像的灰度分布规定为相同的参考分布，可使它们在视觉上更一致，适合于多图像拼接、图像数据库标准化等应用。</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li><p>规定化效果依赖于选择的参考图像，若参考图像质量不高，规定化后的图像效果也可能不理想。</p></li><li><p>相比直方图均衡化，直方图规定化需要两个图像的分布信息，并进行灰度匹配，计算复杂性较高。</p></li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li><strong>图像匹配和拼接</strong>：将多幅图像的灰度分布标准化，便于拼接。</li><li><strong>医学影像分析</strong>：将不同患者或不同设备拍摄的医学影像进行对比分析。</li><li><strong>图像风格迁移</strong>：通过规定化，模仿某幅图像的风格，产生风格相似的图像。</li></ul><h1 id="图像平滑"><a href="#图像平滑" class="headerlink" title="图像平滑"></a>图像平滑</h1><p>图像平滑（Image Smoothing）：通过减少图像中的噪声或细小的纹理，使图像看起来更加平滑和连续。常用于去除噪声、减少细节或提高图像质量。</p><h2 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h2><p>均值滤波是一种低通滤波器，将每个像素值替换为其邻域内像素值的平均值。这种方法能够平滑掉高频噪声，但也会导致边缘模糊。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>对于每个像素 $(i, j)$，使用一个 $k \times k$ 的窗口：</p><script type="math/tex; mode=display">g(i, j) = \frac{1}{k^2} \sum_{m=-a}^{a} \sum_{n=-a}^{a} f(i+m, j+n)</script><p>其中： </p><p>$f(i, j)$ 是原始图像的像素值 ；</p><p>$g(i, j)$ 是平滑后的像素值 ；</p><p>$a = \frac{k-1}{2}$</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li><strong>低频性</strong>：均值滤波能够去除高频噪声，使图像变得平滑。 </li><li><strong>线性性</strong>：均值滤波属于线性滤波器，因此可以分解为简单的加法和除法运算。 </li><li><strong>平滑性</strong>：均值滤波器会模糊图像边缘。</li></ul><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li><p><strong>优点</strong>：简单、快速，适合初步的噪声去除。 </p></li><li><p><strong>缺点</strong>：会模糊边缘，不适合保留图像细节。</p></li></ul><h2 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h2><p>采用高斯分布权重来计算窗口内的加权平均值。</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><script type="math/tex; mode=display">g(i, j) = \sum_{m=-a}^{a} \sum_{n=-a}^{a} f(i+m, j+n) \cdot G(m, n, \sigma)</script><p>其中，</p><p>$G(m, n, \sigma)$ 表示高斯核函数的权重，定义为：$G(m, n, \sigma) = \frac{1}{2\pi\sigma^2} e^{-\frac{m^2 + n^2}{2\sigma^2}}$；</p><p>$\sigma$ 控制高斯核的宽度，值越大则平滑效果越明显。</p><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><ul><li><p>高斯函数的可分离性</p><p>二维高斯滤波可以分解为两个一维滤波操作，分别在水平方向和竖直方向上应用。这种特性大大降低了计算复杂度，使高斯滤波在实际应用中更加高效。</p><script type="math/tex; mode=display">G(x, y) = \frac{1}{2\pi\sigma^2} e^{-\frac{x^2 + y^2}{2\sigma^2}}</script><script type="math/tex; mode=display">= \frac{1}{\sqrt{2\pi}\sigma} e^{-\frac{x^2}{2\sigma^2}} \cdot \frac{1}{\sqrt{2\pi}\sigma} e^{-\frac{y^2}{2\sigma^2}}</script><p>计算复杂度由 $O(n^2)$ 降低到 $O(2n)$，其中 $n$ 是图像的一维大小，因此更适合大型图像的平滑处理。</p></li><li><p><strong>平滑性</strong>：比均值滤波更平滑，且能保留一些边缘信息。</p></li><li><p>高斯函数的性质 </p><ul><li><p><strong>旋转对称性</strong>：二维高斯函数具有旋转对称性，即滤波器在各个方向上的平滑程度是相同的。这意味着无论方向如何，高斯滤波都能够以相同的方式平滑图像。 </p></li><li><p><strong>单调递减</strong>：高斯函数是单值递减函数，随着距离中心点的增大，像素点的系数逐渐递减。即距离中心点越远的像素点对平滑结果的影响越小。 </p></li><li><p><strong>平滑程度与方差关系</strong>：高斯平滑的程度由方差 \sigma 表征，\sigma 值越大，平滑程度越强，即图像会变得更加模糊；\sigma 值越小，平滑效果越弱。</p></li></ul></li></ul><h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li><p><strong>优点</strong>：</p><p>能较好地保留边缘细节，适合自然噪声的去除。 </p></li><li><p><strong>缺点</strong>：计算复杂度较高。</p></li></ul><h2 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h2><p>中值滤波是一种对于干扰脉冲和点状噪声有良好抑制作用，而对图像边缘能较好保持的非线性图像增强技术，将窗口内的像素替换为中值，以更好地去除椒盐噪声（噪声以孤立点的形式出现，这些点对应的像素数很少，<br>而图像则是由像素数较多、面积较大的块构成）。</p><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>对于每个像素 $(i, j)$，使用 $k \times k$ 窗口内的像素值，并将其替换为该区域的中值：</p><script type="math/tex; mode=display">g(i, j) = \text{median}(f(i+m, j+n))</script><p>其中 $(m, n)$ 是 $k \times k$ 窗口内的像素坐标。</p><h3 id="函数性质"><a href="#函数性质" class="headerlink" title="函数性质"></a>函数性质</h3><ul><li><p><strong>非线性</strong>：中值滤波是非线性滤波，不会对图像进行加权平均。 </p></li><li><p><strong>边缘保留性</strong>：中值滤波能够较好地保留边缘信息，不会模糊边缘。 </p></li></ul><h3 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li><p><strong>优点</strong>：对椒盐噪声和干扰脉冲，尤其适合于目标物形状是块状时的图像滤波非常有效，且保留边缘信息。 </p></li><li><p><strong>缺点</strong>：</p><ul><li><p>无法去除其他类型噪声，且计算较复杂。</p></li><li><p>当噪声的宽度大于窗宽的一半时，中值滤波无效。</p></li><li><p><mark>不适用：需要保持细线状及尖顶角目标物细节。</mark></p></li></ul></li></ul><h2 id="自适应中值滤波"><a href="#自适应中值滤波" class="headerlink" title="自适应中值滤波"></a>自适应中值滤波</h2><p>自适应中值滤波（Adaptive Median Filtering）会根据每个像素的邻域动态调整窗口大小</p><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>自适应中值滤波通过计算像素邻域中的最小值、最大值和中值，判断当前像素是否为噪声。</p><p><strong>算法步骤：</strong></p><p>设窗口大小为 $S \times S$，当前像素为 $f(i, j)$，窗口内的中值为 $Z<em>{med}$，最小值为 $Z</em>{min}$，最大值为 $Z_{max}$。</p><ol><li><p><strong>定义窗口</strong>：从最小窗口尺寸开始（如 $3 \times 3$），计算窗口中的最小值、最大值和中值。 </p></li><li><p><strong>判断条件</strong>： </p><ul><li><p><strong>步骤A</strong>：检查窗口中的中值$Z_{med}$是否在最小值和最大值之间。</p><p>$A1 = Z<em>{med} - Z</em>{min}$</p><p>$A2 = Z<em>{med} - Z</em>{max}$</p><ul><li><p>如果满足 $A1 &gt; 0$ 且 $A2 &lt; 0$，继续步骤B。</p></li><li><p>如果不满足，增大窗口尺寸 $S$ 并重新计算，直到达到最大窗口尺寸。</p></li></ul></li><li><p><strong>步骤B</strong>：检查当前像素值是否在最小值和最大值之间。</p><p>$B1 = f(i, j) - Z_{min}$</p><p>$B2 = f(i, j) - Z_{max}$</p><ul><li><p>如果满足 $B1 &gt; 0$ 且 $B2 &lt; 0$ ，用当前像素值替换为中值。</p></li><li><p>如果不满足，用中值 $Z_{med}$ 替代 $f(i, j)$ 的值。</p></li></ul></li></ul></li><li><p><strong>输出结果</strong>：在整个图像中重复上述步骤，最终得到去噪结果。</p></li></ol><h3 id="优缺点-5"><a href="#优缺点-5" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul><li><strong>有效去除脉冲噪声</strong>：自适应中值滤波器特别适合去除椒盐噪声。</li><li><strong>自适应窗口</strong>：根据局部噪声水平调整窗口大小，避免过度模糊。</li><li><strong>边缘保护</strong>：在边缘和细节区域滤波效果良好。</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li><strong>计算复杂度高</strong>：逐像素调整窗口大小，计算量大，处理速度较慢。</li><li><strong>对高密度噪声效果有限</strong>：在高密度噪声下可能需要更大的窗口，导致平滑效果增强。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">adaptive_median_filter</span>(<span class="params">image, max_window_size=<span class="number">7</span></span>):</span><br><span class="line">    padded_image = cv2.copyMakeBorder(image, max_window_size//<span class="number">2</span>, max_window_size//<span class="number">2</span>, max_window_size//<span class="number">2</span>, max_window_size//<span class="number">2</span>, cv2.BORDER_REFLECT)</span><br><span class="line">    output_image = np.zeros_like(image)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">apply_filter</span>(<span class="params">i, j</span>):</span><br><span class="line">        window_size = <span class="number">3</span></span><br><span class="line">        <span class="keyword">while</span> window_size &lt;= max_window_size:</span><br><span class="line">            local_window = padded_image[i - window_size//<span class="number">2</span>:i + window_size//<span class="number">2</span> + <span class="number">1</span>, j - window_size//<span class="number">2</span>:j + window_size//<span class="number">2</span> + <span class="number">1</span>]</span><br><span class="line">            z_min, z_max = np.<span class="built_in">min</span>(local_window), np.<span class="built_in">max</span>(local_window)</span><br><span class="line">            z_med = np.median(local_window)</span><br><span class="line">            pixel_value = padded_image[i, j]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step A</span></span><br><span class="line">            A1 = z_med - z_min</span><br><span class="line">            A2 = z_med - z_max</span><br><span class="line">            <span class="keyword">if</span> A1 &gt; <span class="number">0</span> <span class="keyword">and</span> A2 &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># Step B</span></span><br><span class="line">                B1 = pixel_value - z_min</span><br><span class="line">                B2 = pixel_value - z_max</span><br><span class="line">                <span class="keyword">return</span> pixel_value <span class="keyword">if</span> B1 &gt; <span class="number">0</span> <span class="keyword">and</span> B2 &lt; <span class="number">0</span> <span class="keyword">else</span> z_med</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                window_size += <span class="number">2</span>  <span class="comment"># Increase window size</span></span><br><span class="line">        <span class="keyword">return</span> z_med  <span class="comment"># Use median if max window size reached</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Apply the filter to each pixel</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_window_size//<span class="number">2</span>, padded_image.shape[<span class="number">0</span>] - max_window_size//<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(max_window_size//<span class="number">2</span>, padded_image.shape[<span class="number">1</span>] - max_window_size//<span class="number">2</span>):</span><br><span class="line">            output_image[i - max_window_size//<span class="number">2</span>, j - max_window_size//<span class="number">2</span>] = apply_filter(i, j)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output_image</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load a grayscale image and apply the adaptive median filter</span></span><br><span class="line">image = cv2.imread(<span class="string">&quot;noisy_image.png&quot;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">filtered_image = adaptive_median_filter(image)</span><br><span class="line">cv2.imshow(<span class="string">&quot;Filtered Image&quot;</span>, filtered_image)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h2 id="双边滤波"><a href="#双边滤波" class="headerlink" title="双边滤波"></a>双边滤波</h2><p>非线性滤波器，不仅考虑空间距离，还结合像素值差异，保留边缘信息的同时平滑图像。</p><h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><p>对于每个像素 $(i, j)$，</p><script type="math/tex; mode=display">g(i, j) = \frac{\sum_{m=-a}^{a} \sum_{n=-a}^{a} f(i+m, j+n) \cdot w(i, j, m, n)}{\sum_{m=-a}^{a} \sum_{n=-a}^{a} w(i, j, m, n)}</script><p>其中，</p><p>权重 $w(i, j, m, n)$ 包含空间距离和灰度差异两个高斯分布函数 $w(i, j, m, n) = e^{-\frac{(m^2 + n^2)}{2\sigma_s^2}} \cdot e^{-\frac{(f(i, j) - f(i+m, j+n))^2}{2\sigma_r^2}}$</p><p>$\sigma_s$ 控制空间距离影响，$\sigma_r$ 控制灰度差异影响。</p><h3 id="性质-2"><a href="#性质-2" class="headerlink" title="性质"></a>性质</h3><ul><li><strong>边缘保留</strong>：双边滤波可平滑图像大面积区域，且保留边缘。 </li><li><strong>非线性</strong>：根据像素灰度值差异调整权重，属于非线性操作。</li></ul><h3 id="优缺点-6"><a href="#优缺点-6" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li><strong>优点</strong>：适合去除噪声且保留边缘细节，适合高质量平滑。 </li><li><strong>缺点</strong>：计算量大，速度较慢，适合较小图像。</li></ul><h2 id="自适应局部噪声消除滤波器"><a href="#自适应局部噪声消除滤波器" class="headerlink" title="自适应局部噪声消除滤波器"></a>自适应局部噪声消除滤波器</h2><p>自适应局部噪声消除滤波器（Adaptive Local Noise Reduction Filter）：根据图像局部区域内的统计信息对滤波器进行动态调整，以最大程度地保留图像细节，同时有效去除噪声，特别适用于含有随机噪声的图像。</p><h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h3><p>自适应局部噪声消除滤波器在每个像素的局部邻域内计算<mark>局部均值和方差</mark>，以确定该区域内噪声的程度和图像内容的细节。对于每个像素，该滤波器依据局部和全局的图像统计信息。</p><p>像素值为 $f(i, j)$，滤波后的像素值为 $g(i, j)$：</p><script type="math/tex; mode=display">g(i, j) = \bar{f}_{L} + \frac{\sigma_{L}^2}{\sigma_{L}^2 + \sigma_n^2} \cdot (f(i, j) - \bar{f}_{L})</script><p>其中：</p><ul><li>$\bar{f}_{L}$ 表示当前像素 $(i, j)$ 所在局部窗口的平均值； </li><li>$\sigma_{L}^2$ 表示该窗口内像素的方差；</li><li>$\sigma_n^2$ 表示图像中噪声的方差，通常可通过图像先验知识或噪声模型获得。</li></ul><p>当局部方差较大时，认为该区域包含图像细节，应减少平滑力度；</p><p>当局部方差较小时，认为该区域噪声较多，应增加平滑力度。</p><h3 id="优缺点-7"><a href="#优缺点-7" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ul><li><strong>高效去噪</strong>：自适应调整滤波器，能够有效减少噪声影响。</li><li><strong>细节保留</strong>：在图像细节较多的区域（高方差）中，滤波器平滑程度较小，能保留边缘细节。</li><li><strong>适用性强</strong>：适用于多种噪声类型，尤其是随机噪声。</li></ul><h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ul><li><p><strong>计算复杂</strong>：需要计算每个像素的局部均值和方差，计算量较大。</p></li><li><p><strong>依赖噪声方差</strong>：对噪声方差 $\sigma_n^2$ 的估计准确性较为敏感，错误估计会影响滤波效果。 </p></li><li><p><strong>适用范围有限</strong>：对于某些复杂噪声或强边缘区域，效果不如其他高效去噪算法。</p></li></ul><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">adaptive_local_noise_filter</span>(<span class="params">image, window_size, noise_variance</span>):</span><br><span class="line"> padded_image = cv2.copyMakeBorder(image, window_size//<span class="number">2</span>, window_size//<span class="number">2</span>, window_size//<span class="number">2</span>, window_size//<span class="number">2</span>, cv2.BORDER_REFLECT)</span><br><span class="line"> output_image = np.zeros_like(image, dtype=<span class="built_in">float</span>)</span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(window_size // <span class="number">2</span>, padded_image.shape[<span class="number">0</span>] - window_size // <span class="number">2</span>):</span><br><span class="line"> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(window_size // <span class="number">2</span>, padded_image.shape[<span class="number">1</span>] - window_size // <span class="number">2</span>):</span><br><span class="line"> local_window = padded_image[i - window_size//<span class="number">2</span>:i + window_size//<span class="number">2</span> + <span class="number">1</span>, j - window_size//<span class="number">2</span>:j + window_size//<span class="number">2</span> + <span class="number">1</span>]</span><br><span class="line"> local_mean = np.mean(local_window)</span><br><span class="line"> local_variance = np.var(local_window)</span><br><span class="line"> pixel_value = image[i - window_size//<span class="number">2</span>, j - window_size//<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用自适应滤波公式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local_variance &gt; <span class="number">0</span>:</span><br><span class="line"> output_image[i - window_size//<span class="number">2</span>, j - window_size//<span class="number">2</span>] = local_mean + (local_variance / (local_variance + noise_variance)) * (pixel_value - local_mean)</span><br><span class="line"> <span class="keyword">else</span>:</span><br><span class="line"> output_image[i - window_size//<span class="number">2</span>, j - window_size//<span class="number">2</span>] = local_mean</span><br><span class="line"> <span class="keyword">return</span> output_image.astype(np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载图像并调用滤波函数</span></span><br><span class="line"></span><br><span class="line">image = cv2.imread(<span class="string">&quot;noisy_image.png&quot;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">filtered_image = adaptive_local_noise_filter(image, window_size=<span class="number">5</span>, noise_variance=<span class="number">20</span>)</span><br><span class="line">cv2.imshow(<span class="string">&quot;Filtered Image&quot;</span>, filtered_image)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h2 id="各向异性扩散"><a href="#各向异性扩散" class="headerlink" title="各向异性扩散"></a>各向异性扩散</h2><p>各向异性扩散（Anisotropic Diffusion）是一种图像去噪方法，也称为Perona-Malik滤波器。其通过图像的局部梯度调整扩散系数，在保留边缘细节的同时减少噪声，实现“平滑但不模糊”的效果。与各向同性扩散不同，各向异性扩散在噪声较高的区域进行强烈平滑，而在边缘区域减少扩散，以保持图像边缘的锐利度。</p><h3 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h3><p>在各向异性扩散中，图像被看作一个热量场，像素值视为温度。扩散的过程类似于热传导，模拟“热量”在像素间传递。但与经典的各向同性扩散不同，各向异性扩散会<mark>根据当前像素和周围像素的关系决定扩散的强度</mark>。具体而言，各向异性扩散在图像边缘处减少扩散，从而保留边缘信息。</p><script type="math/tex; mode=display">\frac{\partial I(x, y, t)}{\partial t} = \nabla \cdot \left( c(x, y, t) \cdot \nabla I(x, y, t) \right)</script><p>其中： </p><ul><li><p>$I(x, y, t)$ 表示时间 $t$ 时刻的图像强度值； </p></li><li><p>$\nabla$ 表示梯度操作符，$\nabla I$ 是图像的梯度（表示图像边缘的强度和方向）； </p></li><li><p>$c(x, y, t)$ 是扩散系数，与图像的梯度大小相关，控制扩散的强度。</p></li></ul><h1 id="图像锐化"><a href="#图像锐化" class="headerlink" title="图像锐化"></a>图像锐化</h1><p>图像模糊的原因：成像系统聚焦不好或信道过窄；平均或积分运算。</p><p>图像锐化（Image Sharpening）是一种增强图像中边缘和细节的技术，能够突出图像中变化较大的区域，使得物体轮廓更加清晰。锐化主要用于视觉增强，使边缘、纹理等细节更加清晰分明。</p><p>基于图像梯度和高频成分的增强。通常，图像中的<mark>高频部分代表边缘和细节</mark>，锐化方法通过增加这些高频成分来实现增强效果。</p><h2 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h2><p>边缘通常发生在图像中亮度或颜色变化明显的区域，即像素值的快速变化点。检测这些变化可以使用图像的一阶或二阶导数来实现.</p><p>边缘检测（Edge Detection）是图像处理中用于识别图像中物体边界的技术，通过检测像素值变化剧烈的区域来提取图像的结构信息。</p><h3 id="边缘类型"><a href="#边缘类型" class="headerlink" title="边缘类型"></a>边缘类型</h3><ul><li><p>突变型细节：检测一阶微分极值点，二阶微分过0点</p></li><li><p>细线型细节：检测一阶微分过0点，二阶微分极值点</p></li><li><p>渐变型细节：难检测，二阶微分信息略多于一阶微分</p></li></ul><p><img src="/images/图像处理/三/2.png" alt=""></p><p><img src="/images/图像处理/三/3.png" alt=""></p><h2 id="一阶微分算子"><a href="#一阶微分算子" class="headerlink" title="一阶微分算子"></a>一阶微分算子</h2><p>以下算子模板（卷积核）用来边缘检测，<mark>锐化 = 原图像和梯度图像</mark></p><h3 id="梯度算子"><a href="#梯度算子" class="headerlink" title="梯度算子"></a>梯度算子</h3><h4 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h4><p>图像$f(x,y)$在$(x,y)$处的梯度：$G[f( x , y )] = [\frac{\partial f}{\partial x} \  \frac{\partial f}{\partial y}]^T$</p><p>使用梯度的幅度来代替 $G[f( x , y )] = [(\frac{\partial f}{\partial x})^2 +  (\frac{\partial f}{\partial y})^2]^\frac{1}{2} = |f_x| + |f_y|$</p><p>图像为离散的数字矩阵，使用差分代替微分：</p><p>水平：</p><script type="math/tex; mode=display">\frac{\partial f}{\partial x} = f(x+1, y) - f(x, y)</script><p>垂直：</p><script type="math/tex; mode=display">\frac{\partial f}{\partial y} = f(x, y+1) - f(x, y)</script><p>梯度图像$g(x,y)$：</p><script type="math/tex; mode=display">g(x,y) = |f_x| + |f_y| = |f(x+1, y) - f(x, y)| + |f(x, y+1) - f(x, y)|</script><h4 id="图像锐化和边缘检测"><a href="#图像锐化和边缘检测" class="headerlink" title="图像锐化和边缘检测"></a>图像锐化和边缘检测</h4><p>边缘检测：检测出边缘所在的位置，找出微分中的过零点或极值点，得到梯度图像。</p><p>图像锐化：原图像和梯度图像相加，突出边缘和轮廓。</p><h4 id="阈值化检测"><a href="#阈值化检测" class="headerlink" title="阈值化检测"></a>阈值化检测</h4><ol><li><p>固定边界灰度</p><script type="math/tex; mode=display">g(x, y) = \begin{cases} L_G & \text{if } f(x, y) \geq T \\f(x,y) & \text{if } f(x, y) < T\end{cases}</script></li><li><p>突出边界</p><script type="math/tex; mode=display">g(x, y) = \begin{cases} G[f(x,y)] & \text{if } G[f(x,y)] \geq T \\f(x,y) & \text{if } else\end{cases}</script></li><li><p>二值化边界与背景</p><script type="math/tex; mode=display">g(x, y) = \begin{cases} L_G & \text{if } f(x, y) \geq T \\L_B & \text{if } f(x, y) < T\end{cases}</script></li></ol><p>阈值的选择决定边缘检测的效果。</p><h3 id="Roberts算子"><a href="#Roberts算子" class="headerlink" title="Roberts算子"></a>Roberts算子</h3><p>Roberts算子是一种简单的差分算子，通过在对角线方向上进行卷积来计算图像的梯度。</p><p>对于一个图像像素 $(i, j)$，使用以下卷积核(模板)计算水平和垂直方向上的梯度：</p><script type="math/tex; mode=display">G_x = \begin{bmatrix} 1 & 0 \\ 0 & -1 \end{bmatrix}, \quad G_y = \begin{bmatrix} 0 & 1 \\ -1 & 0 \end{bmatrix}</script><script type="math/tex; mode=display">g(x,y) = |f(x, y) - f(x+1, y+1)| + |f(x+1, y) - f(x, y+1)|</script><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><p><strong>优点</strong>：计算速度快，适用于实时处理。</p></li><li><p><strong>缺点</strong>：对噪声敏感，不适合处理高噪声图像。</p></li></ul><h3 id="Sobel算子"><a href="#Sobel算子" class="headerlink" title="Sobel算子"></a>Sobel算子</h3><p>Sobel算子使用<mark>加权平均</mark>的方法计算水平方向和垂直方向的梯度，对图像中<mark>随机噪声有一定的平滑作用</mark>。</p><script type="math/tex; mode=display">G_x = \begin{bmatrix} -1 & 0 & 1 \\ -2 & 0 & 2 \\ -1 & 0 & 1 \end{bmatrix}, \quad G_y = \begin{bmatrix} -1 & -2 & -1 \\ 0 & 0 & 0 \\ 1 & 2 & 1 \end{bmatrix}</script><script type="math/tex; mode=display">f_x(x, y) = (f(x+1, y-1) + 2 \cdot f(x+1, y) + f(x+1, y+1)) - (f(x-1, y-1) + 2 \cdot f(x-1, y) + f(x-1, y+1))</script><script type="math/tex; mode=display">f_y(x, y) = (f(x-1, y+1) + 2 \cdot f(x, y+1) + f(x+1, y+1)) - (f(x-1, y-1) + 2 \cdot f(x, y-1) + f(x+1, y-1))</script><script type="math/tex; mode=display">g(x,y) = |f_x| + |f_y|</script><p>相隔两行或两列求差分，故边缘两侧的元素得到了增强，<mark>边缘显得粗而亮</mark></p><h3 id="Prewitt算子"><a href="#Prewitt算子" class="headerlink" title="Prewitt算子"></a>Prewitt算子</h3><p>通过在水平和垂直方向上分别计算图像的梯度来识别边缘。Prewitt算子与Sobel算子类似，但它在计算梯度时不加权中心像素，因此计算更加简单。</p><p>在水平方向和垂直方向上的卷积核(模板)分别为：</p><script type="math/tex; mode=display">G_x = \begin{bmatrix}-1 & 0 & +1 \\-1 & 0 & +1 \\-1 & 0 & +1 \\\end{bmatrix}</script><script type="math/tex; mode=display">G_y = \begin{bmatrix}+1 & +1 & +1 \\0 & 0 & 0 \\-1 & -1 & -1 \\\end{bmatrix}</script><script type="math/tex; mode=display">f_x(x, y) = |f(x+1, y-1) + f(x+1, y) + f(x+1, y+1)| - |f(x-1, y-1) + f(x-1, y) + f(x-1, y+1)|</script><script type="math/tex; mode=display">f_y(x, y) = |f(x-1, y+1) + f(x, y+1) + f(x+1, y+1)| - |f(x-1, y-1) + f(x, y-1) + f(x+1, y-1)|</script><script type="math/tex; mode=display">g(x,y) = |f_x| + |f_y|</script><h3 id="其他算子"><a href="#其他算子" class="headerlink" title="其他算子"></a>其他算子</h3><h4 id="Kirsch算子"><a href="#Kirsch算子" class="headerlink" title="Kirsch算子"></a>Kirsch算子</h4><p>Kirsch算子是一种方向性算子，它使用8个$3 \times 3$卷积核，每个核对应一个不同的方向。</p><ul><li>水平方向：</li></ul><script type="math/tex; mode=display">K_x =\begin{bmatrix}-3 & -3 & 5 \\-3 & 0 & 5 \\-3 & -3 & 5 \\\end{bmatrix}</script><ul><li>垂直方向：</li></ul><script type="math/tex; mode=display">K_y =\begin{bmatrix}-3 & -3 & -3 \\5 & 0 & 5 \\5 & 5 & 5 \\\end{bmatrix}</script><ul><li>45度方向：</li></ul><script type="math/tex; mode=display">K_{45} =\begin{bmatrix}-3 & 5 & 5 \\-3 & 0 & 5 \\-3 & -3 & -3 \\\end{bmatrix}</script><ul><li>135度方向：</li></ul><script type="math/tex; mode=display">K_{135} =\begin{bmatrix}5 & 5 & -3 \\5 & 0 & -3 \\-3 & -3 & -3 \\\end{bmatrix}</script><p>其中，每个卷积核可以检测特定方向的边缘。</p><h3 id="边缘方向"><a href="#边缘方向" class="headerlink" title="边缘方向"></a>边缘方向</h3><p><em>梯度方向</em>：函数最大增长的方向，即图像灰度值最大增长的方向，沿该方向灰度值的变化速率最大</p><script type="math/tex; mode=display">\phi (x,y) = \arctan (\frac{f_y}{f_x})</script><p><em>边缘方向</em>：垂直于梯度方向</p><script type="math/tex; mode=display">\theta (x,y) = \arctan (\frac{f_x}{f_y})</script><p>边缘方向的估计方法：</p><p>将8个或更多模板分别作用在图像上，取最大响应作为梯度幅度，梯度的方向为对应模板确定的方向。</p><h2 id="二阶微分算子"><a href="#二阶微分算子" class="headerlink" title="二阶微分算子"></a>二阶微分算子</h2><p>二阶微分算子用于检测图像中的边缘位置，通过检测灰度值变化的二阶导数，能够有效找到图像中的边缘。不同于一阶微分算子，二阶微分算子更加敏感，可以在边缘位置产生尖锐的响应。</p><h3 id="拉普拉斯算子"><a href="#拉普拉斯算子" class="headerlink" title="拉普拉斯算子"></a>拉普拉斯算子</h3><p>通过计算像素点在两个方向上的二阶导数之和来检测边缘。拉普拉斯算子的主要特点是它对所有方向上的变化同样敏感，适用于在多个方向上检测边缘。</p><script type="math/tex; mode=display">\frac{\partial^2 f}{\partial x^2} = \Delta_xf(x+1,y)-\Delta_xf(x,y)</script><script type="math/tex; mode=display">= f ( x + 1 , y ) + f ( x − 1 , y ) − 2 f ( x , y )</script><script type="math/tex; mode=display">\frac{\partial^2 f}{\partial y^2} = \Delta_xf(x,y+1)-\Delta_xf(x,y)</script><script type="math/tex; mode=display">= f ( x , y + 1 ) + f ( x , y − 1 ) − 2 f ( x , y )</script><script type="math/tex; mode=display">\nabla^2 f(x, y) = \frac{\partial^2 f}{\partial x^2} + \frac{\partial^2 f}{\partial y^2}= f ( x + 1 , y ) + f ( x − 1 , y )+ f ( x , y + 1 ) + f ( x , y − 1 ) − 4 f ( x , y )</script><p>模板：</p><script type="math/tex; mode=display">G =    \begin{bmatrix}   0 & -1 & 0 \\   -1 & 4 & -1 \\   0 & -1 & 0 \\   \end{bmatrix}</script><p>锐化模板：</p><script type="math/tex; mode=display">G =    \begin{bmatrix}   0 & -1 & 0 \\   -1 & 5 & -1 \\   0 & -1 & 0 \\   \end{bmatrix}</script><p>对待模板$G$运算得到的负值：</p><ul><li><p>取绝对值</p></li><li><p>加上正整数，有浮雕效果</p></li></ul><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p><strong>优点</strong>：</p><ul><li><p>拉普拉斯算子在检测边缘时对方向不敏感，因此可以检测所有方向的边缘。</p></li><li><p>在检测图像的细小边缘特征方面表现良好，适合高频信息检测。</p></li></ul><p><strong>缺点</strong>：</p><ul><li><p>对噪声较为敏感，容易导致图像中噪声被错误识别为边缘。</p></li><li><p>二阶微分对噪声的放大效应较明显，通常需要在应用前对图像进行平滑处理。</p></li></ul><h2 id="高斯滤波与边缘检测"><a href="#高斯滤波与边缘检测" class="headerlink" title="高斯滤波与边缘检测"></a>高斯滤波与边缘检测</h2><h3 id="高斯函数"><a href="#高斯函数" class="headerlink" title="高斯函数"></a>高斯函数</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><strong>二元高斯函数</strong></p><script type="math/tex; mode=display">g(x, y) = \frac{1}{2\pi \sigma^2} e^{-\frac{x^2 + y^2}{2\sigma^2}}</script><p>$\sigma$ 是标准差，控制高斯函数的扩展范围</p><p><strong>一阶导数</strong></p><p>高斯函数的一阶导数用于检测图像中的变化方向</p><script type="math/tex; mode=display">\frac{\partial g}{\partial x} = -\frac{x}{\sigma^2} g(x, y)</script><script type="math/tex; mode=display">\frac{\partial g}{\partial y} = -\frac{y}{\sigma^2} g(x, y)</script><script type="math/tex; mode=display">\nabla g(x,y) = -\frac{x+y}{\sigma^2} g(x, y)</script><p><strong>二阶导数</strong></p><script type="math/tex; mode=display">\frac{\partial^2 G}{\partial x^2} = \frac{(x^2 - \sigma^2)}{\sigma^4} G(x, y)</script><script type="math/tex; mode=display">\frac{\partial^2 G}{\partial y^2} = \frac{(y^2 - \sigma^2)}{\sigma^4} G(x, y)</script><script type="math/tex; mode=display">\nabla ^2 g(x,y) = \frac{(x^2 +y^2 - 2\sigma^2)}{\sigma^4} G(x, y)</script><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul><li><p>随着远离原点，权值逐渐减小到零，表明离中心较近的图像值比远处的更重要；标准差σ决定邻域范围，总权值的95％包含在2σ的中间范围内。</p></li><li><p>二阶导数具有光滑的中间突出部分，函数值为负；两个光滑的侧边突出部分，值为正。零交叉位于-σ和+σ处，与$h(x)$的拐点和$h’(x)$的极值点对应。高斯函数应用的一个数学基础。</p></li><li><p>1D形式绕垂直轴旋转得各向同性的2D函数形式（在任意过原点的切面上具有相同的1D高斯截面），其二阶导数形式像一个宽边帽或称为墨西哥草帽。高斯滤波器在各方向上平滑程度相同。</p></li></ul><h3 id="LoG算子"><a href="#LoG算子" class="headerlink" title="LoG算子"></a>LoG算子</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>先对图像进行高斯平滑（去除噪声），然后用拉普拉斯算子检测边缘。</p><script type="math/tex; mode=display">\nabla^2 [f(x,y)*h(x,y)] = f(x,y)*\nabla^2h(x,y)</script><p>$\nabla^2h(x,y)$ 为$LoG$滤波器(算子)； $\sigma$ 为尺度因子，大的值可用来检测模糊的边缘，小的值可用来检测聚焦良好的图像细节。</p><p><img src="/images/图像处理/三/4.png" alt=""></p><p>$\omega<em>{2D} = 2 \sigma$ 确定滤波器大小。为了不使函数被过分地截短，应在足够大的窗口内作计算，窗口宽度通常取 $\omega_d \geq 3.6 \omega</em>{2D}  $</p><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>模板大小由 $\sigma$ 决定</p><script type="math/tex; mode=display">\begin{bmatrix}0 & 0 & -1 & 0 & 0 \\0 & -1 & -2 & -1 & 0 \\-1 & -2 & 16 & -2 & -1 \\0 & -1 & -2 & -1 & 0 \\0 & 0 & -1 & 0 & 0 \\\end{bmatrix}</script><h3 id="DoG算子"><a href="#DoG算子" class="headerlink" title="DoG算子"></a>DoG算子</h3><p>DoG算子 (Difference of Gaussian)：用两个不同标准差的高斯函数平滑图<br>像，将结果相减，实现滤波，再利用过零点检测等方式处理滤波图像，实现边缘检测。</p><script type="math/tex; mode=display">DoG(x, y) = h(x, y, k\sigma) - h(x, y, \sigma)</script><h3 id="Canny算子"><a href="#Canny算子" class="headerlink" title="Canny算子"></a>Canny算子</h3><blockquote><p>最优边缘检测的三个主要评价标准:</p><ol><li><p>低错误率。标识出尽可能多的实际边缘，同时尽可能的减少噪声产生的误报。</p></li><li><p>对边缘的定位准确。标识出的边缘要与图像中的实际边缘尽可能接近。</p></li><li><p>最小响应。图像中的边缘最好只标识一次，并且可能存在的图像噪声部分不应标识为边缘。</p></li></ol></blockquote><p><strong>算法步骤：</strong></p><ol><li><p>使用高斯平滑滤波器卷积降噪</p></li><li><p>计算平滑图像的梯度幅值和方向，可采用不同的梯度算子</p></li><li><p>对梯度幅值应用非极大抑制，即找出图像梯度中的局部极大值点，其他非局部极大值点置零</p></li><li><p>使用双阈值检测：设定高、低两个阈值，将大于高阈值的像素点作为强边缘，低于低阈值的像素点作为非边缘，介于两者之间的作为弱边缘。</p></li><li><p>连接边缘：从强边缘像素出发，连接到弱边缘像素，形成最终的边缘检测结果。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新机械硬盘如何在Ubuntu使用</title>
      <link href="/2024/11/03/Linux/%E6%96%B0%E6%9C%BA%E6%A2%B0%E7%A1%AC%E7%9B%98%E5%A6%82%E4%BD%95%E5%9C%A8Ubuntu%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/11/03/Linux/%E6%96%B0%E6%9C%BA%E6%A2%B0%E7%A1%AC%E7%9B%98%E5%A6%82%E4%BD%95%E5%9C%A8Ubuntu%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>新机械硬盘挂载到ubuntu系统</p></blockquote><h1 id="检查硬盘连接状态"><a href="#检查硬盘连接状态" class="headerlink" title="检查硬盘连接状态"></a>检查硬盘连接状态</h1><p>先确认硬盘已被系统识别到</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk</span><br></pre></td></tr></table></figure><p>命令会列出所有连接的存储设备。新硬盘通常会显示为 <code>/dev/sdX</code>，其中 <code>X</code> 是字母（例如 <code>sda</code>、<code>sdb</code>）。</p><p>我的:<code>sda 8:0 0 1.8T 0 disk</code></p><p><code>TYPE</code> 类型显示为 <code>disk</code>，这意味着还没有分区或文件系统。</p><h1 id="使用-fdisk-进行分区"><a href="#使用-fdisk-进行分区" class="headerlink" title="使用 fdisk 进行分区"></a>使用 <code>fdisk</code> 进行分区</h1><p>使用 <code>fdisk</code> 工具对硬盘进行分区。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fdisk /dev/sda # 打开 fdisk 工具，指定要操作的硬盘为 /dev/sda。</span><br></pre></td></tr></table></figure><ol><li><p>显示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Welcome to fdisk (util-linux 2.34).</span><br><span class="line">Changes will remain in memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write command.</span><br><span class="line">Command (m for help):</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输入m</span></span><br><span class="line">Help:</span><br><span class="line">  DOS (MBR)</span><br><span class="line">   a   toggle a bootable flag</span><br><span class="line">   b   edit nested BSD disklabel</span><br><span class="line">   c   toggle the dos compatibility flag</span><br><span class="line">  Generic</span><br><span class="line">   d   delete a partition</span><br><span class="line">   F   list free unpartitioned space</span><br><span class="line">   l   list known partition types</span><br><span class="line">   n   add a new partition</span><br><span class="line">   p   print the partition table</span><br><span class="line">   t   change a partition type</span><br><span class="line">   v   verify the partition table</span><br><span class="line">   i   print information about a partition</span><br><span class="line">  Misc</span><br><span class="line">   m   print this menu</span><br><span class="line">   u   change display/entry units</span><br><span class="line">   x   extra functionality (experts only)</span><br><span class="line">  Script</span><br><span class="line">   I   load disk layout from sfdisk script file</span><br><span class="line">   O   dump disk layout to sfdisk script file</span><br><span class="line">  Save &amp; Exit</span><br><span class="line">   w   write table to disk and exit</span><br><span class="line">   q   quit without saving changes</span><br><span class="line">  Create a new label</span><br><span class="line">   g   create a new empty GPT partition table</span><br><span class="line">   G   create a new empty SGI (IRIX) partition table</span><br><span class="line">   o   create a new empty DOS partition table</span><br><span class="line">   s   create a new empty Sun partition table</span><br></pre></td></tr></table></figure></li><li><p>查看当前分区（查看当前的分区表）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Command (m for help): p</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我的显示：</span></span><br><span class="line">Disk /dev/sda: 1.84 TiB, 2000398934016 bytes, 3907029168 sectors</span><br><span class="line">Disk model: EARZ-00C5XB0    </span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 4096 bytes</span><br><span class="line">I/O size (minimum/optimal): 4096 bytes / 4096 bytes</span><br><span class="line">Disklabel type: dos</span><br><span class="line">Disk identifier: 0xf17061e0</span><br></pre></td></tr></table></figure></li><li><p>创建新分区</p><ol><li><p>输入<code>n</code>创建新分区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Command (m for help): n</span><br><span class="line">Partition type</span><br><span class="line">   p   primary (1 primary, 0 extended, 3 free)</span><br><span class="line">   e   extended (container for logical partitions)</span><br><span class="line">Select (default p): </span><br></pre></td></tr></table></figure></li><li><p>选择 <code>p</code> 表示创建主分区，或者 <code>e</code> 创建扩展分区（一般选择主分区）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Select (default p): p</span><br><span class="line">Partition number (2-4, default 2): </span><br></pre></td></tr></table></figure></li><li><p>输入分区号（对于新硬盘通常是 <code>1</code>，如果是第一个分区）。</p></li><li><p>输入起始和结束扇区，通常可以直接按回车键接受默认值。我是在结束扇区输入的是<code>+1T</code>，创建的第一个盘是1T大小。</p></li><li><p>完成后，输入 <code>p</code> 查看新分区是否正确。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">多出：</span></span><br><span class="line">Device     Boot Start        End    Sectors Size Id Type</span><br><span class="line">/dev/sda1        4096 2147487743 2147483648   1T 83 Linux</span><br></pre></td></tr></table></figure></li></ol></li><li><p>保存更改</p><p>输入 <code>w</code> 保存并退出 <code>fdisk</code>。</p></li></ol><h1 id="格式化新分区"><a href="#格式化新分区" class="headerlink" title="格式化新分区"></a>格式化新分区</h1><blockquote><p>机械硬盘在 Ubuntu、Windows 和手机上都能使用，建议将硬盘格式化为 <code>exFAT</code> 文件系统，因为 <code>exFAT</code> 是一种跨平台支持较好的文件系统，兼容性较强。</p></blockquote><p>假设创建的分区是 <code>/dev/sda1</code>，使用以下命令格式化为 <code>exFAT</code> 文件系统：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkfs.exfat /dev/sda1</span><br></pre></td></tr></table></figure><blockquote><p>如果显示<code>sudo: mkfs.exfat: command not found</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 exfat 支持工具</span></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install exfat-fuse exfat-utils</span><br></pre></td></tr></table></figure></blockquote><p>成功的显示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo mkfs.exfat /dev/sda1</span><br><span class="line">mkexfatfs 1.3.0</span><br><span class="line">Creating... done.</span><br><span class="line">Flushing... done.</span><br><span class="line">File system created successfully.</span><br></pre></td></tr></table></figure><h1 id="创建挂载点并挂载硬盘"><a href="#创建挂载点并挂载硬盘" class="headerlink" title="创建挂载点并挂载硬盘"></a>创建挂载点并挂载硬盘</h1><h2 id="创建一个挂载点，例如-mnt-mydisk"><a href="#创建一个挂载点，例如-mnt-mydisk" class="headerlink" title="创建一个挂载点，例如 /mnt/mydisk"></a>创建一个挂载点，例如 <code>/mnt/mydisk</code></h2><p>在 <code>/mnt</code> 目录下创建一个名为 <code>mydisk</code> 的文件夹，用于挂载机械硬盘。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> /mnt/mydisk</span></span><br></pre></td></tr></table></figure><h2 id="挂载分区"><a href="#挂载分区" class="headerlink" title="挂载分区"></a>挂载分区</h2><p>将格式化后的分区挂载到创建的挂载点。这样，您就可以通过 <code>/mnt/mydisk</code> 访问硬盘上的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">sudo</span> mount -t exfat /dev/sda1 /mnt/mydisk</span></span><br></pre></td></tr></table></figure><h1 id="验证挂载"><a href="#验证挂载" class="headerlink" title="验证挂载"></a>验证挂载</h1><p>确认硬盘是否挂载成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure><p>列出所有挂载的文件系统，能看到 <code>/mnt/mydisk</code> 的信息。</p><h1 id="设置自动挂载"><a href="#设置自动挂载" class="headerlink" title="设置自动挂载"></a>设置自动挂载</h1><p>如果希望每次启动时自动挂载，可以编辑 <code>/etc/fstab</code> 文件。</p><h2 id="查看硬盘的-UUID（文件系统的唯一标识符）"><a href="#查看硬盘的-UUID（文件系统的唯一标识符）" class="headerlink" title="查看硬盘的 UUID（文件系统的唯一标识符）"></a>查看硬盘的 UUID（文件系统的唯一标识符）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo blkid /dev/sda1</span><br></pre></td></tr></table></figure><p>输出中，类似于 <code>UUID=&quot;XXXX-XXXX&quot;</code> 的部分就是硬盘的 UUID。</p><h2 id="编辑-etc-fstab-文件"><a href="#编辑-etc-fstab-文件" class="headerlink" title="编辑 /etc/fstab 文件"></a>编辑 <code>/etc/fstab</code> 文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/fstab</span><br></pre></td></tr></table></figure><h2 id="添加自动挂载条目"><a href="#添加自动挂载条目" class="headerlink" title="添加自动挂载条目"></a>添加自动挂载条目</h2><p>在文件末尾添加一行（用实际的 UUID 和挂载路径替换）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID=XXXX-XXXX /mnt/mydisk exfat defaults 0 0</span><br></pre></td></tr></table></figure><ul><li><p>挂载路径：/mnt/mydisk</p></li><li><p>文件系统类型：因为您的硬盘是 exFAT，这里填 exfat。</p></li></ul><h2 id="保存并关闭文件"><a href="#保存并关闭文件" class="headerlink" title="保存并关闭文件"></a>保存并关闭文件</h2><p> 保存文件后，关闭编辑器。</p><h2 id="验证设置"><a href="#验证设置" class="headerlink" title="验证设置"></a>验证设置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -a</span><br></pre></td></tr></table></figure><p>如果没有错误信息，说明配置正确。之后每次开机时，系统都会自动挂载硬盘到指定位置。</p><h1 id="设置卷标名字"><a href="#设置卷标名字" class="headerlink" title="设置卷标名字"></a>设置卷标名字</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo exfatlabel /dev/sda1 xxx</span><br></pre></td></tr></table></figure><ul><li><strong><code>sudo</code></strong>：以超级用户权限执行命令，允许您进行系统级的修改。</li><li><strong><code>exfatlabel</code></strong>：这是一个用于管理 <code>exFAT</code> 文件系统卷标的命令。</li><li><strong><code>/dev/sda1</code></strong>：指的是您要操作的具体分区。</li><li><strong><code>xxx</code></strong>：这是您想要设置的新卷标名称。</li></ul><h1 id="卸载硬盘"><a href="#卸载硬盘" class="headerlink" title="卸载硬盘"></a>卸载硬盘</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo umount /mnt/mydisk</span><br></pre></td></tr></table></figure><h1 id="使用GParted进行磁盘分区和挂载"><a href="#使用GParted进行磁盘分区和挂载" class="headerlink" title="使用GParted进行磁盘分区和挂载"></a>使用GParted进行磁盘分区和挂载</h1><p><a href="https://cnblogs.com/whjblog/p/17190455.html">Ubuntu 20.04 使用GParted磁盘分区和挂载 - NavyW - 博客园</a></p><h1 id="检查机械硬盘的健康状态和磁粒（扇区）的好坏情况"><a href="#检查机械硬盘的健康状态和磁粒（扇区）的好坏情况" class="headerlink" title="检查机械硬盘的健康状态和磁粒（扇区）的好坏情况"></a>检查机械硬盘的健康状态和磁粒（扇区）的好坏情况</h1><h2 id="使用-smartctl-工具"><a href="#使用-smartctl-工具" class="headerlink" title="使用 smartctl 工具"></a>使用 <code>smartctl</code> 工具</h2><p><code>smartctl</code> 是 Smartmontools 软件包的一部分，它可以帮助您查看硬盘的 SMART（Self-Monitoring, Analysis and Reporting Technology）状态。</p><h3 id="安装-Smartmontools"><a href="#安装-Smartmontools" class="headerlink" title="安装 Smartmontools"></a>安装 Smartmontools</h3><p>如果尚未安装，可以使用以下命令安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="检查硬盘健康状态"><a href="#检查硬盘健康状态" class="headerlink" title="检查硬盘健康状态"></a>检查硬盘健康状态</h3><p>使用以下命令检查硬盘的总体健康状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo smartctl -H /dev/sdX</span><br></pre></td></tr></table></figure><p>将 <code>/dev/sdX</code> 替换为您的硬盘设备路径（例如 <code>/dev/sda</code>、<code>/dev/sdb</code>）。</p><h3 id="查看详细的-SMART-信息"><a href="#查看详细的-SMART-信息" class="headerlink" title="查看详细的 SMART 信息"></a>查看详细的 SMART 信息</h3><p>要获取详细的 SMART 信息和错误日志，运行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo smartctl -a /dev/sdX</span><br></pre></td></tr></table></figure><p>这将显示硬盘的运行时间、健康状态、错误日志和具体的扇区错误信息。</p><h2 id="使用-badblocks-工具"><a href="#使用-badblocks-工具" class="headerlink" title="使用 badblocks 工具"></a>使用 <code>badblocks</code> 工具</h2><p><code>badblocks</code> 可以扫描硬盘上的坏块或坏扇区。</p><h3 id="扫描硬盘上的坏块"><a href="#扫描硬盘上的坏块" class="headerlink" title="扫描硬盘上的坏块"></a>扫描硬盘上的坏块</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo badblocks -sv /dev/sdX</span><br></pre></td></tr></table></figure><p>此命令将以只读模式扫描硬盘，并在控制台中显示坏块列表。<code>-s</code> 显示进度，<code>-v</code> 提供详细信息。</p><p><strong>注意</strong>：如果需要对硬盘进行写测试，请使用 <code>-w</code> 选项，但这会覆盖数据。确保备份数据后再运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo badblocks -wsv /dev/sdX</span><br></pre></td></tr></table></figure><h2 id="使用-gnome-disk-utility"><a href="#使用-gnome-disk-utility" class="headerlink" title="使用 gnome-disk-utility"></a>使用 <code>gnome-disk-utility</code></h2><p>如果您喜欢图形界面，可以使用 <strong>Disks</strong>（磁盘实用程序）工具：</p><ol><li>打开 Ubuntu Dash，搜索并打开 <strong>Disks</strong>。</li><li>选择要检查的硬盘。</li><li>点击右上角的齿轮图标，选择 <strong>SMART Data &amp; Self-Tests</strong>。</li><li>查看硬盘的健康状况并运行自检测试。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>傅里叶变换</title>
      <link href="/2024/10/31/Math/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
      <url>/2024/10/31/Math/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>膜拜大神：<br><a href="https://zhuanlan.zhihu.com/p/19763358">傅里叶分析之掐死教程（完整版）更新于2014.06.06</a></p></blockquote><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>傅里叶变换是信号处理、图像处理和音频分析等领域的核心工具。其起源可追溯到18世纪，数学家约瑟夫·傅里叶通过研究热传导问题提出了傅里叶分析的概念。傅里叶变换的主要作用是<em>将时域信号转换为频域信号</em>，使我们能够分析和处理信号的频率成分。</p><p>傅里叶变换的数学基础是复数，它将实数信号转换为复数信号，从而将时域信号分解为多个频率分量。在傅里叶变换中，我们使用正弦和余弦函数（“正弦波”（Sine Wave））来表示复数信号，从而将信号分解为多个频率分量。</p><h2 id="傅里叶分析的作用"><a href="#傅里叶分析的作用" class="headerlink" title="傅里叶分析的作用"></a>傅里叶分析的作用</h2><p>无论听广播还是看电视，我们一定对一个词不陌生——频道。频道频道，就是频率的通道，不同的频道就是将不同的频率作为一个通道来进行信息传输。</p><p>滤波：从某条曲线中去除一些特定的频率成分。如：$\sin(3x)+\sin(5)$的图像中取出$\sin(3x)$的部分。</p><p>求解微分方程：傅里叶变换则可以让微分和积分在频域中变为乘法和除法。</p><h2 id="频域"><a href="#频域" class="headerlink" title="频域"></a>频域</h2><p>时域分析：以时间作为参照来观察动态世界的方法。</p><p>“你眼中看似落叶纷飞变化无常的世界，实际只是躺在上帝怀中一份早已谱好的乐章。”</p><p>任何周期函数，都可以看作是不同振幅，不同相位正弦波的叠加。</p><p><em>频域信号</em>展示了信号中包含的不同频率成分及其相应的幅度和相位。</p><h1 id="Taylor级数"><a href="#Taylor级数" class="headerlink" title="Taylor级数"></a>Taylor级数</h1><p>Taylor级数是数学中的重要概念，它描述了函数在某个点处的 Taylor 近似。在傅里叶变换中，我们使用 Taylor 级数来表示函数在某个点$x_0$处的傅里叶级数。通过函数在某一点的导数信息来构建函数的局部近似。</p><script type="math/tex; mode=display">f(x) = \sum_{n=0}^{\infty} \frac{f^{(n)}(x_0)}{n!}(x-x_0)^n \\</script><script type="math/tex; mode=display">= f(x_0) + f'(x_0)(x-x_0) + \frac{f''(x_0)}{2!}(x-x_0)^2 + ...</script><h1 id="三角级数（Fourier级数）"><a href="#三角级数（Fourier级数）" class="headerlink" title="三角级数（Fourier级数）"></a>三角级数（Fourier级数）</h1><h2 id="标准形式"><a href="#标准形式" class="headerlink" title="标准形式"></a>标准形式</h2><p>$f(t)$在$[-\pi, \pi]$是<mark>周期函数</mark>。</p><script type="math/tex; mode=display">f(t) = \frac{a_0}{2} + a_1\cos(0 \cdot t) + a_2\cos(1 \cdot t) + a_3\cos(2 \cdot t) + ...  \\</script><script type="math/tex; mode=display">+ b_1\sin(0 \cdot t) + b_2\sin(1 \cdot t) + b_3\sin(2 \cdot t) + ... \\</script><script type="math/tex; mode=display">= \frac{a_0}{2} + \sum_{n=1}^{\infty} (a_n\cos(n \cdot t) + b_n\sin(n \cdot t))</script><h3 id="三角函数系"><a href="#三角函数系" class="headerlink" title="三角函数系"></a>三角函数系</h3><script type="math/tex; mode=display">\{1, cos(t), sin(t), cos(2t), sin(2t), ...\}</script><p>正交性：</p><script type="math/tex; mode=display">\int_{-\pi}^{\pi} cos(nt)cos(mt)dt = \int_{-\pi}^{\pi} sin(nt)sin(mt)dt = \begin{cases} 0, & n \neq m \\ \pi, & n = m \end{cases}</script><p>三角函数系中任意两个不同的元素之间在$[0, \pi]$的内积为0，所以三角函数系是一个正交系统。(积化和差证明)</p><h3 id="系数求解"><a href="#系数求解" class="headerlink" title="系数求解"></a>系数求解</h3><script type="math/tex; mode=display">\int_{-\pi}^{\pi} f(t) \, dt = \int_{-\pi}^{\pi} \frac{a_0}{2} \, dt => a_0 = \frac{1}{\pi} \int_{-\pi}^{\pi} f(t) \, dt</script><script type="math/tex; mode=display">\int_{-\pi}^{\pi} f(t)cos(nt) \, dt = \int_{-\pi}^{\pi} a_n \cos^2(nx) \, dt => a_n = \frac{1}{\pi} \int_{-\pi}^{\pi} f(t)cos(nt) \, dt</script><script type="math/tex; mode=display">\int_{-\pi}^{\pi} f(t)sin(nt) \, dt = \int_{-\pi}^{\pi} a_n \sin^2(nt) \, dt => b_n = \frac{1}{\pi} \int_{-\pi}^{\pi} f(t)sin(nt) \, dt</script><h3 id="Dirichlet-条件"><a href="#Dirichlet-条件" class="headerlink" title="Dirichlet 条件"></a>Dirichlet 条件</h3><p>$f_T(t)$,$T=2\pi$,在$[-\pi, \pi]$上，满足：</p><p> 1.连续性，或者只有有限个第一类间断点。<br> 2.只有有限个极值点。</p><p>则$f_T(x)$的和函数 $S(x)=\begin{cases} f(x), &amp; 连续点; \ \frac{f(x-0)+f(x+0)}{2}, &amp; 间断点. \end{cases}$</p><p><mark>傅里叶级数，在时域是一个周期且连续的函数，而在频域是一个非周期离散的函数。</mark></p><h2 id="傅里叶级数的频谱（振幅谱）"><a href="#傅里叶级数的频谱（振幅谱）" class="headerlink" title="傅里叶级数的频谱（振幅谱）"></a>傅里叶级数的频谱（振幅谱）</h2><p>矩形波的叠加形成：随着叠加的递增，所有正弦波中上升的部分逐渐让原本缓慢增加的曲线不断变陡，而所有正弦波中下降的部分又抵消了上升到最高处时继续上升的部分使其变为水平线。</p><p>时域的基本单元：1s</p><p>将一个角频率为$w_0$的正弦波$\cos(w_0t)$看作基础，<em>频域的基本单元</em>；$w_0$</p><p>$\cos(0 \cdot t)$就是一个周期无限长的正弦波，也就是一条直线！所以在频域，0频率也被称为<em>直流分量</em>，在傅里叶级数的叠加中，它仅仅影响全部波形相对于数轴整体向上或是向下而不改变波的形状。</p><p>正弦波就是一个圆周运动在一条直线上的投影。所以频域的基本单元也可以理解为一个始终在旋转的圆在1s内转的圈数。</p><p><img src="https://pic2.zhimg.com/40cf849e55ed95732a60b52d4019d609_b.jpg" alt=""></p><p><strong>关于时间的函数是正弦波在时域上的投影，而正弦波又是一个旋转的圆在直线上的投影。</strong></p><h2 id="傅里叶级数的相位谱"><a href="#傅里叶级数的相位谱" class="headerlink" title="傅里叶级数的相位谱"></a>傅里叶级数的相位谱</h2><p>频谱并没有包含时域中全部的信息。<em>频谱只代表每一个对应的正弦波的振幅是多少，而没有提到相位</em>。</p><p>基础的正弦波：$A \cdot \sin(w \cdot t + \theta)$中，振幅，频率，相位缺一不可，不同相位决定了波的位置。</p><p><img src="https://pica.zhimg.com/07199fc0250791d768771b50c098e26a_b.jpg" alt=""></p><p><img src="https://pic4.zhimg.com/e1985fe86283a7b14d1fc7e11d322fcb_1440w.jpg" alt=""></p><p>$相位差 = \frac{时间差}{周期} \cdot 2\pi$</p><p>投影得到的时间差依次除以所在频率的周期，就得到了如下的相位谱：<br><img src="https://pica.zhimg.com/4695ce06197677bab880cd55b6846f12_1440w.jpg" alt=""></p><h2 id="周期为-T-的信号-f-T-t-的傅里叶级数"><a href="#周期为-T-的信号-f-T-t-的傅里叶级数" class="headerlink" title="周期为$T$的信号$f_T(t)$的傅里叶级数"></a>周期为$T$的信号$f_T(t)$的傅里叶级数</h2><script type="math/tex; mode=display">f(t) = f(t+T)</script><script type="math/tex; mode=display">令 x = \frac{t}{T} \cdot 2\pi , t \in [\frac{-T}{2}, \frac{T}{2}]</script><script type="math/tex; mode=display">f(t) = f(\frac{T}{2\pi} \cdot x) = F(x)</script><script type="math/tex; mode=display">F(x) = \frac{a_0}{2} + \sum_{n=1}^{\infty} (a_n\cos(nx) + b_n\sin(nx)) ,</script><p>其中，</p><p>$ a<em>0 = \frac{1}{\pi} \int</em>{-\pi}^{\pi} F(x) \, dx = \frac{2}{T} \int_{-\frac{T}{2}}^{\frac{T}{2}} f(t) \, dt $</p><p>$ a<em>n = \frac{1}{\pi} \int</em>{-\pi}^{\pi} F(x) \cos(nx) \, dx = \frac{2}{T} \int_{-\frac{T}{2}}^{\frac{T}{2}} f(t) \cos(n\frac{2\pi}{T}t) \, dt $</p><p>$ b<em>n = \frac{1}{\pi} \int</em>{-\pi}^{\pi} F(x) \sin(nx) \, dx = \frac{2}{T} \int_{-\frac{T}{2}}^{\frac{T}{2}} f(t) \sin(n\frac{2\pi}{T}t) \, dt $</p><script type="math/tex; mode=display">令 w_0 = \frac{2\pi}{T} 为基本（角）频率</script><script type="math/tex; mode=display">f_T(t) = \frac{a_0}{2} + \sum_{n=1}^{\infty} (a_n\cos(nw_0t) + b_n\sin(nw_0t))</script><p>其中，</p><p>$ a<em>0 = \frac{2}{T} \int</em>{-\frac{T}{2}}^{\frac{T}{2}} f_T(t) \, dt $</p><p>$ a<em>n = \frac{2}{T} \int</em>{-\frac{T}{2}}^{\frac{T}{2}} f_T(t) \cos(nw_0t) \, dt $</p><p>$ b<em>n = \frac{2}{T} \int</em>{-\frac{T}{2}}^{\frac{T}{2}} f_T(t) \sin(nw_0t) \, dt $</p><h2 id="指数形式的傅里叶级数"><a href="#指数形式的傅里叶级数" class="headerlink" title="指数形式的傅里叶级数"></a>指数形式的傅里叶级数</h2><p>因为$\cos(nw_0t) = \frac{e^{jnw_0t}+e^{-jnw_0t}}{2}，\sin(nw_0t) = \frac{e^{jnw_0t}-e^{-jnw_0t}}{2}$，</p><p>所以，</p><script type="math/tex; mode=display">f_T(t) = \frac{a_0}{2} + \sum_{n=1}^{\infty} (a_n\frac{e^{jn\omega _0t}+e^{-jn\omega _0t}}{2} + b_n\frac{e^{jn\omega _0t}-e^{-jn\omega _0t}}{2}) = \frac{a_0}{2} + \sum_{n=1}^{\infty} (\frac{a_n - j \cdot b_n}{2} \cdot e^{jn\omega _0t} + \frac{a_n + j \cdot b_n}{2} \cdot e^{-jn\omega _0t})</script><p>因为$\frac{a<em>n - j \cdot b_n}{2} = \frac{1}{T} \int</em>{-\frac{T}{2}}^{\frac{T}{2}} f_T(t) e^{-jn\omega _0t} \, dt$，</p><p>所以，</p><script type="math/tex; mode=display">f_T(t) = \sum_{n=-\infty}^{\infty} \frac{1}{T} \int_{-\frac{T}{2}}^{\frac{T}{2}} f_T(t) e^{-jn\omega _0t} \, dt \cdot e^{-jn\omega _0t}</script><p>其中，</p><p>$\omega _0 = \frac{2\pi}{T}$为基本（角）频率；</p><p>$n$为谐波的编号，表示的是第 $n$ 个正弦波函数的频率分量，用来叠加各个频率分量；</p><p>$C<em>n=\frac{1}{T} \int</em>{-\frac{T}{2}}^{\frac{T}{2}} f_T(t) e^{-jn\omega _0t} \, dt$为傅里叶系数，第 $n$ 个正弦波函数的能量，用来表示第 $n$ 个正弦波函数的振幅。</p><h1 id="傅里叶变换（Fourier-Transformation）"><a href="#傅里叶变换（Fourier-Transformation）" class="headerlink" title="傅里叶变换（Fourier Transformation）"></a>傅里叶变换（Fourier Transformation）</h1><p><mark>傅里叶级数的本质是将一个周期的信号分解成无限多分开的（离散的）正弦波</mark>，但是宇宙似乎并不是周期的。</p><p>傅里叶级数，在时域是一个周期且连续的函数，而在频域是一个离散非周期的函数。</p><p><img src="https://pic3.zhimg.com/419cd0b2e965aca25d5f8a5a6362d728_1440w.jpg" alt=""></p><h2 id="欧拉公式"><a href="#欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式</h2><h3 id="虚数i"><a href="#虚数i" class="headerlink" title="虚数i"></a>虚数i</h3><p><img src="https://pic3.zhimg.com/42e1f6dc43e8868b4962f5ba389a5df4_1440w.jpg" alt=""></p><p>在数轴上有一个红色的线段，它的长度是1。当它乘以3的时候，它的长度发生了变化，变成了蓝色的线段，而当它乘以-1的时候，就变成了绿色的线段，或者说线段在数轴上围绕原点旋转了180度。</p><script type="math/tex; mode=display">i^2 = -1</script><p>乘-1其实就是乘了两次 i使线段旋转了180度，那么乘一次 i 呢——答案很简单——旋转了90度。所以，<strong>i就是旋转90度的单位</strong>。</p><p><img src="https://pic3.zhimg.com/3e88e9463e4667e50ebdda51dee88358_1440w.jpg" alt=""></p><p><strong>实数轴与虚数轴共同构成了一个复数的平面，也称复平面。这样我们就了解到，乘虚数i的一个功能——旋转。</strong></p><p><a href="https://www.zhihu.com/question/23234701/answer/26017000">复数的物理意义是什么</a></p><h3 id="欧拉公式-1"><a href="#欧拉公式-1" class="headerlink" title="欧拉公式"></a>欧拉公式</h3><script type="math/tex; mode=display">e^{i\theta} = cos(\theta) + i\cdot sin(\theta)</script><script type="math/tex; mode=display">e^{i\pi} + 1 = 0</script><p><img src="https://pic2.zhimg.com/974efc6a99e06dcd623193e960ccbe93_1440w.jpg" alt=""><br>在复平面上做圆周运动的点，随着时间的改变，在时间轴上就成了一条螺旋线。如果只看它的实数部分，也就是螺旋线在左侧的投影，就是一个最基础的余弦函数。而右侧的投影则是一个正弦函数。</p><h2 id="指数形式的傅里叶变换"><a href="#指数形式的傅里叶变换" class="headerlink" title="指数形式的傅里叶变换"></a>指数形式的傅里叶变换</h2><p>傅里叶变换出来的频谱是频率从0到无穷所有频率的正弦波的组合。</p><p><em>正弦波</em>：</p><ul><li><p>螺旋线在实数空间的投影。</p></li><li><p>$ \cos(t) = \frac{e^{it} + e^{-it}}{2} $</p><p>$ e^{i \cdot t} $是一条逆时针旋转的螺旋线，$e^{- i \cdot t}$ 是一条顺时针旋转的螺旋线。而$\cos(t)$是两条旋转方向不同的螺旋线叠加的一半，因为这两条螺旋线的虚数部分相互抵消掉了。</p></li></ul><p>逆时针旋转的称为正频率，而顺时针旋转的称为负频率。</p><h2 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h2><script type="math/tex; mode=display">f_T(t) = \sum_{n=-\infty}^{\infty} \frac{1}{T} \int_{-\frac{T}{2}}^{\frac{T}{2}} f_T(t) e^{-jn\omega _0t} \, dt \cdot e^{-jn \omega _0t}，T \rightarrow +\infty</script><script type="math/tex; mode=display">令\Delta \omega = \frac{2\pi}{T} = \omega _0 ，\omega = n \cdot \omega _0</script><script type="math/tex; mode=display">f(t) = \lim_{\Delta \omega \rightarrow 0} \frac{1}{2\pi} \int_{-\infty}^{+\infty} f(t) e^{-j\omega t} \, dt \cdot e^{-j\omega t} \cdot \Delta \omega</script><script type="math/tex; mode=display">= \frac{1}{2\pi} \int_{-\infty}^{+\infty} \int_{-\infty}^{+\infty} f(t) e^{-j\omega t} \, dt \cdot e^{-j\omega t} \cdot d\omega</script><p>所以，<br>非周期信号$f(t)$的傅里叶变换公式为：</p><script type="math/tex; mode=display">F(\omega) = \frac{1}{2\pi} \int_{-\infty}^{+\infty} f(t) e^{-j\omega t} \, dt</script><script type="math/tex; mode=display">f(t) = \frac{1}{2\pi} \int_{-\infty}^{+\infty} F(\omega) e^{j\omega t} \, d\omega</script><p>$F(\omega)$为信号在频率上的表现，展示了信号中包含的不同频率成分及其相应的幅度和相位。</p><h2 id="频域特性"><a href="#频域特性" class="headerlink" title="频域特性"></a>频域特性</h2><ul><li><p>频率分量：频域表示了信号中不同频率成分的强度。例如，音频信号的频域分析可以揭示音调的特性。</p></li><li><p>幅度和相位：频域信号不仅包括频率成分的幅度信息，还包含相位信息，这对信号的重构至关重要。</p></li><li><p>滤波：在频域中，可以方便地设计和实现滤波器，通过选择特定频率的成分来实现低通、高通、带通等滤波效果。</p></li></ul><h2 id="傅里叶变换的性质"><a href="#傅里叶变换的性质" class="headerlink" title="傅里叶变换的性质"></a>傅里叶变换的性质</h2><h3 id="线性性"><a href="#线性性" class="headerlink" title="线性性"></a>线性性</h3><p>如果有两个信号 $f(t)$ 和 $g(t)$ 及其傅里叶变换分别为 $F(\omega)$ 和 $G(\omega)$，则对于任意常数 $a$ 和 $b$：</p><script type="math/tex; mode=display">\mathcal{F}\{a f(t) + b g(t)\} = a F(\omega) + b G(\omega)</script><p>这表明傅里叶变换是线性的。</p><h3 id="平移性质"><a href="#平移性质" class="headerlink" title="平移性质"></a>平移性质</h3><h4 id="时间平移"><a href="#时间平移" class="headerlink" title="时间平移"></a>时间平移</h4><p>如果 $ f(t) $ 的傅里叶变换为 $ F(\omega) $，则时间平移 $ f(t - t_0) $ 的傅里叶变换为：</p><script type="math/tex; mode=display">\mathcal{F}\{f(t - t_0)\} = F(\omega) e^{-j\omega t_0}</script><h4 id="频率平移"><a href="#频率平移" class="headerlink" title="频率平移"></a>频率平移</h4><p>如果 $ f(t) $ 的傅里叶变换为 $ F(\omega) $，则频率平移 $ e^{j\omega_0 t} f(t) $ 的傅里叶变换为：</p><script type="math/tex; mode=display">\mathcal{F}\{e^{j\omega_0 t} f(t)\} = F(\omega - \omega_0)</script><h3 id="时间缩放"><a href="#时间缩放" class="headerlink" title="时间缩放"></a>时间缩放</h3><p>如果 $ f(t) $ 的傅里叶变换为 $ F(\omega) $，则缩放 $ f(at) $ 的傅里叶变换为：</p><script type="math/tex; mode=display">\mathcal{F}\{f(at)\} = \frac{1}{|a|} F\left(\frac{\omega}{a}\right)</script><p>其中 ( a ) 是一个实数。时间压缩会导致频域的扩展，反之亦然。</p><h3 id="共轭性质"><a href="#共轭性质" class="headerlink" title="共轭性质"></a>共轭性质</h3><p>如果 $ f(t) $ 的傅里叶变换为 $ F(\omega) $，则其共轭 $ f^*(t) $ 的傅里叶变换为：</p><script type="math/tex; mode=display">\mathcal{F}\{f^*(t)\} = F^*(-\omega)</script><h3 id="傅里叶变换的卷积定理"><a href="#傅里叶变换的卷积定理" class="headerlink" title="傅里叶变换的卷积定理"></a>傅里叶变换的卷积定理</h3><p>如果 $ f(t) $ 和 $ g(t) $ 的傅里叶变换分别为 $ F(\omega) $ 和 $ G(\omega) $，则它们的卷积 $ f(t) * g(t) $ 的傅里叶变换为：</p><script type="math/tex; mode=display">\mathcal{F}\{f(t) * g(t)\} = F(\omega) \cdot G(\omega)</script><p>反之亦然，乘积 $ f(t) \cdot g(t) $ 的傅里叶变换为：</p><script type="math/tex; mode=display">\mathcal{F}\{f(t) \cdot g(t)\} = \frac{1}{2\pi} F(\omega) * G(\omega)</script><h3 id="导数性质"><a href="#导数性质" class="headerlink" title="导数性质"></a>导数性质</h3><p>如果 $ f(t) $ 的傅里叶变换为 $ F(\omega) $，则其导数 $ \frac{d}{dt} f(t) $ 的傅里叶变换为：</p><script type="math/tex; mode=display">\mathcal{F}\left\{\frac{d}{dt} f(t)\right\} = j\omega F(\omega)</script><p>一般情况下，第 $ n $ 阶导数 $ \frac{d^n}{dt^n} f(t) $ 的傅里叶变换为：</p><script type="math/tex; mode=display">\mathcal{F}\left\{\frac{d^n}{dt^n} f(t)\right\} = (j\omega)^n F(\omega)</script><h3 id="傅里叶变换的对称性"><a href="#傅里叶变换的对称性" class="headerlink" title="傅里叶变换的对称性"></a>傅里叶变换的对称性</h3><p>对于实值函数 $ f(t) $，其傅里叶变换 $ F(\omega) $ 满足共轭对称性：</p><script type="math/tex; mode=display">F(-\omega) = F^*(\omega)</script><p>这意味着频谱的实部是偶函数，而虚部是奇函数。</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 傅里叶变换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二、图像变换</title>
      <link href="/2024/10/31/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%BA%8C%E3%80%81%E5%9B%BE%E5%83%8F%E5%8F%98%E6%8D%A2/"/>
      <url>/2024/10/31/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%BA%8C%E3%80%81%E5%9B%BE%E5%83%8F%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>什么是变换？</p><p>信号变换的本质：空间变换。透过不同角度去更简洁观察和认识信号。将信号放到不同空间观察，如傅里叶变换。</p><p>什么是图像变换？</p><p>通过一定规则将图像由一个空间（空间域）转变到另一个空间（空间域或频率域）</p><h1 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h1><p>几何变换：用数学建模的方法描述图像位置、大小、形状等变化。</p><h2 id="平移变换"><a href="#平移变换" class="headerlink" title="平移变换"></a>平移变换</h2><p>定义：将图像整体移动到新位置。</p><script type="math/tex; mode=display">(x', y') = (x + t_x, y + t_y)</script><script type="math/tex; mode=display">\begin{bmatrix} x' \\ y' \end{bmatrix} = \begin{bmatrix} 1 & 0 & t_x \\ 0 & 1 & t_y \\ 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} x \\ y \\ 1 \end{bmatrix}</script><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>定义：指定角度旋转图像</p><script type="math/tex; mode=display">\begin{align*}x' &= x \cdot \cos(\theta) - y \cdot \sin(\theta) \\y' &= x \cdot \sin(\theta) + y \cdot \cos(\theta)\end{align*}</script><script type="math/tex; mode=display">\begin{bmatrix}  x' \\  y'  \end{bmatrix}  =  \begin{bmatrix}  \cos(\theta) & -\sin(\theta) & 0 \\  \sin(\theta) & \cos(\theta) & 0 \\  0 & 0 & 1  \end{bmatrix}  \begin{bmatrix}  x \\  y \\  1  \end{bmatrix}</script><ul><li>用于校正图像方向或创建旋转效果。</li></ul><h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p>定义：增大或缩小图像的尺寸。</p><script type="math/tex; mode=display">(x', y') = (sx \cdot x, sy \cdot y)</script><script type="math/tex; mode=display">\begin{bmatrix}  x' \\  y'  \end{bmatrix}  =  \begin{bmatrix}  s_x & 0 & 0 \\  0 & s_y & 0 \\  0 & 0 & 1  \end{bmatrix}  \begin{bmatrix}  x \\  y \\  1  \end{bmatrix}</script><h2 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h2><p>定义：一种二维坐标到二维坐标间的线性变换，允许同时进行平移、旋转和缩放。可保持二维图形的平直性和平行性。</p><script type="math/tex; mode=display">\begin{bmatrix}  x' \\  y' \\  1  \end{bmatrix}  =  \begin{bmatrix}  a & b & t_x \\  c & d & t_y \\  0 & 0 & 1  \end{bmatrix}  \begin{bmatrix}  x \\  y \\  1  \end{bmatrix}</script><p>缩放因子：a、d</p><p>旋转因子：b、c</p><p>平移因子：$t_x$、$t_y$</p><p>仿射变换矩阵有6个参数，因此6个自由度。</p><ul><li><p>直线保持性：保持直线和平行关系</p></li><li><p>顶点保持：变换的过程是将每个顶点的坐标进行矩阵运算，而不是改变顶点的数量。</p></li><li><p>在变换过程中，三角形的形状可能发生了变化（如缩放、旋转或倾斜），它仍然保持三角形的结构。</p></li></ul><h2 id="透视变换"><a href="#透视变换" class="headerlink" title="透视变换"></a>透视变换</h2><p>定义：一种平面映射</p><script type="math/tex; mode=display">P'_h = M \cdot P_h = \begin{bmatrix}x' \\y' \\w'\end{bmatrix}=\begin{bmatrix}m_{11} + m_{12} + m_{13} \\m_{21} + m_{22} + m_{23} \\m_{31} + m_{32} + m_{33}\end{bmatrix}\begin{bmatrix}  x \\  y \\  1  \end{bmatrix}\\=\begin{bmatrix}m_{11} \cdot x + m_{12} \cdot y + m_{13} \\m_{21} \cdot x + m_{22} \cdot y + m_{23} \\m_{31} \cdot x + m_{32} \cdot y + m_{33}\end{bmatrix}</script><ol><li><p>平移参数</p><p>$m_{13}$：在 x 方向的平移</p><p>$m_{23}$：在 y 方向的平移</p></li><li><p>旋转和缩放参数</p><p>$m_{11}$:影响 x 轴方向的缩放和旋转</p><p>$m_{12}$:影响 x 轴与 y 轴之间的角度</p><p>$m_{21}$:影响 y 轴方向的缩放和旋转</p><p>$m_{22}$:影响 y 轴的缩放</p></li><li><p>投影和深度参数</p><p>$m<em>{31}$、$m</em>{32}$:控制深度和透视效果</p><p>$m_{33}$:通常用于齐次坐标的归一化（可设为1）</p></li></ol><p>在透视变换中，所有9个参数并不都是独立的，因为我们通常假设图像的齐次坐标形式（使用一个额外的维度来处理平移和缩放），$m_{33}$由其他8个参数算出。</p><h1 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h1><p>几何变换后，可能会出现空白像素，插值用于计算这些像素的值。</p><ul><li><p>最近邻插值: 选择最近的像素值，简单但可能产生锯齿。</p></li><li><p>双线性插值: 使用周围四个像素的加权平均，效果更好。</p></li><li><p>立方插值: 使用更复杂的算法，提供更平滑的结果。</p></li><li><p>样条插值：使用低阶多项式（如三次样条）在每对数据点之间进行插值。</p><ul><li><p>优点：在图像变换时提供高平滑性和良好的保边效果。</p></li><li><p>缺点：实现较复杂，计算量大。</p></li></ul></li><li><p>卷积插值：将卷积核与信号或图像进行卷积，以生成插值结果。</p></li></ul><p>具体步骤如下：</p><ol><li>将卷积核放置在信号的每个数据点上。</li><li>计算卷积，得到插值后的数据点。</li></ol><p>优点</p><ul><li><strong>平滑效果好</strong>：通过卷积核，能够有效地平滑数据，减少噪声。</li><li><strong>灵活性</strong>：可以根据需求选择不同的卷积核，适应不同的应用场景。</li></ul><p>缺点</p><ul><li><strong>计算复杂度高</strong>：卷积操作可能比简单插值方法（如线性或最近邻插值）计算量大。</li><li><strong>边缘效应</strong>：在图像处理中，可能会在边缘部分产生模糊或不连续现象。</li></ul><h1 id="图像的离散傅里叶变换"><a href="#图像的离散傅里叶变换" class="headerlink" title="图像的离散傅里叶变换"></a>图像的离散傅里叶变换</h1><h2 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h2><p>傅里叶变换是一种将信号从时间域（或空间域）转换到频域的数学工具。</p><ul><li><p>周期信号—-&gt;傅里叶级数</p><p>将周期函数表示为一系列正弦和余弦函数（即三角函数）的线性组合</p><script type="math/tex; mode=display">f(x) = a_0 + \sum_{n=1}^{\infty} \left( a_n \cos\frac{2\pi nx}{T} + b_n \sin\frac{2\pi nx}{T} \right)  \\\\</script><script type="math/tex; mode=display">常数项(直流分量)  a_0 = \frac{1}{T} \int_{x_0}^{x_0 + T} f(x) \, dx</script><script type="math/tex; mode=display">余弦系数 a_n = \frac{2}{T} \int_{x_0}^{x_0 + T} f(x) \cos \frac{2\pi nx}{T} \, dx</script><script type="math/tex; mode=display">正弦系数 b_n = \frac{2}{T} \int_{x_0}^{x_0 + T} f(x) \sin\frac{2\pi nx}{T} \, dx</script><p>傅里叶级数主要用于信号处理、振动分析、声学、电机控制、图像处理等领域。它能将复杂的周期信号分解为一系列简化的正弦和余弦成分，方便分析不同频率成分对信号的贡献。</p></li><li><p>非周期信号——&gt;傅里叶变换</p><script type="math/tex; mode=display">F(\omega) = \int_{-\infty}^{\infty} f(t) e^{-j \omega t} dt</script></li></ul><h2 id="一维离散傅里叶变换"><a href="#一维离散傅里叶变换" class="headerlink" title="一维离散傅里叶变换"></a>一维离散傅里叶变换</h2><h3 id="1D-DFT"><a href="#1D-DFT" class="headerlink" title="1D-DFT"></a>1D-DFT</h3><p>一维离散傅里叶变换将离散有限长信号 $f<a href="n = 0, 1, \ldots, N-1">n</a>$ 转换为其频域表示$F[k]$</p><script type="math/tex; mode=display">F[k] = \sum_{n=0}^{N-1} f[n] e^{-j \frac{2\pi}{N} kn} \\ = \sum_{n=0}^{N-1} f(n) W_N^{nk} \\</script><script type="math/tex; mode=display">旋转因子 W_N = e^{-j \frac{2\pi}{N}}</script><p>复数旋转因子$W_N^{nk} = e^{-j \frac{2\pi}{N} nk}$：</p><ul><li><strong>旋转因子</strong>：$W_N^{nk}$表示在复平面上，因子$W_N$的 $nk$ 次幂，给出了<mark>频率成分 k对时间点 n 的旋转</mark>。这种旋转是进行频域分析的基础。 </li><li><strong>频域信息</strong>：通过对$f(n)$ 进行 DFT，可以得到信号的频率成分，$F(k)$ 提供了信号在频域上的表现。</li></ul><h3 id="DFT-的归一化"><a href="#DFT-的归一化" class="headerlink" title="DFT 的归一化"></a>DFT 的归一化</h3><p>通常在 DFT 的公式中，我们会看到一个归一化因子$\frac{1}{\sqrt{N}}$，具体形式为：</p><p>$F(k) = \frac{1}{\sqrt{N}} \sum_{n=0}^{N-1} f(n) W_N^{nk}$</p><p>原因:</p><ul><li><strong>幅度的均衡</strong>：使用归一化因子可以使得 DFT 的幅度在频域上得到均衡，这样在进行逆变换时，幅度的恢复更加简单和直观。</li><li><strong>与逆变换一致</strong>：在逆离散傅里叶变换（IDFT）中，通常会有一个 $\sqrt{N}$ 的因子，以确保变换的一致性。通过在 DFT 中引入 $\frac{1}{\sqrt{N}}$，可以使得反变换的形式与变换的形式一致。</li></ul><h3 id="1D-IDFT"><a href="#1D-IDFT" class="headerlink" title="1D-IDFT"></a>1D-IDFT</h3><p>一维逆离散傅里叶变换用于从频域恢复到时域</p><script type="math/tex; mode=display">f[n] = \frac{1}{N} \sum_{k=0}^{N-1} F[k] e^{j \frac{2\pi}{N} kn} \\= \frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} F(k) W_N^{-nk},F(k)归一化后 \\</script><p>复数旋转因子$W_N^{nk} = e^{-j \frac{2\pi}{N} nk}$的负次幂：</p><ul><li><strong>相位反转</strong>：在 IDFT 中使用 $W_N^{-nk}$ 是因为需要将频域信号的相位反转，以恢复原始的时域信息。</li><li><strong>复平面旋转方向</strong>：在 DFT 中，我们用 $W_N^{nk} = e^{-j \frac{2\pi}{N} nk}$ 进行正向变换，而 IDFT 使用 $W_N^{-nk} = e^{j \frac{2\pi}{N} nk}$ 进行逆向旋转，恢复原始信号。</li></ul><h3 id="矩阵形式"><a href="#矩阵形式" class="headerlink" title="矩阵形式"></a>矩阵形式</h3><p>DFT矩阵$U$(变换矩阵)是$N \times N$方阵：</p><script type="math/tex; mode=display">U = \begin{bmatrix}1 & 1 & 1 & \cdots & 1 \\1 & W_N & W_N^2 & \cdots & W_N^{N-1} \\1 & W_N^2 & W_N^4 & \cdots & W_N^{2(N-1)} \\\vdots & \vdots & \vdots & \ddots & \vdots \\1 & W_N^{N-1} & W_N^{2(N-1)} & \cdots & W_N^{(N-1)(N-1)}\end{bmatrix}</script><script type="math/tex; mode=display">f = \begin{bmatrix}f(0) & f(1) & f(2) & \dots & f(N-1)\end{bmatrix}^T \\F = U \cdot f \\= \begin{bmatrix}F(0) \\F(1) \\F(2) \\\vdots \\F(N-1)\end{bmatrix} \\= \begin{bmatrix}1 & 1 & 1 & \cdots & 1 \\1 & W_N & W_N^2 & \cdots & W_N^{N-1} \\1 & W_N^2 & W_N^4 & \cdots & W_N^{2(N-1)} \\\vdots & \vdots & \vdots & \ddots & \vdots \\1 & W_N^{N-1} & W_N^{2(N-1)} & \cdots & W_N^{(N-1)(N-1)}\end{bmatrix} \cdot \begin{bmatrix}f(0) \\f(1) \\f(2) \\\vdots \\f(N-1)\end{bmatrix}</script><p>我们可以将 DFT 看作一个线性变换，其中矩阵 $U$ 将时域信号 $f$ 转换到频域信号 $F$。</p><h4 id="变换矩阵U"><a href="#变换矩阵U" class="headerlink" title="变换矩阵U"></a>变换矩阵U</h4><ul><li><p>正交性</p><p>行和列是正交的,所以1D-DFT也称为正交变换</p></li><li><p>单位性</p><p>$U U^T = U^T U = I$</p></li><li><p>可逆性</p><p>$U^{-1} = U^T \cdot N$</p></li></ul><h2 id="二维离散傅里叶变换"><a href="#二维离散傅里叶变换" class="headerlink" title="二维离散傅里叶变换"></a>二维离散傅里叶变换</h2><p>二维离散傅里叶变换（2D-DFT）用于对二维信号（如图像）进行频域分析。</p><h3 id="2D-DFT"><a href="#2D-DFT" class="headerlink" title="2D-DFT"></a>2D-DFT</h3><p>对于一个 $M \times N$ 的二维信号 $f(m, n)( m = 0, 1, \ldots, M-1 ),( n = 0, 1, \ldots, N-1 )$，其二维离散傅里叶变换 $F(k, l)$ 定义为：</p><script type="math/tex; mode=display">F[k, l] = \sum_{m=0}^{M-1} \sum_{n=0}^{N-1} f(m, n) W_{M}^{mk} W_{N}^{nl} ,\\W_{M} = e^{-j \frac{2\pi}{M}}, \\W_{N} = e^{-j \frac{2\pi}{N}}, \\k = 0, 1, \ldots, M-1, \\l = 0, 1, \ldots, N-1.</script><p>归一化后：</p><script type="math/tex; mode=display">F(k, l) = \frac{1}{\sqrt{MN}} \sum_{m=0}^{M-1} \sum_{n=0}^{N-1} f(m, n) W_{M}^{mk} W_{N}^{nl}</script><h3 id="表示形式"><a href="#表示形式" class="headerlink" title="表示形式"></a>表示形式</h3><ol><li><p>矩阵形式</p><p>$F = U_M \cdot f \cdot U_N^T \<br>$</p><p>$F$ 是频域表示的矩阵。<br>$f$ 是时域信号的矩阵 $M \times N$ 。<br>$U_M$ 是 $M \times M$ 的 DFT 矩阵。<br>$U_N$ 是 $N \times N$ 的 DFT 矩阵。</p></li><li><p>复数形式</p><script type="math/tex; mode=display">F(k, l) = \frac{1}{\sqrt{MN}} \sum_{m=0}^{M-1} \sum_{n=0}^{N-1} f(m, n) W_{M}^{mk} W_{N}^{nl} \\= R(k, l) + jI(k, l)</script></li><li><p>指数形式</p><script type="math/tex; mode=display">F(k, l) = \frac{1}{\sqrt{MN}} \sum_{m=0}^{M-1} \sum_{n=0}^{N-1} f(m, n) e^{-j \left( \frac{2\pi}{M} mk + \frac{2\pi}{N} nl \right)} \\= |F(k, l)| \cdot e^{j \cdot \phi(k, l)}</script><ul><li><p>频谱：</p><p>$|F(k, l)| = \sqrt{R^2 + I^2}$</p></li><li><p>相位：</p><p>$\phi(k, l) = \tan^{-1} \left( \frac{I}{R} \right)$</p></li><li><p>功率谱：</p><p>$P(k, l) = |F(k, l)|^2$</p></li></ul></li></ol><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><h4 id="变换核的可分离性"><a href="#变换核的可分离性" class="headerlink" title="变换核的可分离性"></a>变换核的可分离性</h4><p>变换核：$e^{-j \left( \frac{2\pi}{M} mk + \frac{2\pi}{N} nl \right)}$</p><p>2D-DFT 的变换核可分离性意味着可以将 2D-DFT 变换分解为两个独立的 1D-DFT 变换:</p><ol><li><p><strong>行方向的 1D-DFT</strong>：对每一行进行一维 DFT。</p></li><li><p><strong>列方向的 1D-DFT</strong>：对每一列进行一维 DFT。</p></li></ol><script type="math/tex; mode=display">F(k, l) = \frac{1}{\sqrt{M}} \sum_{m=0}^{M-1} \left(\frac{1}{\sqrt{N}} \sum_{n=0}^{N-1} f(m, n) e^{-j \frac{2\pi}{N} nl} \right) e^{-j \frac{2\pi}{M} mk}</script><p><em>优点</em>：</p><ul><li><strong>减少计算复杂度</strong>：直接计算 2D-DFT 的计算复杂度是 $O(M^2 N^2)$，但利用可分离性可以将计算复杂度降至 $O(MN \cdot (\log M + \log N))$。</li></ul><h4 id="移位特性"><a href="#移位特性" class="headerlink" title="移位特性"></a>移位特性</h4><p>空间域中信号的平移会影响频谱的相位，但不会改变幅度。</p><ul><li><p>空间移位：</p><script type="math/tex; mode=display">f(x-x_0, y-y_0) {<->} F(k, l)W_{M}^{x_0k} W_{N}^{y_0l}</script></li><li><p>频域移位：</p><script type="math/tex; mode=display">f(x, y) W_{M}^{-xk_0} W_{N}^{-yl_0} {<->} F(k-k_0, l-l_0)</script></li></ul><h4 id="频谱中心化"><a href="#频谱中心化" class="headerlink" title="频谱中心化"></a>频谱中心化</h4><p>将频率的零点移动到图像中心，以便更容易分析低频和高频信息。</p><script type="math/tex; mode=display">f(x, y) \cdot (-1)^{M/2+N/2} <-> F(k-N/2, l-M/2)</script><p><img src="/images/图像处理/2.png" alt=""></p><p><mark>频谱中心化后，低频成分位于图像的中心，高频成分在图像的边缘。</mark></p><h4 id="旋转不变性"><a href="#旋转不变性" class="headerlink" title="旋转不变性"></a>旋转不变性</h4><p>当图像在空间域中旋转时，其频谱会对应地旋转相同的角度，但幅度保持不变。这意味着傅里叶变换对旋转具有不变性，常用于分析旋转不变特征。</p><p><img src="/images/图像处理/3.png" alt=""></p><h4 id="卷积定理"><a href="#卷积定理" class="headerlink" title="卷积定理"></a>卷积定理</h4><ul><li><p>空间域中的卷积对应于频域中的乘积：</p><script type="math/tex; mode=display">f(x, y) * h(x, y) <=>  F(k, l) \cdot H(k, l)</script></li><li><p>频域中的卷积对应于空间域中的乘积：</p><script type="math/tex; mode=display">f(x, y) \cdot h(x, y) <=> F(k, l) * H(k, l)</script></li></ul><h4 id="周期性"><a href="#周期性" class="headerlink" title="周期性"></a>周期性</h4><p>2D-DFT 具有周期性，即频谱在两个维度上是周期的。对于大小为 $M \times N$ 的图像，频谱在两个维度上均以 $M$ 和 $N$ 为周期重复。</p><h4 id="共轭对称性"><a href="#共轭对称性" class="headerlink" title="共轭对称性"></a>共轭对称性</h4><p>对于实值的输入图像，其二维傅里叶变换具有共轭对称性：</p><script type="math/tex; mode=display">F(k, l) = F^*(-k, -l)</script><p>这意味着频谱中心对称点上的值是复共轭关系。共轭对称性可用于简化频谱计算。</p><h3 id="数字图像的平均值"><a href="#数字图像的平均值" class="headerlink" title="数字图像的平均值"></a>数字图像的平均值</h3><p>图像的平均值（或称为灰度均值）是图像亮度的一个整体度量，用于衡量图像像素值的平均亮度。计算图像的平均值可以帮助我们了解图像的整体光照情况、对比度以及是否存在偏暗或过亮的情况。</p><script type="math/tex; mode=display">\bar{f} = \frac{1}{M \times N} \sum_{x=0}^{M-1} \sum_{y=0}^{N-1} f(x, y) \\= \frac{1}{\sqrt{MN}}F(0,0)</script><p>M 是图像的行数（高度）。 N  是图像的列数（宽度）。</p><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><ul><li><strong>亮度分析</strong>：通过平均值可以判断图像是否偏亮或偏暗。如果平均值接近 255，图像偏亮；接近 0 则图像偏暗。 </li><li><strong>图像对比度调整</strong>：调整图像亮度时可以使用平均值作为基准。 </li><li><strong>图像处理</strong>：图像平均值用于直方图均衡化、图像分割和滤波等操作中。</li></ul><h2 id="DFT缺点"><a href="#DFT缺点" class="headerlink" title="DFT缺点"></a>DFT缺点</h2><ul><li><strong>复数运算复杂度高</strong>：DFT 会产生复数频谱，而实际图像多为实数值，这导致计算复杂度增加。 </li><li><strong>边界效应</strong>：在 DFT 中，信号在区间边界处是周期性的，导致边界之间的频率特性可能不真实。</li><li><strong>能量集中</strong>：DFT的能量分布不够集中，而在图像中，重要信息往往集中在低频区域。</li></ul><h1 id="图像的离散余弦变换-Discrete-Cosine-Transform-DCT"><a href="#图像的离散余弦变换-Discrete-Cosine-Transform-DCT" class="headerlink" title="图像的离散余弦变换(Discrete Cosine Transform, DCT)"></a>图像的离散余弦变换(Discrete Cosine Transform, DCT)</h1><p>DFT是复数运算，运算量大，不便实时处理。$F(k, l)= R(k, l) + jI(k, l)$,对函数进行构造使其变成偶函数，偶函数的2D-DFT仅含实部（余弦项），即DCT。</p><p>离散余弦变换（DCT）是一种广泛应用于图像处理和压缩的变换，特别是在 JPEG 图像压缩标准中。DCT 通过将图像从空间域转换到频域，帮助减少冗余信息，从而提高压缩效率。</p><h2 id="1D-DCT"><a href="#1D-DCT" class="headerlink" title="1D-DCT"></a>1D-DCT</h2><p>对于长度为 $N$ 的实数序列 $f(n)$，</p><script type="math/tex; mode=display">F(k) = \alpha(k) \sum_{n=0}^{N-1} f(n) \cos \left( \frac{\pi (2n+1) k}{2N} \right) \\k = 0, 1, \dots, N-1 \\\alpha(k) = \begin{cases}\sqrt{\frac{1}{N}}, & k = 0 \\\sqrt{\frac{2}{N}}, & k \neq 0\end{cases}</script><p>归一化系数：$\alpha(k)$，</p><p>变换核：$\cos \left( \frac{\pi (2n+1) k}{2N} \right)$</p><p>将输入信号 $f(n)$ 转换为频域信号 $F(k)$。其中低频成分集中在前面，高频成分位于后面，这有助于压缩过程中将高频部分截断或量化处理。</p><h2 id="二维离散余弦变换"><a href="#二维离散余弦变换" class="headerlink" title="二维离散余弦变换"></a>二维离散余弦变换</h2><h3 id="2D-DCT"><a href="#2D-DCT" class="headerlink" title="2D-DCT"></a>2D-DCT</h3><p>对于大小为 $M \times N$ 的图像 $f(x, y)$，</p><script type="math/tex; mode=display">F(u, v) = \alpha(u) \alpha(v) \sum_{x=0}^{M-1} \sum_{y=0}^{N-1} f(x, y) \cos \left( \frac{\pi (2x+1) u}{2M} \right) \cos \left( \frac{\pi (2y+1) v}{2N} \right) \\u = 0, 1, \dots, M-1 \\v = 0, 1, \dots, N-1 \\\alpha(u) = \begin{cases}\sqrt{\frac{1}{M}}, & u = 0 \\\sqrt{\frac{2}{M}}, & u \neq 0\end{cases} \\\alpha(v) = \begin{cases}\sqrt{\frac{1}{N}}, & v = 0 \\\sqrt{\frac{2}{N}}, & v \neq 0\end{cases}</script><p>归一化系数：$\alpha(u)$，$\alpha(v)$</p><p>低频成分集中在左上角，而高频成分集中在右下角。</p><h3 id="2D-IDCT"><a href="#2D-IDCT" class="headerlink" title="2D-IDCT"></a>2D-IDCT</h3><script type="math/tex; mode=display">f(x, y) = \frac{1}{4} \sum_{k=0}^{M-1} \sum_{l=0}^{N-1} F(u, v) \cos\left(\frac{\pi}{M} \left(m + \frac{1}{2}\right) k\right) \cos\left(\frac{\pi}{N} \left(n + \frac{1}{2}\right) l\right)</script><h3 id="2D-DCT矩阵表示"><a href="#2D-DCT矩阵表示" class="headerlink" title="2D-DCT矩阵表示"></a>2D-DCT矩阵表示</h3><script type="math/tex; mode=display">F = C \cdot f \cdot C^T \\C_{k, n} = \begin{cases}\sqrt{\frac{1}{N}} & \text{if } k = 0 \\\sqrt{\frac{2}{N}} \cos\left(\frac{\pi}{N} \left(n + \frac{1}{2}\right) k\right) & \text{if } k > 0\end{cases} \\</script><script type="math/tex; mode=display">C = \sqrt{\frac{2}{N}} \cdot \begin{bmatrix}\sqrt{\frac{1}{2}} & \sqrt{\frac{1}{2}}  & \cdots & \sqrt{\frac{N}{2}} \\\cos\left(\frac{\pi}{N}(1)(0 + \frac{1}{2})\right) & \cos\left(\frac{\pi}{N}(1)(1 + \frac{1}{2})\right) & \cdots & \cos\left(\frac{\pi}{N}(1)(N-1 + \frac{1}{2})\right) \\\cos\left(\frac{\pi}{N}(2)(0 + \frac{1}{2})\right) & \cos\left(\frac{\pi}{N}(2)(1 + \frac{1}{2})\right) & \cdots & \cos\left(\frac{\pi}{N}(2)(N-1 + \frac{1}{2})\right) \\\vdots & \vdots & \vdots & \ddots & \vdots \\\cos\left(\frac{\pi}{N}(N-1)(0 + \frac{1}{2})\right) & \cos\left(\frac{\pi}{N}(N-1)(1 + \frac{1}{2})\right) & \cdots & \cos\left(\frac{\pi}{N}(N-1)(N-1 + \frac{1}{2})\right)\end{bmatrix}</script><p><img src="/images/图像处理/4.png" alt=""></p><p><img src="/images/图像处理/5.png" alt=""></p><h1 id="图像的离散小波变换"><a href="#图像的离散小波变换" class="headerlink" title="图像的离散小波变换"></a>图像的离散小波变换</h1><h2 id="经典傅里叶变换"><a href="#经典傅里叶变换" class="headerlink" title="经典傅里叶变换"></a>经典傅里叶变换</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>傅里叶变换是一种将信号从时域转换到频域的数学工具。通过将信号表示为不同频率的正弦波的叠加，傅里叶变换能够分析信号的频率成分。</p><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ol><li><p><strong>绝对可积性（Absolute Integrability）</strong> </p><p>信号 $f(t)$ 必须在全域内绝对可积，即满足以下条件：<br>$\int_{-\infty}^{\infty} |f(t)| \, dt &lt; \infty$</p><p>信号的能量不能无限大。如果 $f(t)$ 是绝对可积的，傅里叶变换能够聚集于有限的频率范围内。</p></li><li><p><strong>有限能量（Finite Energy Condition）</strong> </p><p>信号 $f(t)$ 必须是有限能量信号，即满足：<br>$\int_{-\infty}^{\infty} |f(t)|^2 , dt &lt; \infty$</p><p>确保信号在时域中的能量是有限的。对于具有有限能量的信号，通常使用 <strong>傅里叶积分</strong> 而不是傅里叶级数。</p></li><li><p><strong>Dirichlet 条件（Dirichlet Conditions）</strong> </p><p>傅里叶变换常用的充分条件，满足以下 3 个条件之一的信号可以被傅里叶变换： </p><ol><li><p>在一个周期内，信号 $f(t)$ 必须是 <strong>绝对可积</strong> 的。 </p></li><li><p>在每个有限区间内，信号只有有限个 <strong>极值点</strong> 和 <strong>不连续点</strong>。 </p></li><li><p>信号在区间内的 <strong>有限跳变</strong>，即信号的间断点（不连续）在区间中是有限的。</p></li></ol><p>保证傅里叶变换能够有效地处理信号中的不连续性，而不导致结果发散。</p></li></ol><h3 id="数学表达"><a href="#数学表达" class="headerlink" title="数学表达"></a>数学表达</h3><h4 id="连续信号"><a href="#连续信号" class="headerlink" title="连续信号"></a>连续信号</h4><script type="math/tex; mode=display">F(\omega) = \int_{-\infty}^{\infty} f(t) e^{-j\omega t} dt</script><p>$f(t)$:时域信号; $F(\omega)$:频域信号,原函数$f(t)$的傅里叶正变换; $\omega$:角频率.</p><script type="math/tex; mode=display">f(t) = \frac{1}{2\pi} \int_{-\infty}^{\infty} F(\omega) e^{j\omega t} \, d\omega</script><h4 id="离散信号"><a href="#离散信号" class="headerlink" title="离散信号"></a>离散信号</h4><script type="math/tex; mode=display">X[k] = \sum_{n=0}^{N-1} x[n] e^{-j\frac{2\pi}{N}kn}</script><script type="math/tex; mode=display">x[n] = \frac{1}{N} \sum_{k=0}^{N-1} X[k] e^{j\frac{2\pi}{N}kn}</script><h2 id="加窗傅里叶变换-Windowed-Fourier-Transform-WFT"><a href="#加窗傅里叶变换-Windowed-Fourier-Transform-WFT" class="headerlink" title="加窗傅里叶变换(Windowed Fourier Transform, WFT)"></a>加窗傅里叶变换(Windowed Fourier Transform, WFT)</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>傅里叶变换不能表述信号的时变性。加窗傅里叶变换用一个有限区间（即窗口）外恒等于零的光滑函数✖原函数f(t)，再进行傅里叶变换。</p><p>傅里叶变换适合分析<strong>平稳信号</strong>的频率特性，但对于<strong>非平稳信号</strong>（如频率随时间变化的信号）则效果不佳。为了解决这一问题，引入<strong>加窗函数</strong>来截取信号的局部信息，再进行傅里叶变换，从而实现局部频谱分析。</p><p>加入<strong>时间窗函数</strong>，用于分析信号的<em>局部频率特性</em>。它可以捕捉到信号的时间-频率信息，更适合处理<strong>非平稳信号</strong>。</p><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>时域信号$f(t)$在某一时间位置 $\tau$ 上进行 WFT：</p><script type="math/tex; mode=display">F(\tau, \omega) = \int_{-\infty}^{\infty} f(t) g(t - \tau) e^{-j\omega t} \, dt</script><p>其中，</p><p>$g(x)$为<strong>窗函数</strong>，一般选择为高斯窗、汉宁窗或矩形窗等;</p><p>$\tau$表示窗函数在时间轴上的移动位置;</p><p>$F(\tau, \omega)$ 是信号在<strong>频率$\omega$</strong> 和<strong>时间$\tau$</strong> 上的频谱分布。</p><script type="math/tex; mode=display">f(t) = \frac{1}{2\pi} \int_{-\infty}^{\infty} \int_{-\infty}^{\infty} F(\tau, \omega) g(t - \tau) e^{j\omega t} \, d\tau d\omega</script><h3 id="窗函数"><a href="#窗函数" class="headerlink" title="窗函数"></a>窗函数</h3><p>窗函数 $g(t - \tau)$ 可以将信号在时间轴上截断为一个局部区域，仅保留窗口内的信号进行傅里叶变换。</p><ul><li><strong>矩形窗</strong>：适用于简单分割，但频域分辨率差。但容易产生频谱泄漏（spectral leakage）现象，导致频率成分混叠。</li><li><strong>汉宁窗</strong>：减小频谱泄漏，适用于平滑过渡。在平滑过渡时有效，但对于快速变化的信号可能不适用，尤其是在高频部分。</li><li><strong>高斯窗</strong>：具有最优的时间-频率分辨率，适合精确分析。提供较好的时频平衡，但计算复杂度较高。</li></ul><p>宽度选择：</p><ul><li><strong>窄窗</strong>：提供较好的<strong>时间分辨率</strong>，但频率分辨率低。</li><li><strong>宽窗</strong>：提供较好的<strong>频率分辨率</strong>，但时间分辨率低。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><strong>窄窗函数</strong>（小窗口宽度）能够提供较好的时间分辨率，但频率分辨率较差。 </li><li><strong>宽窗函数</strong>（大窗口宽度）能够提供较好的频率分辨率，但时间分辨率较差。</li><li>窗函数一旦选定，大小形状固定不变，不能自适应反映信号突变，而信号突变很大程度反映目标的特征信息。</li></ul><h2 id="小波变换"><a href="#小波变换" class="headerlink" title="小波变换"></a>小波变换</h2><h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><p>傅里叶变换通过正弦波的线性组合表示信号，但它的<strong>固定分辨率</strong>会导致对非平稳信号的分析不足。傅里叶变换不能有效描述信号的局部频率变化，小波变换则通过<strong>伸缩和平移</strong>的方式来分析不同频率成分的细节。<br>小波变换中的<strong>小波函数</strong>提供了高时间分辨率（在高频段）和高频率分辨率（在低频段）的优势，使得它特别适合处理快速变化的信号。</p><p>傅立叶变换是把信号波分解成不同频率的正弦波的叠加和，而对于小波变换就是把一个信号分解成一系列的小波。</p><h3 id="小波-Wavelet"><a href="#小波-Wavelet" class="headerlink" title="小波(Wavelet)"></a>小波(Wavelet)</h3><ul><li>小波函数 $\psi(t)$ 是一个快速衰减或具有紧支集的函数，小区域、长度有限、值为0的波形。 </li><li><strong>零均值条件</strong>：即 $\int_{-\infty}^{+\infty} \psi(t) \, dt = 0$。</li></ul><p>通过对小波函数进行平移和缩放，能够得到用于不同尺度和位置的局部信号分析的基函数。最终达到高频处时间细分，低频处频率细分，能自动适应时频信号分析的要求，可聚焦到信号的任意细节。</p><p><img src="/home/leon/Pictures/Marktext/2024-11-06-00-14-10-image.png" alt=""></p><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><h4 id="一维连续小波变换（CWT）"><a href="#一维连续小波变换（CWT）" class="headerlink" title="一维连续小波变换（CWT）"></a>一维连续小波变换（CWT）</h4><p>对于信号$f(t)$，</p><script type="math/tex; mode=display">W(a, b) = \int_{-\infty}^{+\infty} f(t) \psi_{a, b}^*(t) \, dt</script><p>其中，</p><p>$\psi_{a, b}(t) = \frac{1}{\sqrt{|a|}} \psi \left( \frac{t - b}{a} \right)$ 是对小波函数 $\psi(t)$ 进行伸缩（尺度 $a$）和平移（位置 $b$）的结果。</p><p>$a$ 控制小波的<strong>尺度</strong>（或频率），$b$ 控制小波的<strong>位置</strong>。</p><p>$W(a, b)$ 是信号在尺度 $a$ 和位置 $b$ 的小波变换系数。</p><h4 id="一维离散小波变换（DWT）"><a href="#一维离散小波变换（DWT）" class="headerlink" title="一维离散小波变换（DWT）"></a>一维离散小波变换（DWT）</h4><p>对于离散信号$f(n)$，</p><script type="math/tex; mode=display">W(j, k) = \sum_{n} f(n) \psi_{j, k}^*(n)</script><p>其中，</p><p>$\psi_{j, k}(n) = \frac{1}{\sqrt{2^j}} \psi \left( \frac{n - k \cdot 2^j}{2^j} \right)$ 表示第 $j$ 个尺度、第 $k$ 个平移的小波基函数。</p><p>$j$ 表示尺度（控制频率分辨率），$k$ 表示时间位置（控制时间分辨率）。</p><h4 id="二维连续小波变换"><a href="#二维连续小波变换" class="headerlink" title="二维连续小波变换"></a>二维连续小波变换</h4>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo遇到的问题</title>
      <link href="/2024/10/31/Blog/Hexo%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98(%E6%9B%B4%E6%96%B0%E4%B8%AD)/"/>
      <url>/2024/10/31/Blog/Hexo%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98(%E6%9B%B4%E6%96%B0%E4%B8%AD)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Hexo博客-source-posts内写的md文件-中无法显示本地图片"><a href="#Hexo博客-source-posts内写的md文件-中无法显示本地图片" class="headerlink" title="Hexo博客(source/_posts内写的md文件)中无法显示本地图片"></a>Hexo博客(source/_posts内写的md文件)中无法显示本地图片</h2><blockquote><p>我的系统：hexo: 7.3.0、 hexo-cli: 4.3.2、 os: linux 5.15.0-124-generic Ubuntu 20.04.6 LTS (Focal Fossa)<br>需要使用绝对路径。<br>原因：<br><img src="/images/Blog/Hexo/7.png" alt=""><br>发现在<code>hexo g</code>后，在<code>public/</code>文件夹下，图片的url路径是<code>/images/</code>。写的博客会从<code>public/</code>文件夹中读取。<br>我是在<code>source/</code>文件夹下创建了<code>images</code>文件夹，将图片放在了<code>source/iamges/</code>文件夹下，那么在md文件中引用图片时，需要写成<code>/images/</code>，而不是<code>images/</code>。但是自己的编辑器无法显示出图像。</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">image</span>](<span class="link">/images/xxx.png</span>)</span><br></pre></td></tr></table></figure><blockquote></blockquote><ul><li>另一种方法（但是我觉得都放在<code>source/_post/</code>文件夹下太乱了，并没有这么做）：<br><a href="https://blog.csdn.net/m0_43401436/article/details/107191688">hexo博客中插入图片失败——解决思路及个人最终解决办法</a></li></ul><h2 id="Hexo博客”有序列表”不能正常显示-出现序号重复。"><a href="#Hexo博客”有序列表”不能正常显示-出现序号重复。" class="headerlink" title="Hexo博客”有序列表”不能正常显示, 出现序号重复。"></a>Hexo博客”有序列表”不能正常显示, 出现序号重复。</h2><blockquote><p>在有序列表中，每行都加上一个空格，这样Markdown就认为这属于同一个列表项。<br>如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> <span class="strong">**nvidia-driver-535 (推荐)**</span>：</span><br><span class="line"><span class="bullet"> -</span> <span class="strong">**版本**</span>: 535</span><br><span class="line"><span class="bullet"> -</span> <span class="strong">**类型**</span>: NVIDIA 专有驱动（non-free）</span><br><span class="line"><span class="bullet"> -</span> <span class="strong">**描述**</span>: 这是最新的稳定版本，由 NVIDIA 官方提供。它被推荐用于现代 NVIDIA 显卡，支持最新的显卡功能、性能优化和 bug 修复。如果系统推荐你使用这个驱动，意味着它最适合你的显卡硬件。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> <span class="strong">**nvidia-driver-535-open**</span>：</span><br><span class="line"><span class="bullet"> -</span> <span class="strong">**版本**</span>: 535</span><br><span class="line"><span class="bullet"> -</span> <span class="strong">**类型**</span>: 开源版本</span><br><span class="line"><span class="bullet"> -</span> <span class="strong">**描述**</span>: 这是 NVIDIA 的开源驱动，基于官方的 open-gpu-kernel-modules。尽管它是开源的，但在功能和性能上可能不如闭源版本全面，适合希望在开源环境中使用的用户。</span><br></pre></td></tr></table></figure></blockquote><h2 id="hexo博客中数学公式如何换行"><a href="#hexo博客中数学公式如何换行" class="headerlink" title="hexo博客中数学公式如何换行"></a>hexo博客中数学公式如何换行</h2><blockquote><p>由于Hexo中会先将Markdown转换为html，然后由MathJax渲染数学公式，所以换行需要写成四个 \ ，这样能确保MathJax能够看到两个连续的 \ 。</p></blockquote><h2 id="如何在一个博客中链接另一个博客？"><a href="#如何在一个博客中链接另一个博客？" class="headerlink" title="如何在一个博客中链接另一个博客？"></a>如何在一个博客中链接另一个博客？</h2>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一、数字图像处理基础</title>
      <link href="/2024/10/30/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%B8%80%E3%80%81%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/10/30/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%B8%80%E3%80%81%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="色度学基础"><a href="#色度学基础" class="headerlink" title="色度学基础"></a>色度学基础</h2><h3 id="三基色"><a href="#三基色" class="headerlink" title="三基色"></a>三基色</h3><p>人眼的视网膜上存在大量能在适当亮度下分辨颜色的锥状细胞，它们分别对应红、绿、蓝三种颜色，即分别对红光、绿光、蓝光敏感。由此，红（R）、绿（G）、蓝（B）这三种颜色被称为三基色。</p><blockquote><p>三基色原理：自然界中的绝大部分色光都可以用特殊选定的三种基本单色光复合而成。</p></blockquote><p>国际照明委员会(CIE)选择红色（波长700.00nm），绿色（波长546.1nm）和蓝色（波长435.8nm）三种光作为表色系统的三基色。</p><p>任意彩色C： <code>C = R（R）+ G（G）+ B（B）</code></p><h3 id="颜色模型"><a href="#颜色模型" class="headerlink" title="颜色模型"></a>颜色模型</h3><p>人眼视觉的感受颜色可用色调（hue）、饱和度（saturation）和亮度（brightness）来表示。</p><blockquote><p>色调：它表明颜色的种类，取决于主波长；<br>饱和度：表示颜色浓淡的物理量。通常用混入白光量的比例来度量。<br>亮度（辉度）：人眼所感受到的颜色明暗程度的物理量。</p></blockquote><p>颜色模型:各种表示颜色的方法。</p><ol><li><p><em>RGB模型</em></p><p>在三维直角坐标系中，用相互垂直的三个坐标轴代表R、G、B三<br>个分量，并将R、G、B分别限定在[0,1]，则该单位正方体就代表颜色<br>空间，其中的一个点就代表一种颜色。</p><p><img src="/images/图像处理/1.png" alt=""></p><ul><li>面向机器（如显示器、摄像机、打印机等）</li></ul></li><li><p><em>HSI模型/HSV模型</em><br>HSI模型利用颜色的三个属性色调H（hue）、饱和度S（ saturation ）和亮度I（intensity）组成一个表示颜色的双圆锥体。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a1e00f255226b84a2fe9796ba5549408.png" alt=""></p><ul><li>面向颜色处理（也面向人眼视觉）</li></ul><blockquote><p>RGB -&gt; HSI</p><p><strong>计算亮度 ( I )</strong>:<br>$I = \frac{R + G + B}{3}$</p><p><strong>计算饱和度 ( S )</strong>:<br>  反映出颜色的纯度。</p><p>$S = 1 - \frac{\text{min}(R, G, B)}{I} \quad (I \neq 0)$</p><p><strong>计算色相 ( H )</strong>: </p><p>  计算出颜色在色轮上的角度。</p><p>  计算RGB三个分量中的最大值和最小值；根据最大值和最小值确定颜色在色轮上的位置；根据不同情况计算出色相值，这些情况涉及了最大值的位置。</p><ul><li><p>如果 ( R = G = B ): H = 0</p></li><li><p>如果 $B \leq G$:<br>$H = \frac{1}{2} \times \left( \frac{(R - G) + (R - B)}{(R - G) + (G - B)} \right)$</p></li><li><p>如果 ( B &gt; G ):<br>$H = 1 - \frac{1}{2} \times \left( \frac{(R - G) + (R - B)}{(R - G) + (G - B)} \right)$</p></li></ul></blockquote></li><li><p><em>CMYK模型</em></p><p>青色(Cyan)、品红(Magenta)、黄色(Yellow)和黑色(Key)的颜色模型。</p><ul><li><p>通过减去特定波长的光来产生颜色，因此适合印刷行业。</p></li><li><p>主要用于彩色印刷和设计领域，因为它能有效地混合这些颜色以生成其他颜色。</p></li><li><p>减色模型</p><blockquote><p>减色模型主要是指通过减去光的某些波长来生成颜色的模型。</p></blockquote></li></ul></li><li><p><em>YCbCr模型</em></p><p>Y指亮度分量，Cb指蓝色色度分量，而Cr指红色色度分量。</p><ul><li><p>亮度信息和色彩信息的分离</p></li><li><p>用于数字彩色信号编码</p></li></ul></li><li><p><em>Lab模型</em></p><p>L: 亮度成分（Lightness），范围从0到100，0表示黑色，100表示白色。 a: 红色-绿色成分，负值表示绿色，正值表示红色。 </p><p>b: 黄蓝成分，负值表示蓝色，正值表示黄色。</p><ul><li>亮度、色度分开</li></ul></li></ol><h2 id="人的视觉特性"><a href="#人的视觉特性" class="headerlink" title="人的视觉特性"></a>人的视觉特性</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/be0400452785cda9fc85c2ca23de7270.png" alt=""></p><ul><li><p>瞳孔：透明的角膜后是不透明的虹膜，虹膜中间的圆孔称为瞳孔，其直径可调节，控制进入人眼内之光通量(照相机光圈作用)。</p></li><li><p>晶状体：瞳孔后是一扁球形弹性透明体，其曲率可调节，以改变焦距，使不同距离的图在视网膜上成像 (照相机透镜作用)。</p></li><li><p>视细胞：视网膜上集中了大量视细胞，分为两类：</p><ul><li><p>锥状细胞：明视细胞，在强光下检测亮度和颜色；</p></li><li><p>杆(柱)状细胞：暗视细胞，在弱光下检测亮度，无色彩感觉。</p></li></ul><p>其中，每个锥状视细胞连接着一个视神经末梢，故分辨率高，分辨细节、颜色；多个杆状视细胞连接着一个视神经末梢，故分辨率低，仅分辨物体的轮廓。</p></li></ul><h2 id="图像数字化"><a href="#图像数字化" class="headerlink" title="图像数字化"></a>图像数字化</h2><h3 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h3><ol><li><p>采样：将连续图像中的信息在空间上取样，并将其转换为离散点。</p><p>位置上离散化 f ( x, y ) ==&gt; fs(m,n) ， (m,n)为采样点，称为像素(pixel) 。</p></li><li><p>采样的过程</p><ul><li><p>空间采样: 通过在图像中定义网格或像素阵列，在每个像素位置上记录颜色和亮度值。</p></li><li><p>时间采样: 在动态图像（如视频）中，时间采样则是指在不同时间点捕捉图像帧。</p></li></ul></li></ol><h3 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h3><ol><li><p>量化：将连续的颜色或亮度值（如灰度级）映射到有限的离散值集合中的过程。这使得计算机能够用数字形式表示图像。</p></li><li><p>量化过程</p><ul><li><p>确定量化级数G: 选择量化级别（如256级、16级等），决定每个像素的颜色表示的细致程度。</p></li><li><p>划分区间: 根据选定的级数，将原始值范围分成相等或不等的区间。</p></li><li><p>替换值（映射）: 将每个像素的连续值替换为对应区间的离散值。</p></li></ul></li><li><p>因素</p><ul><li><p>量化精度: 更高的量化级数能够保留更多的图像细节，但会增加存储需求。</p></li><li><p>颜色深度: 通常以位数表示（如8位、16位），8位图像能表示256种颜色或灰度级，而16位图像能表示65,536种。</p></li></ul></li></ol><p><mark><strong>连续图像到数字图像:</strong></mark></p><p>捕获图像（连续图像）—&gt; 空间采样 —&gt; 幅度量化 —&gt; 数据编码（数字图像）</p><h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3><ol><li><p><strong>分辨率</strong>: 通常指图像的细节表现能力，表示图像中包含的像素数量。分辨率越高，图像细节越丰富。</p><p>因素：采样点数（M，N）和灰度级(数)G。</p></li><li><p>空间分辨率</p><ul><li><p>采样点数越多（采样间隔越小），空间分辨率越高；</p></li><li><p>G不变，(M,N)减少，图像像素粒子变粗。</p></li></ul></li><li><p>幅度分辨率</p><ul><li><p>G越多，图像幅度分辨率越高；</p></li><li><p>M、N不变，G减少，灰度渐变变成突变，出现虚假轮廓</p></li></ul></li></ol><h3 id="数字图像"><a href="#数字图像" class="headerlink" title="数字图像"></a>数字图像</h3><ol><li><p>表示形式</p><p>矩阵表示</p></li><li><p>特点</p><ul><li><p>信息量大</p></li><li><p>占用频带宽</p></li><li><p>像素间相关性大</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何快速搞清字号、纸张和电池的标准尺寸？</title>
      <link href="/2024/10/24/Life/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%90%9E%E6%B8%85%E5%AD%97%E5%8F%B7%E3%80%81%E7%BA%B8%E5%BC%A0%E5%92%8C%E7%94%B5%E6%B1%A0%E7%9A%84%E6%A0%87%E5%87%86%E5%B0%BA%E5%AF%B8%EF%BC%9F/"/>
      <url>/2024/10/24/Life/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%90%9E%E6%B8%85%E5%AD%97%E5%8F%B7%E3%80%81%E7%BA%B8%E5%BC%A0%E5%92%8C%E7%94%B5%E6%B1%A0%E7%9A%84%E6%A0%87%E5%87%86%E5%B0%BA%E5%AF%B8%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>生活中经常分不清字号、纸张和电池的标准尺寸，今天闲来无事总结一下。</p></blockquote><h2 id="字号"><a href="#字号" class="headerlink" title="字号"></a>字号</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>字号：指印刷文字的大小，文字的高度，通常以磅（pt）（点（Point））为单位表示。</li><li>点：1点等于1/72英寸，即0.3515毫米。</li></ul><h3 id="常见字号以及对应磅数"><a href="#常见字号以及对应磅数" class="headerlink" title="常见字号以及对应磅数"></a>常见字号以及对应磅数</h3><ul><li><p>初号：42pt</p></li><li><p>小初：36pt</p></li><li><p>一号：26pt</p></li><li><p>小一：24pt</p></li><li><p>二号：22pt</p></li><li><p>小二：18pt</p></li><li><p>三号：16pt</p></li><li><p>小三：15pt</p></li><li><p>四号：14pt</p></li><li><p>小四：12pt</p></li><li><p>五号：10.5pt</p></li><li><p>小五：9pt</p></li></ul><p>正文常用<strong>小四号</strong>（12pt）或<strong>五号</strong>（10.5pt），标题通常使用较大的字号，如<strong>三号</strong>或<strong>小三号</strong>。</p><hr><h2 id="纸张尺寸"><a href="#纸张尺寸" class="headerlink" title="纸张尺寸"></a>纸张尺寸</h2><p><a href="https://zh.wikipedia.org/zh-hans/%E7%BA%B8%E5%BC%A0%E5%B0%BA%E5%AF%B8"><strong>纸张尺寸</strong></a>（paper size）是将<a href="https://zh.wikipedia.org/wiki/%E7%B4%99" title="纸">纸张</a>的宽高规范成固定的比例尺寸来使用。</p><p>国际标准的纸张尺寸可分为A、B、和C三种系列。此标准的特色是纸张尺寸的宽高比均为 $\sqrt{2}$（约为1.4142）。</p><h3 id="A系列"><a href="#A系列" class="headerlink" title="A系列"></a>A系列</h3><p>A系列是最常见的纸张尺寸标准，应用于办公、打印和出版等各个领域。其最著名的纸张是<strong>A4</strong>，通常用于打印文件和写作材料。A系列的特点是，每向下一级尺寸折叠时，纸张的面积减半，保持了宽高比的恒定（√2:1）。</p><ul><li><strong>A0</strong>：841 x 1189 毫米（非常适合用于海报和建筑设计图纸）</li><li><strong>A1</strong>：594 x 841 毫米</li><li><strong>A2</strong>：420 x 594 毫米</li><li><strong>A3</strong>：297 x 420 毫米（常用于小型海报或图表，考试大试卷）</li><li><strong>A4</strong>：210 x 297 毫米（最常用的办公纸张，适用于打印和信件）</li><li><strong>A5</strong>：148 x 210 毫米（适合笔记本、宣传单页等）</li></ul><p>若将 A0 纸张的长边对切为二，则得到两张 <strong>A1</strong> 的纸张，其宽高分别为 594 毫米和 841 毫米。依此方式继续将 A1 纸张对切，则可以依序得到 <strong>A2</strong>、<strong>A3</strong>、<strong>A4</strong> 等等纸张尺寸。</p><h3 id="B系列"><a href="#B系列" class="headerlink" title="B系列"></a>B系列</h3><p>B系列尺寸稍大于A系列，通常用于需要更大面积的场合，如图书出版、海报等。B系列纸张的长宽比同样保持1:√2，与A系列不同的是，B系列以不同的基准开始，面积比A系列大。</p><ul><li><strong>B0</strong>：1000 x 1414 毫米</li><li><strong>B1</strong>：707 x 1000 毫米</li><li><strong>B2</strong>：500 x 707 毫米</li><li><strong>B3</strong>：353 x 500 毫米</li><li><strong>B4</strong>：250 x 353 毫米</li><li><strong>B5</strong>：176 x 250 毫米</li></ul><h3 id="C系列"><a href="#C系列" class="headerlink" title="C系列"></a>C系列</h3><p>C系列的制定基础是将A系列和B系列的尺寸作<a href="https://zh.wikipedia.org/wiki/%E5%87%A0%E4%BD%95%E5%B9%B3%E5%9D%87" title="几何平均">几何平均</a>而求得的。例如C4的纸张尺寸是A4和B4尺寸的几何平均，且纸张宽高比仍为√2:1。C系列通常用于<strong>信封</strong>，其设计尺寸能完美地容纳相应的A系列纸张。例如，A4大小的文件可以放入C4信封中，而A5文件可以放入C5信封中。</p><ul><li><strong>C0</strong>：917 x 1297 毫米</li><li><strong>C1</strong>：648 x 917 毫米</li><li><strong>C2</strong>：458 x 648 毫米</li><li><strong>C4</strong>：229 x 324 毫米（适合A4纸张的信封）</li><li><strong>C5</strong>：162 x 229 毫米（适合A5纸张的信封）</li></ul><hr><h2 id="电池"><a href="#电池" class="headerlink" title="电池"></a>电池</h2><h3 id="基本分类"><a href="#基本分类" class="headerlink" title="基本分类"></a>基本分类</h3><ol><li><p>一次性电池</p><p>一次性电池也称为<strong>原电池</strong>，使用后不能充电再用，适合短期使用或不频繁更换的设备。常见的一次性电池类型包括：</p><ul><li><strong>碱性电池</strong>：适合低耗能设备，如遥控器、时钟、手电筒等。常见型号为AA、AAA。</li><li><strong>锌锰电池</strong>：价格相对低廉，适用于低功耗设备，但容量和性能比碱性电池差。</li><li><strong>锂电池</strong>：比碱性电池寿命更长，适合高耗能设备，如相机、烟雾报警器等。</li></ul></li><li><p>可充电电池</p><p>可充电电池可以多次充电使用，适合长期使用或高耗电的设备。常见的可充电电池类型包括：</p><ul><li><strong>镍氢电池（NiMH）</strong>：相对安全，容量大，广泛应用于数码相机、游戏手柄等。</li><li><strong>锂离子电池（Li-ion）</strong>：轻便、容量大且无记忆效应，广泛应用于手机、笔记本电脑、电动工具等。</li><li><strong>镍镉电池（NiCd）</strong>：老旧技术，具有记忆效应，但已逐步被镍氢电池和锂离子电池替代。</li></ul></li></ol><h3 id="型号"><a href="#型号" class="headerlink" title="型号"></a>型号</h3><h4 id="1号电池（D电池）"><a href="#1号电池（D电池）" class="headerlink" title="1号电池（D电池）"></a><strong>1号电池（D电池）</strong></h4><p>1号电池，也叫<strong>D型电池</strong>，是体积较大的圆柱形电池，常用于高功耗设备，如手电筒、收音机、大型玩具等。它的尺寸为<strong>直径34.2毫米，长度61.5毫米</strong>，容量较大，能提供较长的使用时间。</p><ul><li><strong>电压</strong>：通常为1.5V（碱性电池），也有可充电版本。</li><li><strong>用途</strong>：高耗能设备，如手电筒、无线音箱、大型玩具等。</li></ul><h4 id="2号电池（C电池）"><a href="#2号电池（C电池）" class="headerlink" title="2号电池（C电池）"></a><strong>2号电池（C电池）</strong></h4><p>2号电池，也叫<strong>C型电池</strong>，比1号电池稍小，适合中等功耗的设备。它的尺寸为<strong>直径26.2毫米，长度50毫米</strong>。容量较大，但比1号电池小一些。</p><ul><li><strong>电压</strong>：1.5V（碱性电池），也有可充电版本。</li><li><strong>用途</strong>：中等功耗设备，如收音机、玩具、手电筒等。</li></ul><h4 id="5号电池（AA电池）"><a href="#5号电池（AA电池）" class="headerlink" title="5号电池（AA电池）"></a><strong>5号电池（AA电池）</strong></h4><p>5号电池，也就是<strong>AA电池</strong>，是最常见的电池型号，广泛应用于各种家用电器和小型电子设备。它的尺寸为<strong>直径14.5毫米，长度50.5毫米</strong>。</p><ul><li><strong>电压</strong>：1.5V（碱性电池），通常也有1.2V的镍氢充电电池。</li><li><strong>用途</strong>：遥控器、钟表、无线鼠标、玩具等。</li></ul><h4 id="7号电池（AAA电池）"><a href="#7号电池（AAA电池）" class="headerlink" title="7号电池（AAA电池）"></a><strong>7号电池（AAA电池）</strong></h4><p>7号电池，也叫<strong>AAA电池</strong>，比5号电池小，适用于低功耗的设备。它的尺寸为<strong>直径10.5毫米，长度44.5毫米</strong>。</p><ul><li><strong>电压</strong>：1.5V（碱性电池），可充电的镍氢电池为1.2V。</li><li><strong>用途</strong>：电视遥控器、手电筒、无线鼠标、小型玩具等。</li></ul><h4 id="9号电池（9V电池）"><a href="#9号电池（9V电池）" class="headerlink" title="9号电池（9V电池）"></a><strong>9号电池（9V电池）</strong></h4><p>9号电池是一种方形电池，通常电压为<strong>9V</strong>。虽然不是按照“几号”命名，但在国内有时也被称为“9号电池”。这种电池常用于需要高电压的设备。</p><ul><li><strong>电压</strong>：9V</li><li><strong>用途</strong>：烟雾报警器、无线麦克风、万用表等。</li></ul><h4 id="CR2032纽扣电池"><a href="#CR2032纽扣电池" class="headerlink" title="CR2032纽扣电池"></a><strong>CR2032纽扣电池</strong></h4><p>CR2032是一种常见的纽扣电池，直径为<strong>20毫米</strong>，厚度为<strong>3.2毫米</strong>，通常用于小型电子设备。</p><ul><li><strong>电压</strong>：3V</li><li><strong>用途</strong>：计算器、汽车钥匙、主板BIOS、电动玩具等</li></ul><h4 id="18650锂电池"><a href="#18650锂电池" class="headerlink" title="18650锂电池"></a><a href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fwww.mrchip.cn%2FnewsDetail%2F3828&amp;psig=AOvVaw0kwzh8U-P5mLsb6oXl8k0R&amp;ust=1729865007575000&amp;source=images&amp;cd=vfe&amp;opi=89978449&amp;ved=0CBQQjRxqFwoTCLC4vMKXp4kDFQAAAAAdAAAAABAE"><strong>18650锂电池</strong></a></h4><p>18650锂电池是一种高容量的可充电电池，常用于需要较大电量和持久续航的设备。“18”表示电池的直径为<strong>18毫米</strong>，“65”表示电池的长度为<strong>65毫米</strong>，而“0”则表示其是圆柱形电池。</p><ul><li><strong>电压</strong>：3.7V（锂离子电池）</li><li><strong>用途</strong>：手电筒、电动工具、电子烟、便携式充电器等</li></ul><h4 id="笔记本电池"><a href="#笔记本电池" class="headerlink" title="笔记本电池"></a><strong>笔记本电池</strong></h4><p>笔记本电池是一种较大容量的可充电电池组，通常由多个18650电池单元组成。这些电池根据笔记本型号而异，通常提供数小时的续航能力。</p><ul><li><strong>电压</strong>：通常为11.1V或14.8V（根据电池芯数不同）</li><li><strong>用途</strong>：笔记本电脑</li></ul><blockquote><p>为什么没有3号和4号电池？</p><ol><li><p><strong>电池命名历史的影响</strong><br>电池的编号和命名由电池的物理尺寸、电压和历史发展所决定。AA（5号）和AAA（7号）是电池设计和标准化过程中常用的术语。而较大的电池，如1号（D型）和2号（C型），以及较小的纽扣电池，都有其特定的应用。虽然你可能会以为电池型号应该按照数字顺序排列，但实际命名过程中，生产和使用需求的差异影响了这些编号。</p></li><li><p><strong>编号并非完全顺序</strong><br>电池的编号方式是根据国际电工委员会（IEC）和美国电气制造商协会（NEMA）设定的标准，它们并不是按照严格的数字顺序排列的。像“5号电池”中的“5号”并不表示大小介于“4号”和“6号”之间，而是仅仅作为一种代号。电池的尺寸和容量与它们的编号之间没有直接的线性关系，这也是为什么你在市面上看到1号、2号、5号、7号电池，但却没有“3号”或“4号”电池。</p></li><li><p><strong>其他尺寸电池的命名</strong><br>虽然我们日常生活中常见的是AA（5号）、AAA（7号）等电池，但在工业、医疗、航天等领域中存在着各种不同尺寸和形状的电池。某些国家和领域中可能有“3号”或“4号”电池的存在，但它们的使用较少，不是大众消费市场的主流型号，因此在日常生活中几乎见不到。</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 奇怪的生活知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu中conda安装显卡驱动、CUDA、pytorch</title>
      <link href="/2024/10/21/Python/Ubuntu%E4%B8%ADconda%E5%AE%89%E8%A3%85%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8%E3%80%81CUDA%E3%80%81pytorch/"/>
      <url>/2024/10/21/Python/Ubuntu%E4%B8%ADconda%E5%AE%89%E8%A3%85%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8%E3%80%81CUDA%E3%80%81pytorch/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>环境：Ubuntu20.04 x86_64、 anaconda</p></blockquote><h2 id="安装显卡驱动"><a href="#安装显卡驱动" class="headerlink" title="安装显卡驱动"></a>安装显卡驱动</h2><blockquote><p>显卡驱动（GPU driver）是操作系统与显卡硬件之间的一种软件接口，它负责管理和控制计算机中的图形处理器（GPU），<mark>是一种底层软件</mark>。显卡驱动的主要作用是使操作系统和应用程序能够正确使用显卡的硬件资源，从而处理和显示图形、加速渲染和视频输出等任务。</p><p>显卡驱动的主要功能：</p><ol><li><p><strong>与硬件通信</strong>：<br>显卡驱动是显卡硬件与操作系统之间的“桥梁”。它向操作系统提供一套标准化的指令，使操作系统能够利用显卡硬件执行图形任务，比如 3D 渲染、视频解码等。</p></li><li><p><strong>图形加速</strong>：<br>显卡驱动通过调用 GPU 的硬件加速功能，显著提升图形渲染性能，尤其是对 3D 应用程序和视频的处理。它能够将复杂的图形任务交给 GPU 专门的硬件来执行，而不是让 CPU 完全负责。</p></li><li><p><strong>显示设置和管理</strong>：<br>驱动程序管理和控制显示器的分辨率、刷新率、颜色深度等参数，并支持多显示器配置。在驱动程序中，你可以调整显示器的布局、旋转方向等。</p></li><li><p><strong>优化性能</strong>：<br>显卡驱动通常会根据具体硬件做优化，使得系统能够以最高效的方式使用显卡的资源。制造商（如 NVIDIA 或 AMD）会发布驱动更新，修复问题或优化针对特定游戏、软件的性能。</p></li><li><p><strong>兼容性</strong>：<br>驱动程序确保操作系统与显卡硬件的兼容性，提供 API（如 OpenGL、DirectX、Vulkan）的支持，允许开发人员编写图形应用程序，并且让用户能够运行这些应用程序。</p></li></ol><p>常见的显卡驱动类型：</p><ol><li><p><strong>厂商驱动（Proprietary Drivers）</strong>：<br>这些是由显卡制造商（如 NVIDIA、AMD 或 Intel）开发并发布的专有驱动程序。它们通常是闭源的，性能优化和硬件支持更好，尤其是在处理图形密集型任务（如游戏、3D 渲染）时表现更佳。</p><ul><li>例如：NVIDIA 的 <code>nvidia-driver-535</code>、AMD 的 <code>amdgpu-pro</code>。</li></ul></li><li><p><strong>开源驱动（Open-Source Drivers）</strong>：<br>开源社区为某些显卡开发了免费的驱动程序，它们是开源的，可以由用户修改和改进。尽管这些驱动程序的性能有时不如厂商的闭源驱动，但它们在开源操作系统（如 Linux）中使用广泛，并且由社区进行长期维护。</p><ul><li>例如：NVIDIA 的开源驱动 <code>nouveau</code>、AMD 的 <code>amdgpu</code>。</li></ul></li></ol></blockquote><h3 id="更新软件包"><a href="#更新软件包" class="headerlink" title="更新软件包"></a>更新软件包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">sudo</span> add-apt-repository ppa:graphics-drivers/ppa  <span class="comment"># 加入官方ppa源</span></span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">sudo</span> apt update  <span class="comment"># 检查软件包更新列表</span></span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">sudo</span> apt upgrade  <span class="comment"># 更新所有可更新的软件包</span></span></span><br></pre></td></tr></table></figure><h3 id="检查可选驱动"><a href="#检查可选驱动" class="headerlink" title="检查可选驱动"></a>检查可选驱动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">ubuntu-drivers devices</span> </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">我的结果：</span><br><span class="line">ubuntu-drivers devices</span><br><span class="line">== /sys/devices/pci0000:00/0000:00:01.0/0000:01:00.0 ==</span><br><span class="line">modalias : pci:v000010DEd00002560sv000017AAsd00003AE8bc03sc00i00</span><br><span class="line">vendor   : NVIDIA Corporation</span><br><span class="line">driver   : nvidia-driver-470 - distro non-free</span><br><span class="line">driver   : nvidia-driver-535-server - distro non-free</span><br><span class="line">driver   : nvidia-driver-535-server-open - distro non-free</span><br><span class="line">driver   : nvidia-driver-470-server - distro non-free</span><br><span class="line">driver   : nvidia-driver-535 - distro non-free recommended</span><br><span class="line">driver   : nvidia-driver-535-open - distro non-free</span><br><span class="line">driver   : xserver-xorg-video-nouveau - distro free builtin</span><br></pre></td></tr></table></figure><blockquote><ul><li><p><strong>distro</strong>: 代表你的 Linux 发行版（distribution），例如 Ubuntu。它指明这个驱动程序是由发行版的官方软件仓库提供的，而不是用户手动从第三方下载的。</p></li><li><p><strong>non-free</strong>: 代表该驱动程序是 <strong>非自由</strong>（proprietary）的，也就是它的源代码没有公开，通常由公司（如 NVIDIA）拥有和维护。用户无法自由修改或发布它的源代码。虽然它是闭源的，但通常能够提供更好的硬件支持、性能优化和 bug 修复。</p></li></ul><ol><li><p><strong>nvidia-driver-535 (推荐)</strong>：</p><ul><li><strong>版本</strong>: 535</li><li><strong>类型</strong>: NVIDIA 专有驱动（non-free）</li><li><strong>描述</strong>: 这是最新的稳定版本，由 NVIDIA 官方提供。它被推荐用于现代 NVIDIA 显卡，支持最新的显卡功能、性能优化和 bug 修复。如果系统推荐你使用这个驱动，意味着它最适合你的显卡硬件。</li></ul></li><li><p><strong>nvidia-driver-535-open</strong>：</p><ul><li><strong>版本</strong>: 535</li><li><strong>类型</strong>: 开源版本</li><li><strong>描述</strong>: 这是 NVIDIA 的开源驱动，基于官方的 open-gpu-kernel-modules。尽管它是开源的，但在功能和性能上可能不如闭源版本全面，适合希望在开源环境中使用的用户。</li></ul></li><li><p><strong>nvidia-driver-535-server</strong>：</p><ul><li><strong>版本</strong>: 535</li><li><strong>类型</strong>: 专有驱动（non-free）</li><li><strong>描述</strong>: 这是专门为服务器硬件优化的版本。服务器驱动专注于稳定性和长期支持，通常被用于数据中心和 GPU 加速的计算任务，如深度学习、AI 推理等工作负载。</li></ul></li><li><p><strong>nvidia-driver-535-server-open</strong>：</p><ul><li><strong>版本</strong>: 535</li><li><strong>类型</strong>: 开源版本</li><li><strong>描述</strong>: 这是服务器驱动的开源版本，类似于 <code>nvidia-driver-535-open</code>，但针对服务器工作负载进行了优化。</li></ul></li><li><p><strong>nvidia-driver-470</strong>：</p><ul><li><strong>版本</strong>: 470</li><li><strong>类型</strong>: 专有驱动（non-free）</li><li><strong>描述</strong>: 这是 NVIDIA 的较旧的稳定版本，适用于一些兼容性要求较高的旧显卡或软件环境。如果某些旧应用或旧硬件不完全支持新驱动，可能需要这个版本。</li></ul></li><li><p><strong>nvidia-driver-470-server</strong>：</p><ul><li><strong>版本</strong>: 470</li><li><strong>类型</strong>: 专有驱动（non-free）</li><li><strong>描述</strong>: 这是与 <code>nvidia-driver-470</code> 相似的版本，但它是为服务器环境优化的，重点关注稳定性和长期支持。</li></ul></li><li><p><strong>xserver-xorg-video-nouveau</strong>：</p><ul><li><strong>版本</strong>: Nouveau（开源驱动）</li><li><strong>类型</strong>: 开源驱动（free builtin）</li><li><strong>描述</strong>: 这是 Linux 社区开发的开源 NVIDIA 显卡驱动，默认包含在大多数 Linux 发行版中。虽然它不需要安装非自由软件，但性能和功能性不如 NVIDIA 的官方闭源驱动。适合对开源驱动有偏好，但在性能和显卡高级功能需求较低的场景。</li></ul></li></ol></blockquote><h3 id="下载安装驱动"><a href="#下载安装驱动" class="headerlink" title="下载安装驱动"></a>下载安装驱动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">sudo</span> apt install nvidia-driver-535   <span class="comment"># 根据自己需求可选驱动下载显卡驱动</span></span></span><br></pre></td></tr></table></figure><h3 id="查看显卡基本信息验证是否安装成功"><a href="#查看显卡基本信息验证是否安装成功" class="headerlink" title="查看显卡基本信息验证是否安装成功"></a>查看显卡基本信息验证是否安装成功</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">nvidia-smi</span></span><br></pre></td></tr></table></figure><p><img src="/images/Blog/Ubuntu软件安装/3.png" alt=""></p><h3 id="查询问题（若未安装成功）"><a href="#查询问题（若未安装成功）" class="headerlink" title="查询问题（若未安装成功）"></a>查询问题（若未安装成功）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">sudo</span> gpu-manager</span></span><br></pre></td></tr></table></figure><p><img src="/images/Blog/Ubuntu软件安装/4.png" alt=""></p><p>根据信息进行相应问题解决</p><h2 id="CUDA安装（以下是安装在系统）"><a href="#CUDA安装（以下是安装在系统）" class="headerlink" title="CUDA安装（以下是安装在系统）"></a>CUDA安装（以下是安装在系统）</h2><blockquote><p>CUDA（Compute Unified Device Architecture）是由 <strong>NVIDIA</strong> 开发的<mark>一种并行计算平台和编程模型</mark>，旨在利用 <strong>GPU</strong>（图形处理单元）的强大计算能力进行通用计算任务。CUDA 允许开发者使用 GPU 处理不仅限于图形渲染的高性能计算任务，比如科学计算、机器学习、深度学习和模拟仿真等。</p><p><strong>CUDA的基本概念</strong></p><ol><li><p><strong>并行计算</strong>：<br>CUDA 提供了一种并行编程环境，允许开发者编写程序，将计算任务分解为大量的小任务，并将这些任务分配到 GPU 上的成千上万个处理核心上同时执行。GPU 的设计使得它非常适合处理需要大规模并行计算的任务。</p></li><li><p><strong>GPU与CPU的协作</strong>：<br>在 CUDA 编程中，CPU 称为 <strong>主机（Host）</strong>，GPU 则称为 <strong>设备（Device）</strong>。CPU 主要负责一般的计算任务和管理程序的控制流，而 GPU 则负责执行计算密集型的并行任务。CUDA 编程模型允许开发者将部分工作交给 GPU 处理，从而大大加速计算过程。</p></li><li><p><strong>内存模型</strong>：<br>CUDA 提供了灵活的内存管理方式。内存主要分为 <strong>主机内存（Host Memory）</strong> 和 <strong>设备内存（Device Memory）</strong>，即 CPU 和 GPU 各自的内存。程序通常需要将数据从主机内存复制到设备内存，然后在 GPU 上进行计算，最后将结果返回到主机。</p></li></ol><p><strong>CUDA 编程模型</strong></p><p>CUDA 的编程语言基于 <strong>C/C++</strong>，并提供了扩展来定义并行任务，主要包括以下几个核心概念：</p><ol><li><p><strong>核函数（Kernel Function）</strong>：<br>核函数是运行在 GPU 上的函数。每个核函数通过大量的线程并行运行。CUDA 的并行模型允许开发者将计算任务划分为多个线程，所有线程可以同时执行核函数。</p></li><li><p><strong>线程（Thread）</strong>：<br>CUDA 中的每个线程是执行核函数的基本单位。数以千计的线程能够被 GPU 并行运行，从而大大提高运算效率。CUDA 线程组织在多个层次的结构中，如 <strong>线程块（Block）</strong> 和 <strong>网格（Grid）</strong>。</p></li><li><p><strong>线程块（Block）</strong> 和 <strong>网格（Grid）</strong>：</p><ul><li><strong>线程块</strong>：一组线程被组织成线程块。每个线程块中的线程可以共享一些本地的设备内存，并且可以进行同步操作。一个线程块最多可以包含 1024 个线程。</li><li><strong>网格</strong>：多个线程块组成一个网格。网格中的线程块可以独立运行，因此 CUDA 可以将庞大的计算任务分解到成千上万个线程块中。</li></ul></li></ol></blockquote><h3 id="查看对应版本"><a href="#查看对应版本" class="headerlink" title="查看对应版本"></a>查看对应版本</h3><p><a href="https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html">查询链接</a>中根据自己显卡版本选择合适的CUDA版本</p><p><img src="/images/Blog/Ubuntu软件安装/5.png" alt=""></p><p><img src="/images/Blog/Ubuntu软件安装/6.png" alt=""></p><p><code>nvidia-smi</code>查询驱动版本，我的驱动版本 <code>Driver Version: 535.183.01</code>，可以安装 CUDA Version 12.2</p><h3 id="下载CUDA"><a href="#下载CUDA" class="headerlink" title="下载CUDA"></a>下载CUDA</h3><p>到官网(<a href="https://developer.nvidia.com/cuda-toolkit-archive">CUDA Toolkit Archive | NVIDIA Developer</a>)根据自己的需要选择CUDA版本</p><p><img src="/images/Blog/Ubuntu软件安装/7.png" alt=""></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">wget https://developer.download.nvidia.com/compute/cuda/12.2.2/local_installers/cuda_12.2.2_535.104.05_linux.run</span></span><br></pre></td></tr></table></figure><h3 id="安装CUDA"><a href="#安装CUDA" class="headerlink" title="安装CUDA"></a>安装CUDA</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">sudo</span> sh cuda_12.2.2_535.104.05_linux.run</span></span><br></pre></td></tr></table></figure><ol><li><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6dc85544475499997e8606ed30ee875a.png" alt=""></p></li><li><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8eda00e88164002cb3ea78c2efcf45a7.png" alt=""></p></li><li><p>选择驱动，给他回车取消，因为我们已经有安装驱动了，然后移动到install安装<img src="https://i-blog.csdnimg.cn/blog_migrate/88b5eea6fad323b3c180aad8c14801f3.png" alt=""></p></li></ol><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">sudo</span> vim ~/.bashrc</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加以下内容：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt;&lt;&lt;<span class="string">cuda&lt;&lt;&lt;</span></span></span><br><span class="line">export PATH=&quot;/usr/local/cuda-12.1/bin:$PATH&quot;</span><br><span class="line">export LD_LIBRARY_PATH=&quot;/usr/local/cuda-12.1/lib64:$LD_LIBRARY_PATH&quot;</span><br></pre></td></tr></table></figure><h3 id="验证是否成功"><a href="#验证是否成功" class="headerlink" title="验证是否成功"></a>验证是否成功</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">source</span> ~/.bashrc    <span class="comment"># 更新环境变量</span></span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">nvcc -V</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我的输出：</span></span><br><span class="line">nvcc: NVIDIA (R) Cuda compiler driver</span><br><span class="line">Copyright (c) 2005-2023 NVIDIA Corporation</span><br><span class="line">Built on Mon_Apr__3_17:16:06_PDT_2023</span><br><span class="line">Cuda compilation tools, release 12.1, V12.1.105</span><br><span class="line">Build cuda_12.1.r12.1/compiler.32688072_0</span><br></pre></td></tr></table></figure><h2 id="安装pytorch"><a href="#安装pytorch" class="headerlink" title="安装pytorch"></a>安装pytorch</h2><h3 id="选择合适pytorch版本"><a href="#选择合适pytorch版本" class="headerlink" title="选择合适pytorch版本"></a>选择合适pytorch版本</h3><p><a href="https://pytorch.org/get-started/previous-versions/">pytorch官网</a>选择需要的版本</p><p><img src="/images/Blog/Ubuntu软件安装/8.png" alt=""></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以创建虚拟环境,装在这个虚拟环境中</span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">conda create --name pytorch_env python=3.11</span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">conda activate pytorch_env</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CUDA 12.1</span></span><br><span class="line"><span class="meta prompt_">(pytorch_env)~$ </span><span class="language-bash">conda install pytorch==2.3.1 torchvision==0.18.1 torchaudio==2.3.1 pytorch-cuda=12.1 -c pytorch -c nvidia</span></span><br></pre></td></tr></table></figure><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(pytorch_env)~$ </span><span class="language-bash">python -c <span class="string">&quot;import torch; print(torch.__version__)&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出对应版本则成功： 2.3.1</span></span><br></pre></td></tr></table></figure><hr><p>参考：</p><p><a href="https://blog.csdn.net/qq_34972053/article/details/127689332">【ubuntu环境配置】超详细ubuntu20.04/22.04安装nvidia驱动/CUDA/cudnn_ubuntu20安装nvidia显卡驱动-CSDN博客</a></p><p><a href="https://blog.csdn.net/sdbyp/article/details/139853774">Ubuntu 20.04安装显卡驱动、CUDA、Miniconda和Pytorch（2024.09最新）-Ubuntu从零搭建深度学习环境_ubuntu20.04安装显卡驱动-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu环境配置 </tag>
            
            <tag> pytorch </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu中安装配置anaconda</title>
      <link href="/2024/10/21/Linux/Ubuntu%E4%B8%AD%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEanaconda/"/>
      <url>/2024/10/21/Linux/Ubuntu%E4%B8%AD%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEanaconda/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>环境：Ubuntu20.04</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>从<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">Index of /anaconda/archive/ | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a>网站中下载所需要的软件包</p><p>以<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2024.06-1-Linux-x86_64.sh" title="Anaconda3-2024.06-1-Linux-x86_64.sh">Anaconda3-2024.06-1-Linux-x86_64.sh</a>为例</p><p>下载到想要安装的文件夹下:[~/software/anaconda3（我的位置）]（需要替换成你的位置）</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>ctl+alt+T 打开终端进入该文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">cd</span> [~/software/anaconda3（我的位置）]</span></span><br><span class="line">[~/software/anaconda3（我的位置）]$ bash Anaconda3-2024.06-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><p>不断回车，需要输入就输入yes</p><p>中途会需要选择安装目录</p><p><img src="/images/Blog/Ubuntu软件安装/1.png" alt=""></p><ul><li><p>Enter 默认在用户主目录下创建一个名为anaconda3的文件夹作为安装地址</p></li><li><p>我是输入 <code>/home/software/anaconda3</code> 安装在这个目录下</p></li></ul><p>安装成功：<br><img src="/images/Blog/Ubuntu软件安装/2.png" alt=""></p><h3 id="查看安装的包"><a href="#查看安装的包" class="headerlink" title="查看安装的包"></a>查看安装的包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(base)[~/software/anaconda3（我的位置）]$ conda list</span><br></pre></td></tr></table></figure><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(base)[~/software/anaconda3（我的位置）]$ cd ~</span><br><span class="line"><span class="meta prompt_">(base)~$ </span><span class="language-bash">vim .bashrc</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加以下内容：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&gt;&gt;&gt; conda initialize &gt;&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">!! Contents within this block are managed by <span class="string">&#x27;conda init&#x27;</span> !!</span></span><br><span class="line">__conda_setup=&quot;$(&#x27;[~/software/anaconda3（我的位置）]/bin/conda&#x27; &#x27;shell.bash&#x27; &#x27;hook&#x27; 2&gt; /dev/null)&quot;</span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">    eval &quot;$__conda_setup&quot;</span><br><span class="line">else</span><br><span class="line">    if [ -f &quot;[~/software/anaconda3（我的位置）]/etc/profile.d/conda.sh&quot; ]; then</span><br><span class="line">        . &quot;/home/leon/software/anaconda3/etc/profile.d/conda.sh&quot;</span><br><span class="line">    else</span><br><span class="line">        export PATH=&quot;[~/software/anaconda3（我的位置）]/bin:$PATH&quot;</span><br><span class="line">    fi</span><br><span class="line">fi</span><br><span class="line">unset __conda_setup</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt;&lt;&lt; <span class="string">conda initialize &lt;&lt;&lt;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">或者直接在根目录下 ctl+h 找到隐藏文件.bashrc添加以上内容</span></span></span><br><span class="line"><span class="meta prompt_">(base)~$ </span><span class="language-bash"><span class="string">source ~/.bashrc   # 使环境变量更改生效。</span></span></span><br></pre></td></tr></table></figure><h2 id="创建应用桌面图标"><a href="#创建应用桌面图标" class="headerlink" title="创建应用桌面图标"></a>创建应用桌面图标</h2><h3 id="创建图标文件"><a href="#创建图标文件" class="headerlink" title="创建图标文件"></a>创建图标文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(base)~$ </span><span class="language-bash"><span class="built_in">cd</span> .<span class="built_in">local</span>/share/applications</span></span><br></pre></td></tr></table></figure><blockquote><p><code>~/.local/share/applications</code>:用于存储当前用户的桌面应用程序相关信息。这个目录中的 <code>.desktop</code> 文件包含了用户特定的应用程序启动配置，例如应用程序的名称、图标、执行命令等。这些文件仅对当前用户有效，其他用户无法访问或影响这些配置。</p><p><code>/usr/share/applications/</code>:目录用于存储系统范围内的桌面应用程序配置文件。这些文件是针对所有用户的，因此无论哪个用户登录，都会看到这些应用程序。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(base)~/.local/share/applications$ vim anaconda.desktop</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">----------</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加以下内容</span></span><br><span class="line">[Desktop Entry]</span><br><span class="line">Name=Anaconda</span><br><span class="line">Version=2.5.2</span><br><span class="line">Type=Application</span><br><span class="line">Exec=[~/software/anaconda3（我的位置）]/bin/anaconda-navigator</span><br><span class="line">Icon=[~/software/anaconda3（我的位置）]/pkgs/anaconda-navigator-2.5.2-py311h06a4308_0/lib/python3.11/site-packages/anaconda_navigator/app/icons/Icon1024.png</span><br><span class="line">Terminal=false</span><br><span class="line">StartupNotify=true</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-----------</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保存退出</span></span><br></pre></td></tr></table></figure><h3 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(base)~/.local/share/applications$ sudo chmod a+x anaconda.desktop</span><br></pre></td></tr></table></figure><h2 id="修改Anaconda镜像"><a href="#修改Anaconda镜像" class="headerlink" title="修改Anaconda镜像"></a>修改Anaconda镜像</h2><p>由于外网限制，Anaconda 下载安装包很慢，可以使用国内镜像提高安装包下载速度。</p><p>清华镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/</span><br><span class="line">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br></pre></td></tr></table></figure><h3 id="修改镜像："><a href="#修改镜像：" class="headerlink" title="修改镜像："></a>修改镜像：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge </span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/</span><br></pre></td></tr></table></figure><h3 id="设置下载安装包显示源路径（可选）："><a href="#设置下载安装包显示源路径（可选）：" class="headerlink" title="设置下载安装包显示源路径（可选）："></a>设置下载安装包显示源路径（可选）：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure><h3 id="查看："><a href="#查看：" class="headerlink" title="查看："></a>查看：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">conda config --show</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">看到channels： xxx</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者</span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">cat</span> ./.condarc</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示：</span></span><br><span class="line">channels:</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">  - defaults</span><br></pre></td></tr></table></figure><h3 id="删除指定源"><a href="#删除指定源" class="headerlink" title="删除指定源"></a>删除指定源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --remove-key channels XXX</span><br></pre></td></tr></table></figure><h3 id="还原源文件"><a href="#还原源文件" class="headerlink" title="还原源文件"></a>还原源文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --remove-key channels</span><br></pre></td></tr></table></figure><h2 id="conda常用命令"><a href="#conda常用命令" class="headerlink" title="conda常用命令"></a>conda常用命令</h2><h3 id="环境管理"><a href="#环境管理" class="headerlink" title="环境管理"></a>环境管理</h3><h4 id="创建新环境"><a href="#创建新环境" class="headerlink" title="创建新环境"></a>创建新环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda create -n &lt;环境名&gt; python=&lt;版本号&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：创建一个名为 &quot;myenv&quot;，Python 版本为 3.9 的环境</span></span><br><span class="line"></span><br><span class="line">conda create -n myenv python=3.9</span><br></pre></td></tr></table></figure><h4 id="激活环境"><a href="#激活环境" class="headerlink" title="激活环境"></a>激活环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda activate &lt;环境名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：激活名为 &quot;myenv&quot; 的环境</span></span><br><span class="line"></span><br><span class="line">conda activate myenv</span><br></pre></td></tr></table></figure><h4 id="退出环境"><a href="#退出环境" class="headerlink" title="退出环境"></a>退出环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure><h4 id="删除环境"><a href="#删除环境" class="headerlink" title="删除环境"></a>删除环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conda remove -n &lt;环境名&gt; --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：删除名为 &quot;myenv&quot; 的环境</span></span><br><span class="line">conda remove -n myenv --all</span><br></pre></td></tr></table></figure><h3 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h3><h4 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda install &lt;包名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：安装 numpy</span></span><br><span class="line"></span><br><span class="line">conda install numpy</span><br></pre></td></tr></table></figure><h4 id="指定版本安装包"><a href="#指定版本安装包" class="headerlink" title="指定版本安装包"></a>指定版本安装包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda install &lt;包名&gt;=&lt;版本号&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：安装 numpy 的 1.21.0 版本</span></span><br><span class="line"></span><br><span class="line">conda install numpy=1.21.0</span><br></pre></td></tr></table></figure><h4 id="更新包"><a href="#更新包" class="headerlink" title="更新包"></a>更新包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda update &lt;包名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：更新 numpy 到最新版本</span></span><br><span class="line"></span><br><span class="line">conda update numpy</span><br></pre></td></tr></table></figure><h4 id="删除包"><a href="#删除包" class="headerlink" title="删除包"></a>删除包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda remove &lt;包名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：删除 numpy</span></span><br><span class="line"></span><br><span class="line">conda remove numpy</span><br></pre></td></tr></table></figure><h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><h4 id="查看已有环境"><a href="#查看已有环境" class="headerlink" title="查看已有环境"></a>查看已有环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda <span class="built_in">env</span> list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"></span><br><span class="line">conda info --envs</span><br></pre></td></tr></table></figure><h4 id="查看已安装的包"><a href="#查看已安装的包" class="headerlink" title="查看已安装的包"></a>查看已安装的包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看特定包的信息</span></span><br><span class="line"></span><br><span class="line">conda list &lt;包名&gt;</span><br></pre></td></tr></table></figure><h3 id="环境导出与还原"><a href="#环境导出与还原" class="headerlink" title="环境导出与还原"></a>环境导出与还原</h3><h4 id="导出环境"><a href="#导出环境" class="headerlink" title="导出环境"></a>导出环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda <span class="built_in">env</span> <span class="built_in">export</span> &gt; environment.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将当前环境导出到 environment.yml 文件</span></span><br></pre></td></tr></table></figure><h4 id="从文件创建环境"><a href="#从文件创建环境" class="headerlink" title="从文件创建环境"></a>从文件创建环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda <span class="built_in">env</span> create -f environment.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据 environment.yml 文件创建环境</span></span><br></pre></td></tr></table></figure><h4 id="environment-yml文件"><a href="#environment-yml文件" class="headerlink" title="environment.yml文件"></a>environment.yml文件</h4><p>用来管理和分享 Conda 环境的配置文件。定义了一个环境的名称、依赖包及其版本，方便用户快速创建、重现或共享环境。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="comment"># 定义环境的名字，如果没有 prefix:，Conda 会根据 name 将环境创建在默认路径下，通常是 &lt;conda安装路径&gt;/envs/&lt;name&gt;。</span></span><br><span class="line"><span class="attr">channels:</span> <span class="comment"># 指定安装依赖时使用的 Conda 仓库（渠道）</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">defaults</span></span><br><span class="line"><span class="attr">dependencies:</span> <span class="comment"># 列出该环境所需的依赖包及其版本</span></span><br><span class="line">  <span class="bullet">-</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">pip:</span> <span class="comment"># pip 下列出的包会通过 pip 而不是 Conda 安装</span></span><br><span class="line">    <span class="bullet">-</span> </span><br><span class="line"><span class="attr">prefix:</span> <span class="comment"># 指定环境的具体路径（绝对路径）。如果有 prefix: 字段，Conda 会忽略 name:，直接将环境安装到指定位置。对于跨系统使用，建议删除此字段以避免路径不兼容。</span></span><br></pre></td></tr></table></figure><h4 id="克隆环境"><a href="#克隆环境" class="headerlink" title="克隆环境"></a>克隆环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda create --name &lt;新环境名&gt; --<span class="built_in">clone</span> &lt;已有环境名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：克隆 &quot;myenv&quot; 环境为 &quot;newenv&quot;</span></span><br><span class="line"></span><br><span class="line">conda create --name newenv --<span class="built_in">clone</span> myenv</span><br></pre></td></tr></table></figure><h3 id="Conda-更新与清理"><a href="#Conda-更新与清理" class="headerlink" title="Conda 更新与清理"></a>Conda 更新与清理</h3><h4 id="更新-Conda-本身"><a href="#更新-Conda-本身" class="headerlink" title="更新 Conda 本身"></a>更新 Conda 本身</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update conda</span><br></pre></td></tr></table></figure><h4 id="更新所有包"><a href="#更新所有包" class="headerlink" title="更新所有包"></a>更新所有包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update --all</span><br></pre></td></tr></table></figure><h4 id="清理-Conda-缓存"><a href="#清理-Conda-缓存" class="headerlink" title="清理 Conda 缓存"></a>清理 Conda 缓存</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">conda clean --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选项说明：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --all：清除所有冗余文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --packages：清除未使用的包</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --tarballs：清除下载的压缩包</span></span><br></pre></td></tr></table></figure><h3 id="创建基于特定-Python-版本的环境"><a href="#创建基于特定-Python-版本的环境" class="headerlink" title="创建基于特定 Python 版本的环境"></a>创建基于特定 Python 版本的环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda create -n &lt;环境名&gt; python=&lt;版本号&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：创建一个 Python 3.8 的环境</span></span><br><span class="line"></span><br><span class="line">conda create -n py38 python=3.8</span><br></pre></td></tr></table></figure><h3 id="管理-Conda-虚拟环境中的-Pip"><a href="#管理-Conda-虚拟环境中的-Pip" class="headerlink" title="管理 Conda 虚拟环境中的 Pip"></a>管理 Conda 虚拟环境中的 Pip</h3><p>如果需要使用 <code>pip</code> 安装包，请在 Conda 环境中使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda install pip</span><br><span class="line"></span><br><span class="line">pip install &lt;包名&gt;</span><br></pre></td></tr></table></figure><h2 id="删除anaconda"><a href="#删除anaconda" class="headerlink" title="删除anaconda"></a>删除anaconda</h2><h3 id="删除相应的文件夹及文件"><a href="#删除相应的文件夹及文件" class="headerlink" title="删除相应的文件夹及文件"></a>删除相应的文件夹及文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(base)~$ </span><span class="language-bash"><span class="built_in">cd</span> [~/software（我的位置）]</span></span><br><span class="line">(base)[~/software（我的位置）]$ rm -rf anaconda3   # 删除所安装的目录文件夹</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以下操作是彻底删除</span></span><br><span class="line">(base)[~/software（我的位置）]$ cd ~</span><br><span class="line"><span class="meta prompt_">(base)~$ </span><span class="language-bash"><span class="built_in">rm</span> -rf ~/.anaconda ~/.conda</span></span><br></pre></td></tr></table></figure><h3 id="删除anaconda环境变量"><a href="#删除anaconda环境变量" class="headerlink" title="删除anaconda环境变量"></a>删除anaconda环境变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(base)~$ </span><span class="language-bash">vim .bashrc</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除以下内容：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&gt;&gt;&gt; conda initialize &gt;&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">!! Contents within this block are managed by <span class="string">&#x27;conda init&#x27;</span> !!</span></span><br><span class="line">__conda_setup=&quot;$(&#x27;[~/software/anaconda3（我的位置）]/bin/conda&#x27; &#x27;shell.bash&#x27; &#x27;hook&#x27; 2&gt; /dev/null)&quot;</span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">    eval &quot;$__conda_setup&quot;</span><br><span class="line">else</span><br><span class="line">    if [ -f &quot;[~/software/anaconda3（我的位置）]/etc/profile.d/conda.sh&quot; ]; then</span><br><span class="line">        . &quot;/home/leon/software/anaconda3/etc/profile.d/conda.sh&quot;</span><br><span class="line">    else</span><br><span class="line">        export PATH=&quot;[~/software/anaconda3（我的位置）]/bin:$PATH&quot;</span><br><span class="line">    fi</span><br><span class="line">fi</span><br><span class="line">unset __conda_setup</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt;&lt;&lt; <span class="string">conda initialize &lt;&lt;&lt;</span></span></span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><hr><p>参考：</p><p><a href="https://blog.csdn.net/thy0000/article/details/122878599">Ubuntu安装Anaconda详细步骤（Ubuntu21.10，Anaconda3）</a></p><p><a href="https://blog.csdn.net/KIK9973/article/details/118795049">Unbuntu卸载anaconda(最新最全亲测)_ubuntu卸载anaconda</a></p><p><a href="https://blog.csdn.net/guozhengxian123/article/details/130726596">Ubuntu——Anaconda环境配置及镜像修改_ubuntu 修改conda镜像-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu软件安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git基础</title>
      <link href="/2024/10/16/Git/Git%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/10/16/Git/Git%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Git-简介"><a href="#Git-简介" class="headerlink" title="Git 简介"></a>Git 简介</h1><p>Git 是一个分布式版本控制系统，广泛用于代码管理和协作开发。相比 SVN 等集中式版本控制系统，Git 具有更高效的分支管理、离线操作能力和强大的合并机制。</p><h2 id="Git工作区域和文件状态"><a href="#Git工作区域和文件状态" class="headerlink" title="Git工作区域和文件状态"></a>Git工作区域和文件状态</h2><h3 id="本地数据管理："><a href="#本地数据管理：" class="headerlink" title="本地数据管理："></a>本地数据管理：</h3><ul><li><p>工作区（本地工作目录（电脑目录）,如：<code>~/Documents/Study/Python$</code>）</p></li><li><p>暂存区（索引，用于保存即将提交到Git仓库的修改内容）</p></li><li><p>本地仓库（版本库，包含完整的项目历史和元数据，Git存储代码和版本信息）</p></li></ul><p>工作区<code>git add</code> —&gt; 暂存区<code>git commit</code> —&gt; 本地仓库</p><h3 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h3><p><code>git status</code>查看当前文件夹（<em>工作区</em>）的文件状态， untracked红色，committed绿色</p><ul><li><p>未跟踪untracked：新建的，未被Git管理</p></li><li><p>未修改：被Git管理</p></li></ul><h1 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h1><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><ul><li>下载地址：<a href="https://git-scm.com/">Git 官方网站</a></li><li>安装后在终端输入 <code>git --version</code> 验证安装</li></ul><h2 id="Linux（Ubuntu-Debian）"><a href="#Linux（Ubuntu-Debian）" class="headerlink" title="Linux（Ubuntu/Debian）"></a>Linux（Ubuntu/Debian）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install git</span><br></pre></td></tr></table></figure><h2 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure><h1 id="Git-基本配置"><a href="#Git-基本配置" class="headerlink" title="Git 基本配置"></a>Git 基本配置</h1><p>安装 Git 后，需要进行全局配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;你的名字&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;你的邮箱&quot;</span></span><br><span class="line"><span class="comment"># （可选）凭证会以明文形式保存到 ~/.git-credentials 文件中。</span></span><br><span class="line">git config --global credential.helper store <span class="comment"># 保存用户名和密码</span></span><br></pre></td></tr></table></figure><p>查看 Git 配置信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filter.lfs.smudge=git-lfs smudge -- %f</span><br><span class="line">filter.lfs.process=git-lfs filter-process</span><br><span class="line">filter.lfs.required=true</span><br><span class="line">filter.lfs.clean=git-lfs clean -- %f</span><br><span class="line">user.name=ShaoHLeon</span><br><span class="line">user.email=180xx</span><br><span class="line">creadential.helper=store</span><br></pre></td></tr></table></figure><blockquote><ol><li><p><strong>Git LFS（大文件存储）配置</strong></p><p>Git LFS 是 Git 用于管理大文件的扩展工具</p><ul><li><p><code>filter.lfs.smudge=git-lfs smudge -- %f</code>：<br>当从仓库中检出文件时，Git 会运行此命令来处理 LFS 文件。</p></li><li><p><code>filter.lfs.process=git-lfs filter-process</code>：<br>指定 Git LFS 的处理流程。</p></li><li><p><code>filter.lfs.required=true</code>：<br>表示此仓库必须使用 Git LFS，如果未安装 LFS，操作可能会失败。</p></li><li><p><code>filter.lfs.clean=git-lfs clean -- %f</code>：<br>当文件被添加到暂存区时，Git 会运行此命令来处理 LFS 文件。</p></li></ul></li><li><p><strong>用户信息</strong></p><ul><li><p><code>user.name=ShaoHLeon</code>：<br>提交代码时使用的用户名。</p></li><li><p><code>user.email=180xx</code>：<br>提交代码时使用的邮箱地址。</p></li></ul></li><li><p><strong>凭证（Credential）配置</strong></p><ul><li><code>creadential.helper=store</code>：<br>用于存储 Git 的凭证（如用户名和密码）。</li></ul></li></ol></blockquote><h1 id="Git-基本操作"><a href="#Git-基本操作" class="headerlink" title="Git 基本操作"></a>Git 基本操作</h1><h2 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h2><h3 id="本地创建"><a href="#本地创建" class="headerlink" title="本地创建"></a>本地创建</h3><p>在本地目录初始化一个 Git 仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>会在当前目录下创建一个<code>.git</code>文件夹，该文件夹是Git仓库核心，也标识着当前目录是一个Git仓库。</p><p><code>.git</code> 目录是 Git 仓库的元数据存储位置，包含所有的版本历史、分支信息、配置等。</p><h3 id="克隆远程服务器存在的仓库"><a href="#克隆远程服务器存在的仓库" class="headerlink" title="克隆远程服务器存在的仓库"></a>克隆远程服务器存在的仓库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;仓库地址&gt;</span><br></pre></td></tr></table></figure><h2 id="添加文件到暂存区"><a href="#添加文件到暂存区" class="headerlink" title="添加文件到暂存区"></a>添加文件到暂存区</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add 文件名  <span class="comment"># 添加指定文件</span></span><br><span class="line">git add .       <span class="comment"># 添加所有修改的文件</span></span><br></pre></td></tr></table></figure><h2 id="提交到本地仓库"><a href="#提交到本地仓库" class="headerlink" title="提交到本地仓库"></a>提交到本地仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;提交信息&quot;</span></span><br></pre></td></tr></table></figure><h2 id="连接远程仓库"><a href="#连接远程仓库" class="headerlink" title="连接远程仓库"></a>连接远程仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin 远程仓库地址</span><br></pre></td></tr></table></figure><h2 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin main  <span class="comment"># 推送到 main 分支</span></span><br></pre></td></tr></table></figure><h2 id="拉取最新代码"><a href="#拉取最新代码" class="headerlink" title="拉取最新代码"></a>拉取最新代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main</span><br></pre></td></tr></table></figure><h2 id="查看仓库的提交记录"><a href="#查看仓库的提交记录" class="headerlink" title="查看仓库的提交记录"></a>查看仓库的提交记录</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br><span class="line">git log --oneline # 查看简明的提交信息</span><br></pre></td></tr></table></figure><h2 id="查看暂存区的文件"><a href="#查看暂存区的文件" class="headerlink" title="查看暂存区的文件"></a>查看暂存区的文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files</span><br></pre></td></tr></table></figure><h2 id="删除仓库"><a href="#删除仓库" class="headerlink" title="删除仓库"></a>删除仓库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf .git</span><br></pre></td></tr></table></figure><p><strong>删除当前文件夹下的 <code>.git</code> 目录</strong>，而这个 <code>.git</code> 目录是 Git 仓库的核心部分。删除 <code>.git</code> 目录后，当前文件夹将不再是一个 Git 仓库，所有与 Git 相关的信息都会被清除。</p><h1 id="Git仓库目录结构"><a href="#Git仓库目录结构" class="headerlink" title="Git仓库目录结构"></a>Git仓库目录结构</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my-repo/</span><br><span class="line">├── .git/</span><br><span class="line">├── file1.txt</span><br><span class="line">├── file2.txt</span><br></pre></td></tr></table></figure><h1 id="Git-分支管理"><a href="#Git-分支管理" class="headerlink" title="Git 分支管理"></a>Git 分支管理</h1><h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch 分支名</span><br></pre></td></tr></table></figure><h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 分支名</span><br></pre></td></tr></table></figure><p>或者使用新版 Git 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git switch 分支名</span><br></pre></td></tr></table></figure><h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge 目标分支</span><br></pre></td></tr></table></figure><h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d 分支名</span><br></pre></td></tr></table></figure><h1 id="Git-版本回退"><a href="#Git-版本回退" class="headerlink" title="Git 版本回退"></a>Git 版本回退</h1><h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br></pre></td></tr></table></figure><h2 id="回退到某个版本"><a href="#回退到某个版本" class="headerlink" title="回退到某个版本"></a>回退到某个版本</h2><p><code>git reset --soft + &lt;版本ID&gt;</code> 保存工作区、暂存区;</p><p><code>git reset --hard + &lt;ID&gt;</code> 删除ID的工作区和暂存区的内容;</p><p><code>git reset --mixed + &lt;ID&gt;</code> (默认)保存工作区，删除暂存区;</p><p><code>git reflog</code> 查看操作的历史记录.</p><h1 id="查看文件差异git-diff"><a href="#查看文件差异git-diff" class="headerlink" title="查看文件差异git diff"></a>查看文件差异<code>git diff</code></h1><ul><li><p>比较工作区和暂存区的差异</p></li><li><p>比较工作区和版本库</p></li></ul><blockquote><p>红色文字表示删除的内容，绿色文字表示新增的内容</p></blockquote><p><code>git diff &lt;HEAD&gt;</code> 比较工作区暂存区和版本库</p><p><code>git diff --cached</code> 比较暂存区和版本库差异</p><p><code>git diff &lt;ID&gt; &lt;ID&gt;</code> 或者<code>git diff HEAD~(x) HEAD</code> 当前版本和第x版本比较</p><p><code>git diff HEAD~ HEAD &lt;file_name&gt;</code> 比较文件</p><h1 id="Git-忽略文件"><a href="#Git-忽略文件" class="headerlink" title="Git 忽略文件"></a>Git 忽略文件</h1><p>忽略不加入版本库中的文件</p><p>忽略文件包含：系统软件自动生成的文件、编译产生的中间文件、运行生成的日志文件、缓存文件、临时文件，敏感信息文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo access.log &gt; .gitignore     # 添加log文件</span><br><span class="line">cat .gitignore        # 查看</span><br><span class="line">echo &quot;内容&quot; &gt;&gt; other.log   # 追加内容 </span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo基础</title>
      <link href="/2024/10/15/Blog/Hexo%E5%9F%BA%E7%A1%80(%E6%9B%B4%E6%96%B0%E4%B8%AD)/"/>
      <url>/2024/10/15/Blog/Hexo%E5%9F%BA%E7%A1%80(%E6%9B%B4%E6%96%B0%E4%B8%AD)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>什么是Hexo？<br>Hexo 是一个快速、简洁且强大的博客框架。它基于 Node.js，使用 Markdown 语法编写文章，并可以通过多种主题、插件进行自定义。</p><h2 id="一、写作"><a href="#一、写作" class="headerlink" title="一、写作"></a>一、写作</h2><h3 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~/blog$ </span><span class="language-bash">hexo new [layout] &lt;title&gt;</span></span><br></pre></td></tr></table></figure><p>[layout]: </p><ul><li>post 文章(default) 在source/_posts</li><li>page 页面 在source</li><li>draft 草稿 在source/_drafts</li></ul><blockquote><p>可以通过编辑 _config.yml 文件中的 <code>default_layout</code> 参数来设置默认布局。</p></blockquote><h3 id="文章名字格式"><a href="#文章名字格式" class="headerlink" title="文章名字格式"></a>文章名字格式</h3><p>可以编辑 _config.yml 文件中的 <code>new_post_name</code> 参数来设置，默认为 <code>:title.md</code>。</p><div class="table-container"><table><thead><tr><th>Placeholder</th><th>描述</th></tr></thead><tbody><tr><td><code>:title</code></td><td>标题（小写，空格将会被替换为短杠）</td></tr><tr><td><code>:year</code></td><td>建立的年份，比如，2015</td></tr><tr><td><code>:month</code></td><td>建立的月份（有前导零），比如，04</td></tr><tr><td><code>:i_month</code></td><td>建立的月份（无前导零），比如，4</td></tr><tr><td><code>:day</code></td><td>建立的日期（有前导零），比如，07</td></tr><tr><td><code>:i_day</code></td><td>建立的日期（无前导零），比如，7</td></tr></tbody></table></div><h3 id="草稿draft"><a href="#草稿draft" class="headerlink" title="草稿draft"></a>草稿draft</h3><p><code>~/blog$ hexo new draft &lt;title&gt;</code> 创建草稿文章到 <code>source/_drafts</code> 文件夹内，可以使用 <code>~/blog$ hexo publish [layout] &lt;title&gt;</code> 命令将草稿文章移动到想要的layout（默认<code>_post</code>）中。</p><blockquote><p>默认情况下不显示草稿。您可以在运行Hexo时添加<code>--draft</code>选项，或者启用 _config. yml 中的<code>render_drafts</code>设置来渲染草稿。</p></blockquote><h3 id="Scaffolds-模板"><a href="#Scaffolds-模板" class="headerlink" title="Scaffolds(模板)"></a>Scaffolds(模板)</h3><p><strong>Scaffolds</strong>（模板）是用于定义新建页面、文章或草稿的默认结构的文件。当你使用 <code>hexo new</code> 命令创建新文章或页面时，Hexo 会根据 Scaffolds 中的模板生成相应的 Markdown 文件。这些模板包含了文章的基础结构，例如 Front-matter（YAML 头部信息）部分。</p><p>Scaffolds 模板文件位于 Hexo 项目的 <code>scaffolds</code> 目录中。默认情况下，Hexo 会提供以下几种模板：</p><ul><li><code>post.md</code>：用于创建新文章的模板。</li><li><code>page.md</code>：用于创建新页面的模板。</li><li><code>draft.md</code>：用于创建草稿的模板。</li></ul><p><img src="/images/Blog/Hexo/6.png" alt=""></p><p>如果你为某个页面创建了特定的 Scaffolds，例如 <code>mytemplate.md</code>，可以通过以下命令调用它：<code>hexo new mytemplate &quot;文章标题&quot;</code></p><p>这样会使用你自定义的 <code>mytemplate.md</code> 作为模板创建新的文章文件。</p><hr><p>参考：</p><p><a href="https://hexo.io/zh-cn/docs/writing">写作 | Hexo</a></p><p><a href="https://butterfly.zhheo.com/create.html">从零开始 | Butterfly主题美化教程</a></p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Font Awesome图标库的使用</title>
      <link href="/2024/10/15/Blog/Font%20Awesome%E5%9B%BE%E6%A0%87%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/10/15/Blog/Font%20Awesome%E5%9B%BE%E6%A0%87%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Butterfly主题配置文件中的 <code>menu:Home: / || fas fa-home</code> 是什么？如何获取所需要的图标？本文将介绍如何使用Font Awesome图标库。</p><blockquote><p>A: <code>fas</code> 是Font Awesome的图标前缀，<code>fa-home</code>是图标名称，所以 <code>fas fa-home</code> 就是Font Awesome图标库的图标。</p></blockquote><p><mark>注：</mark>主要针对Hexo的配置。</p><h2 id="Font-Awesome图标库"><a href="#Font-Awesome图标库" class="headerlink" title="Font Awesome图标库"></a>Font Awesome图标库</h2><p>Font Awesome 是一个非常流行的图标库，它提供了数以千计的矢量图标，可以在网页设计中轻松使用。Font Awesome 提供了多种图标样式，每种样式都有不同的前缀，用于在 HTML 或配置文件中引用特定的图标样式。</p><h3 id="Font-Awesome-的主要前缀"><a href="#Font-Awesome-的主要前缀" class="headerlink" title="Font Awesome 的主要前缀"></a>Font Awesome 的主要前缀</h3><ol><li><strong>Solid (<code>fas</code>)</strong><ul><li><strong>前缀</strong>: <code>fas</code></li><li><strong>描述</strong>: 实心风格的图标，适用于大多数常见用途。</li><li><strong>示例</strong>: <code>fas fa-music</code> （🎵）</li></ul></li><li><strong>Regular (<code>far</code>)</strong><ul><li><strong>前缀</strong>: <code>far</code></li><li><strong>描述</strong>: 边框风格的图标，通常用于表示较轻的视觉效果。</li><li><strong>示例</strong>: <code>far fa-music</code> （🎵）</li></ul></li><li><p><strong>Brands (<code>fab</code>)</strong></p><ul><li><strong>前缀</strong>: <code>fab</code></li><li><strong>描述</strong>: 品牌标志类图标，专门用于表示各种品牌和服务的标志。</li><li><strong>示例</strong>: <code>fab fa-weibo</code> （🐦）</li></ul></li><li><strong>Light (<code>fal</code>)</strong><ul><li><strong>前缀</strong>: <code>fal</code></li><li><strong>描述</strong>: 轻量风格的图标，适用于需要更细线条的设计（需要付费许可）。</li><li><strong>示例</strong>: <code>fal fa-music</code></li></ul></li><li><strong>Duotone (<code>fad</code>)</strong><ul><li><strong>前缀</strong>: <code>fad</code></li><li><strong>描述</strong>: 双色风格的图标，允许在一个图标中使用两种颜色（需要付费许可）。</li><li><strong>示例</strong>: <code>fad fa-music</code></li></ul></li></ol><h3 id="如何使用-Font-Awesome-图标库"><a href="#如何使用-Font-Awesome-图标库" class="headerlink" title="如何使用 Font Awesome 图标库"></a>如何使用 Font Awesome 图标库</h3><p>在 Hexo 的 Butterfly 主题中，Font Awesome 图标可以通过简短的标记直接引用。在配置菜单时，例如 <code>fas fa-home</code>，我们可以通过以下几个步骤找到需要的图标：</p><ol><li><p><strong>访问 Font Awesome 网站</strong><br>进入 Font Awesome 官网(<a href="https://fontawesome.com/icons">Find Icons with the Perfect Look &amp; Feel | Font Awesome</a>) 并使用搜索栏查找你需要的图标。你可以根据图标名称、风格或者用途进行搜索。</p></li><li><p><strong>选择合适的图标</strong><br>当你找到需要的图标时，页面会显示多个图标风格的选择，包括：</p><ul><li><strong>Solid（实心图标）</strong>：前缀为 <code>fas</code>，适用于大多数通用图标，提供清晰且醒目的视觉效果。</li><li><strong>Regular（边框图标）</strong>：前缀为 <code>far</code>，适用于需要较轻视觉效果的场景。</li><li><strong>Brands（品牌标志）</strong>：前缀为 <code>fab</code>，适用于各大社交平台、公司等品牌标志，如微博、Twitter、Facebook 等。</li></ul><p>选择你需要的风格，点击图标，即可看到使用代码。</p></li><li><p><strong>复制图标代码</strong><br>在图标页面的下方，找到类似 <code>fas fa-home</code> 的代码，将其复制到你的网站配置文件中。这里的 <code>fas</code> 表示这是一个实心风格的图标，<code>fa-home</code> 则是图标名称。</p></li><li><p><strong>配置到菜单中</strong><br>你可以将复制的代码直接放在 Hexo 配置文件中的菜单项后面，例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">Home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">Archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="attr">Categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder</span></span><br><span class="line">  <span class="attr">Social Media:</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-users</span></span><br><span class="line">  <span class="attr">Tools:</span> <span class="string">/tools/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-wrench</span></span><br></pre></td></tr></table></figure></li><li><p><strong>检查效果</strong><br>部署你的 Hexo 博客后，图标就会显示在对应的菜单项旁边。</p></li></ol><h3 id="常用图标示例"><a href="#常用图标示例" class="headerlink" title="常用图标示例"></a>常用图标示例</h3><p>以下是一些常用的 Font Awesome 图标及其代码示例，供你在配置中使用：</p><ul><li><strong>Home（主页图标）</strong>: <code>fas fa-home</code></li><li><strong>Archive（存档图标）</strong>: <code>fas fa-archive</code></li><li><strong>Folder（分类图标）</strong>: <code>fas fa-folder</code></li><li><strong>Users（社交图标）</strong>: <code>fas fa-users</code></li><li><strong>Wrench（工具图标）</strong>: <code>fas fa-wrench</code></li><li><strong>Book（学习相关图标）</strong>: <code>fas fa-book</code></li><li><strong>Music（音乐图标）</strong>: <code>fas fa-music</code></li><li><strong>Video（电影图标）</strong>: <code>fas fa-video</code></li><li><strong>Comments（评论图标）</strong>: <code>fas fa-comments</code></li></ul><p>你可以根据不同页面的功能，选择合适的图标，并将它们加入到菜单中。</p><hr><h2 id="添加-Font-Awesome-到-Hexo-主题"><a href="#添加-Font-Awesome-到-Hexo-主题" class="headerlink" title="添加 Font Awesome 到 Hexo 主题"></a>添加 Font Awesome 到 Hexo 主题</h2><p>确保你的 Hexo 主题支持 Font Awesome，如果没有，你可以手动添加 Font Awesome 到你的主题中。</p><h3 id="通过-CDN-引入"><a href="#通过-CDN-引入" class="headerlink" title="通过 CDN 引入"></a>通过 CDN 引入</h3><p>最简单的方法是通过 CDN 引入 Font Awesome，在你的主题的 <code>themes/butterfly/layout/_partial/head.ejs</code> 文件中，添加以下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="本地引入"><a href="#本地引入" class="headerlink" title="本地引入"></a>本地引入</h3><p>如果你希望本地引用 Font Awesome，也可以下载相关的字体文件并放置在 <code>themes/your-theme/source/css/</code> 目录下，并在 HTML 文件中引入本地的 CSS 文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/css/font-awesome.min.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="自定义菜单图标"><a href="#自定义菜单图标" class="headerlink" title="自定义菜单图标"></a>自定义菜单图标</h2><p>根据你的需求，你可以自定义菜单项的图标和名称。以下是一个完整的配置示例，它为不同分类添加了不同的图标：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">Home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">Archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="attr">Categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder</span></span><br><span class="line">  <span class="attr">Social Media:</span> <span class="string">/social/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-users</span></span><br><span class="line">  <span class="attr">Entertainment:</span></span><br><span class="line">    <span class="attr">Music:</span> <span class="string">/music/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-music</span></span><br><span class="line">    <span class="attr">Movies:</span> <span class="string">/movies/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-video</span></span><br><span class="line">  <span class="attr">Study:</span> <span class="string">/study/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-book</span></span><br><span class="line">  <span class="attr">Tools:</span> <span class="string">/tools/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-wrench</span></span><br><span class="line">  <span class="attr">Forums:</span> <span class="string">/forums/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-comments</span></span><br></pre></td></tr></table></figure><p>在这个示例中，<code>Home</code> 使用了一个房屋图标，<code>Music</code> 和 <code>Movies</code> 分别使用了音乐和视频的图标，<code>Tools</code> 则使用了扳手图标。</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> Tools </tag>
            
            <tag> Font Awesome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何记忆HTML</title>
      <link href="/2024/10/15/%E5%A6%82%E4%BD%95%E8%AE%B0%E5%BF%86HTML/"/>
      <url>/2024/10/15/%E5%A6%82%E4%BD%95%E8%AE%B0%E5%BF%86HTML/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="HTML标签记忆"><a href="#HTML标签记忆" class="headerlink" title="HTML标签记忆"></a>HTML标签记忆</h2><div class="table-container"><table><thead><tr><th>标签</th><th>英文</th><th>功能</th></tr></thead><tbody><tr><td>html</td><td>hypertext markup language</td><td>超文本标记语言，定义HTML文档</td></tr><tr><td>body</td><td>body</td><td>定义文档主题，可显示部分</td></tr><tr><td>h</td><td>heading</td><td>标题</td></tr><tr><td>段落:   </td></tr><tr><td>p</td><td>paragraph</td><td>段落</td></tr><tr><td>br</td><td>break</td><td>换行</td></tr><tr><td>hr</td><td>horizontal rule</td><td>定义水平分割线，用于分隔内容</td></tr><tr><td>文本格式化标签:</td></tr><tr><td>b</td><td>bold</td><td>将文本加粗</td></tr><tr><td>strong</td><td>strong</td><td>强调文本（通常呈现为加粗）</td></tr><tr><td>em</td><td>emphasis</td><td>强调文本（通常呈现为斜体）</td></tr><tr><td>i</td><td>italic</td><td>将文本斜体</td></tr><tr><td>sub</td><td>subscript</td><td>下标字</td></tr><tr><td>sup</td><td>superscript</td><td>上标字</td></tr><tr><td>ins</td><td>insert</td><td>插入字</td></tr><tr><td>del</td><td>delete</td><td>删除字</td></tr><tr><td>“计算机输出” 标签:</td></tr><tr><td>code</td><td>code</td><td>计算机输出的代码片段</td></tr><tr><td>kbd</td><td>keyboard</td><td>键盘输入,键盘码</td></tr><tr><td>tt</td><td>teletype</td><td>打字机文本</td></tr><tr><td>samp</td><td>sample</td><td>计算机代码样本</td></tr><tr><td>var</td><td>variable</td><td>计算机变量</td></tr><tr><td>pre</td><td>preformatted</td><td>预格式文本</td></tr><tr><td>引文, 引用, 及标签定义</td></tr><tr><td>abbr</td><td>abbreviation</td><td>定义缩写</td></tr><tr><td>address</td><td>address</td><td>定义地址信息</td></tr><tr><td>bdo</td><td>bidirectional override</td><td>定义文字方向</td></tr><tr><td>blockquote</td><td>blockquote</td><td>定义长的引用</td></tr><tr><td>q</td><td>quote</td><td>定义短的引用语</td></tr><tr><td>cite</td><td>citation</td><td>定义引用、引证</td></tr><tr><td>dfn</td><td>definition</td><td>定义一个定义项目</td></tr><tr><td>链接</td></tr><tr><td>a</td><td>anchor</td><td>锚点，超链接</td></tr><tr><td>头部</td></tr><tr><td>head</td><td>head</td><td>包含了所有的头部标签元素。</td></tr><tr><td>title</td><td>title</td><td>定义网页的标题，显示在浏览器标签页上</td></tr><tr><td>style</td><td>style</td><td>定义内部CSS样式，直接在HTML文档中编写样式</td></tr><tr><td>meta</td><td>metadata</td><td>定义元数据，如网页描述、关键词、字符编码等</td></tr><tr><td>link</td><td>link</td><td>定义外部资源链接，通常用于引入外部CSS或其他文件</td></tr><tr><td>script</td><td>script</td><td>定义客户端脚本，如JavaScript代码</td></tr><tr><td>noscript</td><td>no script</td><td>当浏览器不支持或禁用了JavaScript时显示的内容</td></tr><tr><td>base</td><td>base</td><td><a href="https://www.runoob.com/try/try.php?filename=tryhtml_base">定义页面上所有相对链接的基础URL</a></td></tr><tr><td>样式标签</td></tr><tr><td>style</td><td>style</td><td>定义内联样式，直接在HTML文档中编写样式</td></tr><tr><td>link</td><td>link</td><td><a href="https://www.runoob.com/try/try.php?filename=tryhtml_link">定义外部资源链接，通常用于引入外部CSS或其他文件</a></td></tr><tr><td>图片标签:</td></tr><tr><td>img</td><td>image</td><td>定义图像</td></tr><tr><td>map</td><td>map</td><td><a href="https://www.runoob.com/try/try.php?filename=tryhtml_areamap">定义一个图像映射，用于定义点击区域，并执行不同的操作。</a></td></tr><tr><td>area</td><td>area</td><td>定义图像映射中的区域，通常与 <code>&lt;map&gt;</code> 标签一起使用。</td></tr><tr><td>表格</td></tr><tr><td>table</td><td>table</td><td>定义表格</td></tr><tr><td>tr</td><td>table row</td><td>表示表格的一行</td></tr><tr><td>td</td><td>table data</td><td>表示表格的数据单元格</td></tr><tr><td>th</td><td>table header</td><td>表示表格的表头单元格</td></tr><tr><td>caption</td><td>caption</td><td>定义表格的标题</td></tr><tr><td>colgroup</td><td>column group</td><td>定义表格列的组</td></tr><tr><td>col</td><td>column</td><td>定义用于表格列的属性</td></tr><tr><td>thead</td><td>table head</td><td>定义表格的页眉部分</td></tr><tr><td>tbody</td><td>table body</td><td>定义表格的主体部分</td></tr><tr><td>tfoot</td><td>table footer</td><td>定义表格的页脚部分</td></tr><tr><td><a href="https://www.runoob.com/html/html-lists.html">列表</a></td></tr><tr><td>ul</td><td>unordered list</td><td>定义无序列表</td></tr><tr><td>ol</td><td>ordered list</td><td>定义有序列表</td></tr><tr><td>li</td><td>list item</td><td>表示列表中的项目</td></tr><tr><td>dl</td><td>definition list</td><td>自定义列表</td></tr><tr><td>dt</td><td>definition term</td><td>定义自定义列表中的项目</td></tr><tr><td>dd</td><td>definition description</td><td>定义自定义列表项的描述</td></tr><tr><td>区块</td></tr><tr><td>div</td><td>division</td><td>定义文档中的一个区块</td></tr><tr><td>span</td><td>span</td><td>定义行内区块</td></tr><tr><td>表单和输入</td></tr><tr><td>form</td><td>form</td><td>定义一个表单，用于用户输入数据</td></tr><tr><td>label</td><td>label</td><td>定义表单字段的标签，与 <code>&lt;input&gt;</code> 标签一起使用</td></tr><tr><td>select</td><td>select</td><td>定义下拉列表，用于从多个选项中选择一个值</td></tr><tr><td>input</td><td>input</td><td>定义用户输入的字段，如文本框、复选框、按钮等</td></tr><tr><td>option</td><td>option</td><td>定义下拉列表中的一个选项</td></tr><tr><td>textarea</td><td>text area</td><td>定义多行文本输入字段，通常用于长文本输入。</td></tr><tr><td>fieldset</td><td>field set</td><td><a href="https://www.runoob.com/try/try.php?filename=tryhtml_legend">定义表单字段集，通常用于将多个表单元素组合在一起，并添加样式。</a></td></tr><tr><td>legend</td><td>legend</td><td>定义表单字段集的标题，通常与 <code>&lt;fieldset&gt;</code> 标签一起使用。</td></tr><tr><td>outgroup</td><td>out group</td><td>定义一个输出字段，用于显示由脚本生成的内容。</td></tr><tr><td>button</td><td>button</td><td>定义一个按钮，用于触发脚本或提交表单。</td></tr><tr><td>datalist</td><td>data list</td><td>预先定义的输入控件选项列表，通常与 <code>&lt;input&gt;</code> 标签一起使用。</td></tr><tr><td>框架</td></tr><tr><td>iframe</td><td>inline frame</td><td>定义内嵌框架，即在当前页面中显示其他页面的内容。</td></tr><tr><td>脚本</td></tr><tr><td>script</td><td>script</td><td>定义客户端脚本，如JavaScript。</td></tr><tr><td>noscript</td><td>no script</td><td>当浏览器不支持或禁用了JavaScript时显示的内容。</td></tr><tr><td><a href="https://www.runoob.com/tags/ref-entities.html">字符实体</a></td></tr><tr><td>&nbsp;</td><td>non-breaking space</td><td>插入一个空格，但不换行。</td></tr><tr><td>&lt;</td><td>less than</td><td>小于号。</td></tr><tr><td>&gt;</td><td>greater than</td><td>大于号。</td></tr><tr><td>&amp;</td><td>ampersand</td><td>插入一个 <code>&amp;</code> 字符。</td></tr><tr><td>&quot;</td><td>quotation mark</td><td>插入一个双引号。</td></tr><tr><td>&apos;</td><td>apostrophe</td><td>插入一个单引号。</td></tr></tbody></table></div><hr><h2 id="HTML属性记忆"><a href="#HTML属性记忆" class="headerlink" title="HTML属性记忆"></a>HTML属性记忆</h2><p>属性：</p><ul><li>在元素中添加属性</li><li>描述于开始标签</li><li>以名字/值对形式出现</li></ul><div class="table-container"><table><thead><tr><th>属性</th><th>英文</th><th>功能</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/html/html-links.html">链接属性</a></td></tr><tr><td>href</td><td>hyperlink reference</td><td>指定超链接的目标地址</td></tr><tr><td>target</td><td>target</td><td>定义链接的打开方式</td></tr><tr><td>rel</td><td>relationship</td><td>定义链接与目标页面的关系，例如 <code>nofollow</code>, <code>noopener</code>, <code>noreferrer</code>。</td></tr><tr><td>nofollow</td><td>nofollow</td><td>告诉搜索引擎不跟踪该链接，常用于外部链接。</td></tr><tr><td>noopener</td><td>noopener</td><td>防止新页面访问 <code>window.opener</code> 属性，避免安全问题，通常与 <code>target=&quot;_blank&quot;</code> 配合使用。</td></tr><tr><td>noreferrer</td><td>noreferrer</td><td>不发送 <code>referer</code> header，防止目标页面知道你从哪里来。</td></tr><tr><td>download</td><td>download</td><td>提示浏览器下载链接的目标，而不是导航到该目标。</td></tr><tr><td>title</td><td>title</td><td>定义链接的额外信息，鼠标悬停时显示工具提示。</td></tr><tr><td>id</td><td>id</td><td>用于链接锚点，通常用于跳转到页面中的特定位置。</td></tr><tr><td>hreflang</td><td>hreflang</td><td>指定目标URL的语言。</td></tr><tr><td>type</td><td>type</td><td>指定链接资源的MIME类型，例如 <code>text/css</code>。</td></tr><tr><td>class</td><td>class</td><td>用于指定元素的类名，便于CSS样式的应用。</td></tr><tr><td>style</td><td>style</td><td>直接在元素上定义CSS样式。</td></tr><tr><td><a href="https://www.runoob.com/html/html-images.html">图像属性</a></td></tr><tr><td>src</td><td>source</td><td>指定外部资源的来源，如图片、视频、脚本等</td></tr><tr><td>alt</td><td>alternate</td><td>当图片无法显示时，提供的替代文本</td></tr><tr><td>width</td><td>width</td><td>指定图像的宽度，单位为像素</td></tr><tr><td>height</td><td>height</td><td>指定图像的高度，单位为像素</td></tr><tr><td>align</td><td>align</td><td>定义图像的垂直对齐方式，如 <code>left</code>, <code>right</code>, <code>center</code>。</td></tr><tr><td>表格属性</td></tr><tr><td>border</td><td>border</td><td>指定表格边框的宽度，单位为像素。</td></tr><tr><td>colspan</td><td>column span</td><td>定义单元格跨越的列数</td></tr><tr><td>rowspan</td><td>row span</td><td>定义单元格跨越的行数</td></tr><tr><td>cellspacing</td><td>cell spacing</td><td>指定单元格之间的间距，单位为像素。</td></tr><tr><td>cellpadding</td><td>cell padding</td><td>指定单元格内容与边框之间的间距，单位为像素。</td></tr><tr><td>表单属性</td></tr><tr><td>action</td><td>action</td><td>指定表单提交的目标URL，默认为当前页面。</td></tr><tr><td>method</td><td>method</td><td>指定表单提交的方式，如 <code>get</code>(default), <code>post</code>。</td></tr><tr><td>enctype</td><td>encoding type</td><td>定义表单数据在发送到服务器时的编码类型</td></tr><tr><td>name</td><td>name</td><td>定义表单的名称，用于提交数据时使用。</td></tr><tr><td>value</td><td>value</td><td>定义表单字段的默认值。</td></tr><tr><td>checked</td><td>checked</td><td>用于定义复选框或单选按钮的默认选中状态。</td></tr><tr><td>title</td><td>title</td><td>为元素提供提示信息，通常用于鼠标悬停时显示</td></tr><tr><td>id</td><td>identifier</td><td>为元素定义唯一的标识符，方便CSS、JavaScript引用</td></tr><tr><td>class</td><td>class</td><td>为元素定义一个或多个类名，通常用于CSS样式控制</td></tr><tr><td>type</td><td>type</td><td>指定元素的类型，如 <code>&lt;input&gt;</code> 标签的类型、脚本类型等</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基础语法</title>
      <link href="/2024/10/14/Markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/10/14/Markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe src="//player.bilibili.com/player.html?aid=327623069&bvid=BV1JA411h7Gw&cid=171385214&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>Markdown 是一种轻量级的标记语言，能够通过简单的标记符号来编写格式化文本。它的设计初衷是让文本既可以轻松阅读，又能够直接转换成 HTML，非常适合编写博客、文档和 README 文件。</p><hr><h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><ul><li><p><a href="https://markdown.com.cn/editor/">在线markdown编辑器_微信公众号markdown排版工具</a></p></li><li><p><a href="https://tool.lu/markdown/">markdown编辑器 - 在线工具</a></p></li><li><p>MarkText:</p><p><a href="https://www.bilibili.com/video/BV1J94y1V7tp?vd_source=59c9078be8272e804fcbbcf1da9a9f94">Markdown神器Marktext的安装与汉化</a></p></li></ul><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="标题（Headers）"><a href="#标题（Headers）" class="headerlink" title="标题（Headers）"></a>标题（Headers）</h3><p>使用 <code>#</code> 符号来定义标题，<code>#</code> 的个数代表标题的层级（从 <code>#</code> 到 <code>######</code>，依次为 1-6 级标题）。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br></pre></td></tr></table></figure><h3 id="段落（Paragraphs）"><a href="#段落（Paragraphs）" class="headerlink" title="段落（Paragraphs）"></a>段落（Paragraphs）</h3><ul><li><p>Markdown 中段落之间需要空一行，直接输入文字即可。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是一个段落。</span><br><span class="line"></span><br><span class="line">这是另一个段落。</span><br></pre></td></tr></table></figure><p>渲染效果：</p><p>这是一个段落。</p><p>这是另一个段落。</p></li><li><p>或者使用HTML语法</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span>这是另一种方法的一个段落。<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>渲染效果：</p><p>这是另一种方法的一个段落。</p></li><li><p>换行</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul><h3 id="强调（Emphasis）"><a href="#强调（Emphasis）" class="headerlink" title="强调（Emphasis）"></a>强调（Emphasis）</h3><p>可以使用星号 <code>*</code> 或下划线 <code>_</code> 来进行文字的强调。</p><ul><li><em>斜体</em>：使用一个星号或下划线包裹文字。</li><li><strong>加粗</strong>：使用两个星号或下划线包裹文字。</li><li><strong><em>加粗并斜体</em></strong>：使用三个星号或下划线包裹文字。</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*斜体*</span></span><br><span class="line"><span class="strong">**加粗**</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*加粗并斜体*</span>**</span></span><br></pre></td></tr></table></figure><p>渲染效果：</p><p><em>斜体</em><br><strong>加粗</strong><br><strong><em>加粗并斜体</em></strong></p><h3 id="删除线（Strikethrough）"><a href="#删除线（Strikethrough）" class="headerlink" title="删除线（Strikethrough）"></a>删除线（Strikethrough）</h3><p>使用两个波浪线 <code>~~</code> 包裹文字。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><p>渲染效果：</p><p><del>删除线</del></p><h3 id="下划线（Underline）"><a href="#下划线（Underline）" class="headerlink" title="下划线（Underline）"></a>下划线（Underline）</h3><p>使用 <code>&lt;u&gt;</code> 标签包裹文字。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>渲染效果：</p><p><u>下划线</u></p><h3 id="列表（Lists）"><a href="#列表（Lists）" class="headerlink" title="列表（Lists）"></a>列表（Lists）</h3><p>有序列表和无序列表的创建也非常简单。</p><h4 id="无序列表："><a href="#无序列表：" class="headerlink" title="无序列表："></a><strong>无序列表</strong>：</h4><p>使用 <code>*</code>、<code>+</code> 或 <code>-</code> 表示无序列表。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 项目一</span><br><span class="line"><span class="bullet">-</span> 项目二</span><br><span class="line"><span class="bullet">-</span> 项目三</span><br></pre></td></tr></table></figure><p>渲染效果：</p><ul><li>项目一</li><li>项目二</li><li>项目三</li></ul><h4 id="有序列表："><a href="#有序列表：" class="headerlink" title="有序列表："></a><strong>有序列表</strong>：</h4><p>使用数字加句点 <code>.</code> 表示有序列表。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 第一项</span><br><span class="line"><span class="bullet">2.</span> 第二项</span><br><span class="line"><span class="bullet">3.</span> 第三项</span><br></pre></td></tr></table></figure><p>渲染效果：</p><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><h3 id="链接（Links）"><a href="#链接（Links）" class="headerlink" title="链接（Links）"></a>链接（Links）</h3><p>可以通过方括号 <code>[]</code> 包含显示文本，后跟圆括号 <code>()</code> 包含链接地址的方式创建链接。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">百度</span>](<span class="link">https://www.baidu.com</span>)</span><br></pre></td></tr></table></figure><p>渲染效果：<br><a href="https://www.baidu.com">百度</a></p><h3 id="图片（Images）"><a href="#图片（Images）" class="headerlink" title="图片（Images）"></a>图片（Images）</h3><p>插入图片的语法与链接类似，前面多加一个感叹号 <code>!</code>。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">图片描述</span>](<span class="link">图片链接</span>)</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">示例图片</span>](<span class="link">https://via.placeholder.com/150</span>)</span><br></pre></td></tr></table></figure><p>渲染效果：<br><img src="https://via.placeholder.com/150" alt="示例图片"></p><h3 id="引用（Blockquotes）"><a href="#引用（Blockquotes）" class="headerlink" title="引用（Blockquotes）"></a>引用（Blockquotes）</h3><p>使用 <code>&gt;</code> 表示引用。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 这是一个引用。</span></span><br></pre></td></tr></table></figure><p>渲染效果：</p><blockquote><p>这是一个引用。</p></blockquote><h3 id="代码块（Code-Blocks）"><a href="#代码块（Code-Blocks）" class="headerlink" title="代码块（Code Blocks）"></a>代码块（Code Blocks）</h3><p>单行代码使用反引号 <code>` </code> 包裹，代码块则用三个反引号包裹，并可以指定语言。</p><p><strong>单行代码</strong>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`print(&quot;Hello, World!&quot;)`</span></span><br></pre></td></tr></table></figure><p>渲染效果：<br><code>print(&quot;Hello, World!&quot;)</code></p><p><strong>多行代码</strong>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">```python</span></span><br><span class="line"><span class="code">def hello():</span></span><br><span class="line"><span class="code">    print(&quot;Hello, World!&quot;)</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">渲染效果：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">def hello():</span><br><span class="line">    print(&quot;Hello, World!&quot;)</span><br></pre></td></tr></table></figure><h3 id="表格（Tables）"><a href="#表格（Tables）" class="headerlink" title="表格（Tables）"></a>表格（Tables）</h3><p>使用管道符号 <code>|</code> 创建表格，使用短横线 <code>-</code> 来分隔表头和内容。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 名字   | 年龄 |</span><br><span class="line">|--------|------|</span><br><span class="line">| 小明   | 18   |</span><br><span class="line">| 小红   | 20   |</span><br></pre></td></tr></table></figure><p>渲染效果：</p><div class="table-container"><table><thead><tr><th>名字</th><th>年龄</th></tr></thead><tbody><tr><td>小明</td><td>18</td></tr><tr><td>小红</td><td>20</td></tr></tbody></table></div><p>管道字符 <code>|</code></p><ul><li><p>定义列的边界</p></li><li><p>第一行通常是表头，第二行是用短横线 (-) 来定义表格的结构（并且同样使用管道符号来分隔列）。</p></li><li><p>每个单元格的内容可以有不同的对齐方式。</p><blockquote><p>对齐方式<br>你可以通过在短横线旁边添加 : 来定义表格中列的对齐方式：</p><ul><li>:—- 表示左对齐</li><li>—-: 表示右对齐</li><li>:—-: 表示居中对齐</li></ul></blockquote></li></ul><h3 id="分割线（Horizontal-Rules）"><a href="#分割线（Horizontal-Rules）" class="headerlink" title="分割线（Horizontal Rules）"></a>分割线（Horizontal Rules）</h3><p>使用三个或更多的 <code>-</code>、<code>*</code> 或 <code>_</code> 产生分割线。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">---</span><br></pre></td></tr></table></figure><p>渲染效果：</p><hr><h3 id="逃逸字符（Escaping-Characters）"><a href="#逃逸字符（Escaping-Characters）" class="headerlink" title="逃逸字符（Escaping Characters）"></a>逃逸字符（Escaping Characters）</h3><p>如果想在 Markdown 中显示特殊字符，可以在字符前面加上反斜杠 <code>\</code> 来进行转义。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\<span class="emphasis">*这是一段没有被加粗的文字\*</span></span><br></pre></td></tr></table></figure><p>渲染效果：<br>*这是一段没有被加粗的文字*</p><h3 id="任务列表（Task-Lists）"><a href="#任务列表（Task-Lists）" class="headerlink" title="任务列表（Task Lists）"></a>任务列表（Task Lists）</h3><p>使用 <code>- [ ]</code> 表示未完成的任务，<code>- [x]</code> 表示已完成的任务。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> [x] 已完成的任务</span><br><span class="line"><span class="bullet">-</span> [ ] 未完成的任务</span><br></pre></td></tr></table></figure><p>渲染效果：</p><ul><li><p>[x] 已完成的任务</p></li><li><p>[ ] 未完成的任务</p></li></ul><h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h3><p>可以使用HTML语言</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">mark</span>&gt;</span></span>这是高亮部分<span class="language-xml"><span class="tag">&lt;/<span class="name">mark</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><mark>这是高亮部分</mark></p><h3 id="锚点（超链接）"><a href="#锚点（超链接）" class="headerlink" title="锚点（超链接）"></a>锚点（超链接）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#创建锚点</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&#x27;bookmark&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="section"># 添加跳转链接</span></span><br><span class="line">[<span class="string">跳转到锚点</span>](<span class="link">#bookmark</span>)</span><br></pre></td></tr></table></figure><hr><p>参考：</p><p><a href="https://www.bilibili.com/video/BV1JA411h7Gw?vd_source=59c9078be8272e804fcbbcf1da9a9f94"><strong>八分钟快速掌握Markdown</strong></a></p><p><a href="https://www.bilibili.com/video/BV17r4y1E7cM?vd_source=59c9078be8272e804fcbbcf1da9a9f94"><strong>MarkText使用</strong></a></p><p>官方教程</p><ul><li><p><a href="https://markdown.com.cn/basic-syntax/"><strong>基本语法</strong></a></p></li><li><p><a href="https://markdown.com.cn/cheat-sheet.html"><strong>Markdown语法速成</strong></a></p></li><li><p><a href="https://markdown.com.cn/cheat-sheet.html#%E6%89%A9%E5%B1%95%E8%AF%AD%E6%B3%95"><strong>扩展语法</strong></a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AppImage文件</title>
      <link href="/2024/10/11/Linux/AppImage%E6%96%87%E4%BB%B6/"/>
      <url>/2024/10/11/Linux/AppImage%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是AppImage？"><a href="#什么是AppImage？" class="headerlink" title="什么是AppImage？"></a>什么是AppImage？</h2><p><strong>AppImage</strong> 是一种用于在 Linux 上分发应用程序的便携式<mark>打包格式</mark>。与传统的 Linux 软件包（如 <strong>.deb</strong>、<strong>.rpm</strong>）不同，AppImage 是一个自包含的应用程序，打包了所有应用所需的依赖库和文件，允许用户<mark>无需安装</mark>即可运行应用程序。</p><p>以AppImage打包的应用程式，需要的依赖套件都包在一起，下载就是单一档案，点二下就可以执行，不需要安装，也无需考量不同Linux发行版的差异。</p><p>特点：</p><ul><li><p><strong>无需安装</strong>：<br>AppImage 文件不需要安装或管理员权限。下载后，你只需赋予可执行权限，然后直接运行它。它不会改变系统文件或安装额外的依赖库。</p></li><li><p><strong>便携性</strong>：<br>AppImage 文件是自包含的，这意味着它打包了应用程序及其所需的所有依赖项。你可以将它复制到任何地方（USB 驱动器、云盘等），在不同的 Linux 发行版上运行，而不需要重新安装或配置。</p></li><li><p><strong>无依赖性问题</strong>：<br>因为 AppImage 打包了应用所需的所有库和依赖项，用户不必担心库版本冲突或依赖关系未满足的问题。</p></li><li><p><strong>版本独立</strong>：<br>AppImage 文件可以运行在大多数 Linux 发行版上，而不依赖于特定的发行版或版本。你可以在 Ubuntu、Fedora、Arch 等多种发行版上运行相同的 AppImage 文件。</p></li><li><p><strong>不改变系统文件</strong>：<br>AppImage 不会修改系统库或系统目录，也不会安装或升级系统上的其他软件，因此不会破坏现有的系统设置。</p></li><li><p><strong>自动更新和桌面集成</strong>：<br>虽然 AppImage 不会自动安装，但某些 AppImage 文件可以通过第三方工具实现自动更新功能，并与桌面环境进行集成，生成菜单项和快捷方式。</p></li></ul><h2 id="如何安装？"><a href="#如何安装？" class="headerlink" title="如何安装？"></a>如何安装？</h2><p>AppImage 文件通常可以在应用程序官方网站或 <a href="https://www.appimagehub.com/">AppImageHub</a>（一个集中提供 AppImage 文件的网站）下载。</p><ul><li><p><em>方法一</em>：右击.AppImage文件 -&gt; 点击properties -&gt; 点击permissions -&gt; ‘Allow executing file as program’ -&gt; 双击该文件即可</p></li><li><p><em>方法二</em>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~(文件所在目录)$ chmod +x 文件名.AppImage   # 修改文件权限为可执行文件</span><br></pre></td></tr></table></figure></li></ul><h2 id="创建软件快捷方式"><a href="#创建软件快捷方式" class="headerlink" title="创建软件快捷方式"></a>创建软件快捷方式</h2><p>当执行该AppImage文件后，可以在’/tmp’文件夹中查看相关整个文件包（ctl+h显示出来）从中可以提取相关desktop文件和icon。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/share/applications</span><br><span class="line">或者 </span><br><span class="line">cd ~/.local/share/applications</span><br><span class="line">sudo vim 文件名.desktop</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输入以下内容</span></span><br><span class="line">[Desktop Entry]</span><br><span class="line">Name=</span><br><span class="line">Comment=</span><br><span class="line">Exec=            # .AppImage文件路径</span><br><span class="line">Icon=            # icon路径</span><br><span class="line">Type=Application</span><br><span class="line">StartupNotify=true</span><br><span class="line">Categories=Application;</span><br></pre></td></tr></table></figure><h2 id="如何删除AppImage？"><a href="#如何删除AppImage？" class="headerlink" title="如何删除AppImage？"></a>如何删除AppImage？</h2><p>只需要删除.AppImage文件和<code>~/.local/share/applications</code>or<code>/usr/share/applications</code>中相关的.desktop文件</p><hr><p>参考：</p><p><a href="https://ivonblog.com/posts/linux-appimage-introduction/">Linux AppImage軟體格式安裝方法</a></p><p><a href="https://www.bilibili.com/video/BV1x5411m7eH?vd_source=59c9078be8272e804fcbbcf1da9a9f94">appimage的一些知识</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Butterfly主题+Github搭建自己的博客</title>
      <link href="/2024/10/11/Blog/Hexo+Butterfly%E4%B8%BB%E9%A2%98+Github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
      <url>/2024/10/11/Blog/Hexo+Butterfly%E4%B8%BB%E9%A2%98+Github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本人设备及工具: 20.04-Ubuntu、 Marktext（markdown编辑器）、 Hexo(hexo-cli: 4.3.2)、 Git</p><hr><h2 id="一、安装Node-js"><a href="#一、安装Node-js" class="headerlink" title="一、安装Node.js"></a>一、安装Node.js</h2><ol><li><p>方式一：Ubuntu apt-get 命令安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install nodejs</span><br><span class="line">sudo apt-get install npm</span><br></pre></td></tr></table></figure></li><li><p>方式二: 二进制源码安装<br>官网：(<a href="https://nodejs.org/en/download/prebuilt-binaries">https://nodejs.org/en/download/prebuilt-binaries</a>)<br><img src="/images/Blog/Hexo/1.png" alt=""></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar xf  node-v20.18.0-linux-x64.tar.xz       # 解压</span><br><span class="line">cd node-v20.18.0-linux-x64/</span><br><span class="line">./bin/node -v                   # 执行node命令 查看版本 v20.18.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">建立软链接</span></span><br><span class="line">ln -s ./bin/npm   /usr/local/bin/ </span><br><span class="line">ln -s ./bin/node   /usr/local/bin/         </span><br></pre></td></tr></table></figure></li><li><p>版本更新<br>安装 Hexo 博客的时候提示 nodejs 版本过低</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">node -v    <span class="comment"># 查看版本</span></span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">sudo</span> npm install n -g  <span class="comment"># 下载用于更新nodejs版本工具</span></span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">sudo</span> n stable     <span class="comment"># 安装最新稳定版本</span></span></span><br></pre></td></tr></table></figure></li></ol><h2 id="二、安装Hexo"><a href="#二、安装Hexo" class="headerlink" title="二、安装Hexo"></a>二、安装Hexo</h2><p>官网：<a href="https://hexo.io/zh-cn/">Hexo</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">npm config <span class="built_in">set</span> registry https://registry.npmmirror.com <span class="comment">#将npm源替换为阿里的镜像。之后的安装就会迅速很多了。</span></span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">npm install hexo-cli -g   <span class="comment"># hexo-cli 是 hexo的指令集</span></span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">hexo init blog         <span class="comment"># ‘blog’ 可替换成自己想取的名字</span></span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">cd</span> blog</span></span><br><span class="line"><span class="meta prompt_">~/blog$ </span><span class="language-bash">npm install        <span class="comment"># 时间较长</span></span></span><br><span class="line"><span class="meta prompt_">~/blog$ </span><span class="language-bash">hexo server        <span class="comment"># 本地打开博客</span></span></span><br></pre></td></tr></table></figure><h2 id="三、安装配置Butterfly主题"><a href="#三、安装配置Butterfly主题" class="headerlink" title="三、安装配置Butterfly主题"></a>三、安装配置Butterfly主题</h2><p>网站：(<a href="https://github.com/jerryc127/hexo-theme-butterfly">https://github.com/jerryc127/hexo-theme-butterfly</a>)</p><ol><li><p>下载<br>1.1 Git克隆</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~/blog$ </span><span class="language-bash">git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span></span><br></pre></td></tr></table></figure><p>1.2 若网络问题，可以直接将整个文件下载到<code>~/blog/themes/butterfly</code>中</p></li><li><p>修改配置文件</p><blockquote><p>可以使用Vscode</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~/blog$ </span><span class="language-bash">vim _config.yml</span></span><br></pre></td></tr></table></figure><p><img src="/images/Blog/Hexo/2.png" alt=""><br>修改主题为<code>butterfly</code>并保存退出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~/blog$ </span><span class="language-bash">hexo s</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果出现 extends includes/layout.pug block content include ./includes/mixins/post-ui.pug <span class="comment">#recent-posts.recent-posts +postUI include includes/pagination.pug错误，未安装相关渲染器</span></span></span><br><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus # 时间较长，我是半小时</span><br></pre></td></tr></table></figure></blockquote></li></ol><h2 id="四、本地部署到GitHub"><a href="#四、本地部署到GitHub" class="headerlink" title="四、本地部署到GitHub"></a>四、本地部署到GitHub</h2><ol><li><p>新建github仓库<br>1.1 注册登陆<a href="https://github.com/">GitHub</a><br>1.2 新建仓库，仓库名字：username.github.io (username是你的github账号名)<br><img src="/images/Blog/Hexo/3.png" alt=""><br><img src="/images/Blog/Hexo/4.png" alt=""></p></li><li><p>配置hexo部署插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~/blog$ </span><span class="language-bash">npm install hexo-deployer-git --save</span></span><br></pre></td></tr></table></figure></li><li><p>修改_config.yml配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~/blog$ </span><span class="language-bash">vim _config.yml</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加以下内容</span></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/username/username.github.io.git</span><br><span class="line">  branch: main</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/images/Blog/Hexo/5.png" alt=""></p></li><li><p>部署到GitHub</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~/blog$ </span><span class="language-bash">hexo clean</span></span><br><span class="line"><span class="meta prompt_">~/blog$ </span><span class="language-bash">hexo generate</span></span><br><span class="line"><span class="meta prompt_">~/blog$ </span><span class="language-bash">hexo deploy</span></span><br></pre></td></tr></table></figure></li><li><p>访问<br>username.github.io (username是你的github账号名)</p></li></ol><hr><p>参考：</p><p><a href="https://www.runoob.com/nodejs/nodejs-install-setup.html">Node.js 安装配置 | 菜鸟教程</a></p><p><a href="https://blog.csdn.net/zzq0523/article/details/122910368">Ubuntu升级nodejs版本_ubuntu nodejs升级-CSDN博客</a></p><p><a href="https://www.bilibili.com/video/BV1q741167PJ?p=2&amp;vd_source=59c9078be8272e804fcbbcf1da9a9f94">Hexo搭建个人博客——系列教程</a></p><p><a href="https://www.laodengai.com/hexo-butterfly-github-blog-20240318/">Hexo+Butterfly主题+Github搭建博客 | 老登AI</a></p><p><a href="https://akilar.top/posts/6ef63e2d/">Win10:Hexo+github搭建个人博客</a></p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* @font-face {  font-family: Candyhome;  src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/Candyhome.ttf);  font-display: swap;  font-weight: lighter;} */@font-face {    font-family: ZhuZiAYuanJWD;    src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/ZhuZiAWan.woff2);    font-display: swap;    font-weight: lighter;  }    div#menus {    font-family: "ZhuZiAYuanJWD";  }  h1#site-title {    font-family: ZhuZiAYuanJWD;    font-size: 3em !important;  }  a.article-title,  a.blog-slider__title,  a.categoryBar-list-link,  h1.post-title {    font-family: ZhuZiAYuanJWD;  }    .iconfont {    font-family: "iconfont" !important;    font-size: 3em;    /* 可以定义图标大小 */    font-style: normal;    -webkit-font-smoothing: antialiased;    -moz-osx-font-smoothing: grayscale;  }    /* 时间轴生肖icon */  svg.icon {    /* 这里定义svg.icon，避免和Butterfly自带的note标签冲突 */    width: 1em;    height: 1em;    /* width和height定义图标的默认宽度和高度*/    vertical-align: -0.15em;    fill: currentColor;    overflow: hidden;  }    .icon-zhongbiao::before {    color: #f7c768;  }    /* bilibli番剧插件 */  #article-container .bangumi-tab.bangumi-active {    background: var(--anzhiyu-theme);    color: var(--anzhiyu-ahoverbg);    border-radius: 10px;  }  a.bangumi-tab:hover {    text-decoration: none !important;  }  .bangumi-button:hover {    background: var(--anzhiyu-theme) !important;    border-radius: 10px !important;    color: var(--anzhiyu-ahoverbg) !important;  }  a.bangumi-button.bangumi-nextpage:hover {    text-decoration: none !important;  }  .bangumi-button {    padding: 5px 10px !important;  }    a.bangumi-tab {    padding: 5px 10px !important;  }  svg.icon.faa-tada {    font-size: 1.1em;  }  .bangumi-info-item {    border-right: 1px solid #f2b94b;  }  .bangumi-info-item span {    color: #f2b94b;  }  .bangumi-info-item em {    color: #f2b94b;  }    /* 解决artitalk的图标问题 */  #uploadSource > svg {    width: 1.19em;    height: 1.5em;  }    /*top-img黑色透明玻璃效果移除，不建议加，除非你执着于完全一图流或者背景图对比色明显 */  #page-header:not(.not-top-img):before {    background-color: transparent !important;  }    /* 首页文章卡片 */  #recent-posts > .recent-post-item {    background: rgba(255, 255, 255, 0.9);  }    /* 首页侧栏卡片 */  #aside-content .card-widget {    background: rgba(255, 255, 255, 0.9);  }    /* 文章页面正文背景 */  div#post {    background: rgba(255, 255, 255, 0.9);  }    /* 分页页面 */  div#page {    background: rgba(255, 255, 255, 0.9);  }    /* 归档页面 */  div#archive {    background: rgba(255, 255, 255, 0.9);  }    /* 标签页面 */  div#tag {    background: rgba(255, 255, 255, 0.9);  }    /* 分类页面 */  div#category {    background: rgba(255, 255, 255, 0.9);  }    /*夜间模式伪类遮罩层透明*/  [data-theme="dark"] #recent-posts > .recent-post-item {    background: #121212;  }    [data-theme="dark"] .card-widget {    background: #121212 !important;  }    [data-theme="dark"] div#post {    background: #121212 !important;  }    [data-theme="dark"] div#tag {    background: #121212 !important;  }    [data-theme="dark"] div#archive {    background: #121212 !important;  }    [data-theme="dark"] div#page {    background: #121212 !important;  }    [data-theme="dark"] div#category {    background: #121212 !important;  }    [data-theme="dark"] div#category {    background: transparent !important;  }  /* 页脚透明 */  #footer {    background: transparent !important;  }    /* 头图透明 */  #page-header {    background: transparent !important;  }    #rightside > div > button {    border-radius: 5px;  }    /* 滚动条 */    ::-webkit-scrollbar {    width: 10px;    height: 10px;  }    ::-webkit-scrollbar-thumb {    background-color: #3b70fc;    border-radius: 2em;  }    ::-webkit-scrollbar-corner {    background-color: transparent;  }    ::-moz-selection {    color: #fff;    background-color: #3b70fc;  }    /* 音乐播放器 */    /* .aplayer .aplayer-lrc {    display: none !important;  } */    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {    left: -66px !important;    transition: all 0.3s;    /* 默认情况下缩进左侧66px，只留一点箭头部分 */  }    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {    left: 0 !important;    transition: all 0.3s;    /* 鼠标悬停是左侧缩进归零，完全显示按钮 */  }    .aplayer.aplayer-fixed {    z-index: 999999 !important;  }    /* 评论框  */  .vwrap {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 30px 0px;  }    /* 设置评论框 */    .vcard {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 0px 0px;  }    /* md网站下划线 */  #article-container a:hover {    text-decoration: none !important;  }    #article-container #hpp_talk p img {    display: inline;  }    /* 404页面 */  #error-wrap {    position: absolute;    top: 40%;    right: 0;    left: 0;    margin: 0 auto;    padding: 0 1rem;    max-width: 1000px;    transform: translate(0, -50%);  }    #error-wrap .error-content {    display: flex;    flex-direction: row;    justify-content: center;    align-items: center;    margin: 0 1rem;    height: 18rem;    border-radius: 8px;    background: var(--card-bg);    box-shadow: var(--card-box-shadow);    transition: all 0.3s;  }    #error-wrap .error-content .error-img {    box-flex: 1;    flex: 1;    height: 100%;    border-top-left-radius: 8px;    border-bottom-left-radius: 8px;    background-color: #3b70fc;    background-position: center;    background-size: cover;  }    #error-wrap .error-content .error-info {    box-flex: 1;    flex: 1;    padding: 0.5rem;    text-align: center;    font-size: 14px;    font-family: Titillium Web, "PingFang SC", "Hiragino Sans GB", "Microsoft JhengHei", "Microsoft YaHei", sans-serif;  }  #error-wrap .error-content .error-info .error_title {    margin-top: -4rem;    font-size: 9em;  }  #error-wrap .error-content .error-info .error_subtitle {    margin-top: -3.5rem;    word-break: break-word;    font-size: 1.6em;  }  #error-wrap .error-content .error-info a {    display: inline-block;    margin-top: 0.5rem;    padding: 0.3rem 1.5rem;    background: var(--btn-bg);    color: var(--btn-color);  }    #body-wrap.error .aside-list {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    bottom: 0px;    position: absolute;    padding: 1rem;    width: 100%;    overflow: scroll;  }    #body-wrap.error .aside-list .aside-list-group {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    max-width: 1200px;    margin: 0 auto;  }    #body-wrap.error .aside-list .aside-list-item {    padding: 0.5rem;  }    #body-wrap.error .aside-list .aside-list-item img {    width: 100%;    object-fit: cover;    border-radius: 12px;  }    #body-wrap.error .aside-list .aside-list-item .thumbnail {    overflow: hidden;    width: 230px;    height: 143px;    background: var(--anzhiyu-card-bg);    display: flex;  }    #body-wrap.error .aside-list .aside-list-item .content .title {    -webkit-line-clamp: 2;    overflow: hidden;    display: -webkit-box;    -webkit-box-orient: vertical;    line-height: 1.5;    justify-content: center;    align-items: flex-end;    align-content: center;    padding-top: 0.5rem;    color: white;  }    #body-wrap.error .aside-list .aside-list-item .content time {    display: none;  }    /* 代码框主题 */  #article-container figure.highlight {    border-radius: 10px;  }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>forums</title>
      <link href="/forums/index.html"/>
      <url>/forums/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><a href="https://news.un.org/zh/">联合国新闻</a></li></ul><ul><li><p><a href="https://www.zhihu.com/">知乎</a></p></li><li><p><a href="https://www.csdn.net/">CSDN</a></p></li><li><p><a href="https://github.com/">Github</a></p></li><li><p><a href="https://gitee.com/">码云gitee</a></p></li><li><p><a href="https://blog.waytoagi.com/">WaytoAGI | 人工智能博客</a></p></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>movies</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><h2 id="爱奇艺"><a href="#爱奇艺" class="headerlink" title="爱奇艺"></a><a href="https://www.iqiyi.com/">爱奇艺</a></h2></li><li><h2 id="腾讯视频"><a href="#腾讯视频" class="headerlink" title="腾讯视频"></a><a href="https://v.qq.com/">腾讯视频</a></h2></li><li><h2 id="bilibili"><a href="#bilibili" class="headerlink" title="bilibili"></a><a href="https://www.bilibili.com/">bilibili</a></h2></li><li><h2 id="youtube"><a href="#youtube" class="headerlink" title="youtube"></a><a href="https://www.youtube.com/">youtube</a></h2></li><li><h2 id="豆瓣电影-Top-250"><a href="#豆瓣电影-Top-250" class="headerlink" title="豆瓣电影 Top 250"></a><a href="https://movie.douban.com/top250">豆瓣电影 Top 250</a></h2></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>music</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><p><a href="https://music.163.com/">网易云</a></p></li><li><p><a href="https://soundcloud.com/">soundcloud | 音乐分享和流媒体平台(还可以）</a></p></li><li><p><a href="https://y.qq.com/">QQ音乐</a></p></li><li><p><a href="https://www.kugou.com/">酷狗</a></p></li></ul><hr><ul><li><p><a href="https://www.gugutm.com/">无损音乐源 | 无损音乐下载</a></p></li><li><p><a href="https://www.wotianna.com/">我天哪鸡哥 | 歌手歌曲合集下载（较全）</a></p></li><li><p><a href="https://tools.liumingye.cn/music/#/">MyFreeMP3 | 可下载歌曲（一般）</a></p></li><li><p><a href="https://www.kugeci.com/">酷歌词 | 下载歌词</a></p></li><li><p><a href="https://www.xinjuc.com/yinyue">音乐 - 新剧坊 - 一个网盘资源分享小站</a></p></li><li><p><a href="[瓜牛居士](https://www.guaniumusic.com/index.php">瓜牛居士 | 需要会员（39.9）</a>)</p></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>social</title>
      <link href="/social/index.html"/>
      <url>/social/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="社交平台"><a href="#社交平台" class="headerlink" title="社交平台"></a>社交平台</h1><ul><li><h2 id="微博"><a href="#微博" class="headerlink" title="微博"></a><a href="https://m.weibo.cn/">微博</a></h2></li></ul><h1 id="休闲"><a href="#休闲" class="headerlink" title="休闲"></a>休闲</h1><ul><li><h2 id="五子棋在线玩"><a href="#五子棋在线玩" class="headerlink" title="五子棋在线玩"></a><a href="https://www.wuziqi123.com/">五子棋在线玩</a></h2></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>study</title>
      <link href="/study/index.html"/>
      <url>/study/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>一些本人学习过程中使用的网站</p></blockquote><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><ul><li><p><a href="https://www.runoob.com/html/html-tutorial.html">HTML 教程 | 菜鸟教程</a></p></li><li><p><a href="https://www.jyshare.com/front-end/7688/">HTML 表格生成器 | 菜鸟工具</a></p></li></ul><h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><ul><li><p><a href="https://hexo.io/">Hexo</a></p></li><li><p><a href="https://butterfly.zhheo.com/create.html">从零开始 | Butterfly主题美化教程</a></p></li><li><p><a href="https://butterfly.js.org/">butterfly主题</a></p><p>butterfly魔改的一些博主：</p><ul><li><p><a href="https://blog.anheyu.com/posts/asdx.html">安知鱼</a></p></li><li><p><a href="https://blog.itchenliang.club/posts/3a058e75/#%E7%AB%99%E7%82%B9%E5%9B%BE%E6%A0%87">Butterfly主题安装文档(三)之主题配置2 | 陈亮的个人博客</a></p></li><li><p><a href="https://zsyyblog.com/e109555b.html#%E5%89%8D%E8%A8%80">Hexo博客Butterfly主题配置 | 竹山一叶</a></p></li><li><p><a href="https://www.fomal.cc/posts/3451f874.html">Fomalhaut</a></p></li><li><p><a href="https://blog.dearxuan.com/2023/01/07/Volantis%E9%AD%94%E6%94%B9%E6%95%99%E7%A8%8B/">Volantis魔改教程 - DearXuan的主页</a></p></li><li><p><a href="https://blog.aqcoder.cn/posts/c90c/">Butterfly博客主题搭建系列：进阶教程 | 枫叶</a></p></li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Tools</title>
      <link href="/tools/index.html"/>
      <url>/tools/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h1><ul><li><h2 id="在线证件照换底色工具-UU在线工具"><a href="#在线证件照换底色工具-UU在线工具" class="headerlink" title="在线证件照换底色工具 - UU在线工具"></a><a href="https://uutool.cn/id-photo/">在线证件照换底色工具 - UU在线工具</a></h2><p>提供在线证件照换底色、裁剪等功能，方便用户快速修改照片背景颜色。</p></li><li><h2 id="iLovePDF-为PDF爱好者提供的PDF文件在线处理工具"><a href="#iLovePDF-为PDF爱好者提供的PDF文件在线处理工具" class="headerlink" title="iLovePDF | 为PDF爱好者提供的PDF文件在线处理工具"></a><a href="https://www.ilovepdf.com/zh-cn">iLovePDF | 为PDF爱好者提供的PDF文件在线处理工具</a></h2><p>支持PDF文件的合并、分割、压缩、旋转、转换为其他格式（如Word、Excel、PowerPoint）等。</p></li><li><h2 id="iLoveIMG-图像文件在线编辑工具"><a href="#iLoveIMG-图像文件在线编辑工具" class="headerlink" title="iLoveIMG | 图像文件在线编辑工具"></a><a href="https://www.iloveimg.com/zh-cn">iLoveIMG | 图像文件在线编辑工具</a></h2><p>提供图片压缩、图片格式转换、图片裁剪、添加水印等功能</p></li></ul><h1 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h1><ul><li><h2 id="YouTube视频下载-下载YouTube视频-在线免费-Y2mate"><a href="#YouTube视频下载-下载YouTube视频-在线免费-Y2mate" class="headerlink" title="YouTube视频下载 - 下载YouTube视频 在线免费 | Y2mate"></a><a href="https://www.y2mate.onl/zh-cn/">YouTube视频下载 - 下载YouTube视频 在线免费 | Y2mate</a></h2></li><li><h2 id="哔哩哔哩-AV-BV-互转-av-bv-在线转换-刘明野的工具箱"><a href="#哔哩哔哩-AV-BV-互转-av-bv-在线转换-刘明野的工具箱" class="headerlink" title="哔哩哔哩 AV/BV 互转 av bv 在线转换 - 刘明野的工具箱"></a><a href="https://tool.liumingye.cn/avbv/">哔哩哔哩 AV/BV 互转 av bv 在线转换 - 刘明野的工具箱</a></h2></li><li><h2 id="贝贝BiliBili-免费、免登录、画质清晰"><a href="#贝贝BiliBili-免费、免登录、画质清晰" class="headerlink" title="贝贝BiliBili 免费、免登录、画质清晰"></a><a href="https://xbeibeix.com/api/bilibili/">贝贝BiliBili 免费、免登录、画质清晰</a></h2></li><li><h2 id="哔哩哔哩视频下载-画质一般"><a href="#哔哩哔哩视频下载-画质一般" class="headerlink" title="哔哩哔哩视频下载 | 画质一般"></a><a href="https://snapany.com/zh/bilibili">哔哩哔哩视频下载 | 画质一般</a></h2></li><li><h2 id="解析工具-各平台视频-无水印下载-画质清晰、有次数限制"><a href="#解析工具-各平台视频-无水印下载-画质清晰、有次数限制" class="headerlink" title="解析工具_各平台视频(无水印下载)|画质清晰、有次数限制"></a><a href="https://www.xiazaitool.com/dy">解析工具_各平台视频(无水印下载)|画质清晰、有次数限制</a></h2></li><li><h2 id="人人电影网"><a href="#人人电影网" class="headerlink" title="人人电影网"></a><a href="www.rrdynb.com">人人电影网</a></h2></li><li><h2 id="我天哪鸡哥"><a href="#我天哪鸡哥" class="headerlink" title="我天哪鸡哥"></a><a href="https://www.wotianna.com/">我天哪鸡哥</a></h2></li><li><h2 id="免费资源搜索库"><a href="#免费资源搜索库" class="headerlink" title="免费资源搜索库"></a><a href="https://ysxjjkl.souyisou.top/">免费资源搜索库</a></h2></li><li><h2 id="校长影视"><a href="#校长影视" class="headerlink" title="校长影视"></a><a href="https://mj028.cn/">校长影视</a></h2></li><li><h2 id="短视频-图集在线去水印解析"><a href="#短视频-图集在线去水印解析" class="headerlink" title="短视频/图集在线去水印解析"></a><a href="https://watermark.liumingye.cn/">短视频/图集在线去水印解析</a></h2></li><li><h2 id="FlexClip-从视频中提取音频"><a href="#FlexClip-从视频中提取音频" class="headerlink" title="FlexClip | 从视频中提取音频"></a><a href="https://www.flexclip.com/cn/tools/extract-audio-from-video/">FlexClip | 从视频中提取音频</a></h2></li><li><h2 id="Converter-App-视频转文字工具"><a href="#Converter-App-视频转文字工具" class="headerlink" title="Converter.App | 视频转文字工具"></a><a href="https://converter.app/cn/video-text/">Converter.App | 视频转文字工具</a></h2></li></ul><h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><ul><li><h2 id="Amymind-在线思维导图"><a href="#Amymind-在线思维导图" class="headerlink" title="Amymind | 在线思维导图"></a><a href="https://amymind.com/">Amymind | 在线思维导图</a></h2></li><li><h2 id="LaTeX-Live-在线LaTeX编辑器"><a href="#LaTeX-Live-在线LaTeX编辑器" class="headerlink" title="LaTeX Live | 在线LaTeX编辑器"></a><a href="https://www.latexlive.com/">LaTeX Live | 在线LaTeX编辑器</a></h2></li><li><h2 id="Z-Library"><a href="#Z-Library" class="headerlink" title="Z-Library"></a><a href="https://zh.z-lib.gs/">Z-Library</a></h2></li><li><h2 id="微信读书"><a href="#微信读书" class="headerlink" title="微信读书"></a><a href="https://weread.qq.com/">微信读书</a></h2></li><li><h2 id="小绿鲸英文文献阅读器"><a href="#小绿鲸英文文献阅读器" class="headerlink" title="小绿鲸英文文献阅读器"></a><a href="https://www.xljsci.com/editor/">小绿鲸英文文献阅读器</a></h2></li><li><h2 id="Qwerty-Learner-打字肌肉记忆和英文单词"><a href="#Qwerty-Learner-打字肌肉记忆和英文单词" class="headerlink" title="Qwerty Learner | 打字肌肉记忆和英文单词"></a><a href="https://qwerty.liumingye.cn/">Qwerty Learner | 打字肌肉记忆和英文单词</a></h2></li><li><h2 id="维基百科中文-全球范围的知识和信息"><a href="#维基百科中文-全球范围的知识和信息" class="headerlink" title="维基百科中文 | 全球范围的知识和信息"></a><a href="https://zh.wikipedia.org/zh-hans/">维基百科中文 | 全球范围的知识和信息</a></h2></li></ul><h1 id="GPT及AI："><a href="#GPT及AI：" class="headerlink" title="GPT及AI："></a>GPT及AI：</h1><ul><li><h2 id="OpenAI-Chatgpt"><a href="#OpenAI-Chatgpt" class="headerlink" title="OpenAI-Chatgpt"></a><a href="https://chatgpt.com/">OpenAI-Chatgpt</a></h2></li><li><h2 id="Chatgpt镜像chatos"><a href="#Chatgpt镜像chatos" class="headerlink" title="Chatgpt镜像chatos"></a><a href="https://cat.chatavx.com/">Chatgpt镜像chatos</a></h2></li><li><h2 id="豆包"><a href="#豆包" class="headerlink" title="豆包"></a><a href="https://www.doubao.com/">豆包</a></h2></li><li><h2 id="文心一言"><a href="#文心一言" class="headerlink" title="文心一言"></a><a href="https://yiyan.baidu.com/">文心一言</a></h2></li><li><h2 id="KiMi"><a href="#KiMi" class="headerlink" title="KiMi"></a><a href="https://kimi.moonshot.cn/">KiMi</a></h2></li><li><h2 id="天工"><a href="#天工" class="headerlink" title="天工"></a><a href="https://work.tiangong.cn/">天工</a></h2></li><li><h2 id="AI工具集"><a href="#AI工具集" class="headerlink" title="AI工具集"></a><a href="https://ai-bot.cn/">AI工具集</a></h2></li><li><h2 id="Anakin-ai-One-Stop-AI-App-Platform"><a href="#Anakin-ai-One-Stop-AI-App-Platform" class="headerlink" title="Anakin.ai - One-Stop AI App Platform"></a><a href="https://app.anakin.ai/discover">Anakin.ai - One-Stop AI App Platform</a></h2></li><li><h2 id="Stable-Diffusion-Web-AI图像生成"><a href="#Stable-Diffusion-Web-AI图像生成" class="headerlink" title="Stable Diffusion Web | AI图像生成"></a><a href="https://stablediffusionweb.com/#ai-image-generator">Stable Diffusion Web | AI图像生成</a></h2></li><li><h2 id="Lexica-Stable-Diffusion-图像搜索"><a href="#Lexica-Stable-Diffusion-图像搜索" class="headerlink" title="Lexica | Stable Diffusion 图像搜索"></a><a href="https://lexica.art/">Lexica | Stable Diffusion 图像搜索</a></h2></li><li><h2 id="Leonardo-AI-AI图像生成"><a href="#Leonardo-AI-AI图像生成" class="headerlink" title="Leonardo.AI | AI图像生成"></a><a href="https://app.leonardo.ai/auth/login?callbackUrl=%2F">Leonardo.AI | AI图像生成</a></h2></li><li><h2 id="NoteGPT-免费的-AI-总结工具-和-AI-生成器"><a href="#NoteGPT-免费的-AI-总结工具-和-AI-生成器" class="headerlink" title="NoteGPT | 免费的 AI 总结工具 和 AI 生成器"></a><a href="https://notegpt.io/cn">NoteGPT | 免费的 AI 总结工具 和 AI 生成器</a></h2></li><li><h2 id="AI课代表-支持哔哩哔哩和抖音、西瓜视频的摘要"><a href="#AI课代表-支持哔哩哔哩和抖音、西瓜视频的摘要" class="headerlink" title="AI课代表 | 支持哔哩哔哩和抖音、西瓜视频的摘要"></a><a href="https://www.kedaibiao.pro/welcome">AI课代表 | 支持哔哩哔哩和抖音、西瓜视频的摘要</a></h2></li></ul><h1 id="开发与技术"><a href="#开发与技术" class="headerlink" title="开发与技术"></a>开发与技术</h1><ul><li><h2 id="Netron-可视化神经网络结构"><a href="#Netron-可视化神经网络结构" class="headerlink" title="Netron | 可视化神经网络结构"></a><a href="https://netron.app/">Netron | 可视化神经网络结构</a></h2></li><li><h2 id="Optuna-一个超参数优化框架"><a href="#Optuna-一个超参数优化框架" class="headerlink" title="Optuna: 一个超参数优化框架"></a><a href="https://zh-cn.optuna.org/index.html">Optuna: 一个超参数优化框架</a></h2></li><li><h2 id="Weights-amp-Biases-The-AI-Developer-Platform-可视化深度学习"><a href="#Weights-amp-Biases-The-AI-Developer-Platform-可视化深度学习" class="headerlink" title="Weights &amp; Biases: The AI Developer Platform | 可视化深度学习"></a><a href="https://wandb.ai/site">Weights &amp; Biases: The AI Developer Platform | 可视化深度学习</a></h2></li><li><h2 id="LabML-Annotated-Deep-Learning-Paper-Implementations-提供深度学习经典论文实现的开源项目"><a href="#LabML-Annotated-Deep-Learning-Paper-Implementations-提供深度学习经典论文实现的开源项目" class="headerlink" title="LabML: Annotated Deep Learning Paper Implementations | 提供深度学习经典论文实现的开源项目"></a><a href="https://github.com/labmlai/annotated_deep_learning_paper_implementations?tab=readme-ov-file">LabML: Annotated Deep Learning Paper Implementations | 提供深度学习经典论文实现的开源项目</a></h2></li><li><h2 id="CodeGeeX-智能编程助手"><a href="#CodeGeeX-智能编程助手" class="headerlink" title="CodeGeeX 智能编程助手"></a><a href="https://codegeex.cn/zh-CN">CodeGeeX 智能编程助手</a></h2></li><li><h2 id="NoneBot-聊天机器人"><a href="#NoneBot-聊天机器人" class="headerlink" title="NoneBot | 聊天机器人"></a><a href="https://nb2.baka.icu/">NoneBot | 聊天机器人</a></h2></li></ul><h1 id="科研"><a href="#科研" class="headerlink" title="科研"></a>科研</h1><ul><li><h2 id="知网"><a href="#知网" class="headerlink" title="知网"></a><a href="https://www.cnki.net/">知网</a></h2></li><li><h2 id="万方数据知识服务平台-全球顶尖的知识、学术、科研全流程服务平台"><a href="#万方数据知识服务平台-全球顶尖的知识、学术、科研全流程服务平台" class="headerlink" title="万方数据知识服务平台-全球顶尖的知识、学术、科研全流程服务平台"></a><a href="https://g.wanfangdata.com.cn/index.html">万方数据知识服务平台-全球顶尖的知识、学术、科研全流程服务平台</a></h2></li><li><h2 id="小绿鲸英文文献阅读器-1"><a href="#小绿鲸英文文献阅读器-1" class="headerlink" title="小绿鲸英文文献阅读器"></a><a href="https://www.xljsci.com/editor/">小绿鲸英文文献阅读器</a></h2></li><li><h2 id="txyz"><a href="#txyz" class="headerlink" title="txyz"></a><a href="https://app.txyz.ai/chat">txyz</a></h2></li></ul><h1 id="互联网服务"><a href="#互联网服务" class="headerlink" title="互联网服务"></a>互联网服务</h1><ul><li><h2 id="Panelook-显示面板查询工具"><a href="#Panelook-显示面板查询工具" class="headerlink" title="Panelook | 显示面板查询工具"></a><a href="https://www.panelook.cn/">Panelook | 显示面板查询工具</a></h2></li></ul><h1 id="壁纸"><a href="#壁纸" class="headerlink" title="壁纸"></a>壁纸</h1><ul><li><h2 id="在线电脑壁纸"><a href="#在线电脑壁纸" class="headerlink" title="在线电脑壁纸"></a><a href="https://tool.liumingye.cn/wallpaper/">在线电脑壁纸</a></h2></li></ul><h1 id="工作效率及通信"><a href="#工作效率及通信" class="headerlink" title="工作效率及通信"></a>工作效率及通信</h1><ul><li><h2 id="Slack-团队协作与通讯工具"><a href="#Slack-团队协作与通讯工具" class="headerlink" title="Slack | 团队协作与通讯工具"></a><a href="https://app.slack.com/client/T06DFM619D2/C06CYM8V623">Slack | 团队协作与通讯工具</a></h2></li><li><h2 id="矿大邮箱"><a href="#矿大邮箱" class="headerlink" title="矿大邮箱"></a><a href="http://mail.cumt.edu.cn/">矿大邮箱</a></h2></li></ul><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><ul><li><h2 id="方正字库"><a href="#方正字库" class="headerlink" title="方正字库"></a><a href="https://www.foundertype.com/">方正字库</a></h2></li><li><h2 id="羽兔网-Search"><a href="#羽兔网-Search" class="headerlink" title="羽兔网 - Search"></a><a href="https://www.bing.com/search?q=羽兔网">羽兔网 - Search</a></h2></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>连接彼此的桥梁</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
  
</search>
